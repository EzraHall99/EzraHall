{
    "_frozen_importlib.BuiltinImporter": {
        "function": "BuiltinImporter()",
        "alias": "BuiltinImporter",
        "help": "Help on class BuiltinImporter in module importlib._bootstrap:\n\nclass BuiltinImporter(builtins.object)\n |  Meta path import for built-in modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return None as built-in modules do not have code objects.\n |\n |  get_source(fullname)\n |      Return None as built-in modules do not have source code.\n |\n |  is_package(fullname)\n |      Return False as built-in modules are never packages.\n |\n |  load_module = _load_module_shim(fullname) from _frozen_importlib\n |      Load the specified module into sys.modules and return it.\n |\n |      This method is deprecated.  Use loader.exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Create a built-in module\n |\n |  exec_module(module)\n |      Exec a built-in module\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: BuiltinImporter()",
        "other-params": ""
    },
    "_frozen_importlib.FrozenImporter": {
        "function": "FrozenImporter()",
        "alias": "FrozenImporter",
        "help": "Help on class FrozenImporter in module importlib._bootstrap:\n\nclass FrozenImporter(builtins.object)\n |  Meta path import for frozen modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return the code object for the frozen module.\n |\n |  get_source(fullname)\n |      Return None as frozen modules do not have source code.\n |\n |  is_package(fullname)\n |      Return True if the frozen module is a package.\n |\n |  load_module(fullname)\n |      Load a frozen module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Set __file__, if able.\n |\n |  exec_module(module)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FrozenImporter()",
        "other-params": ""
    },
    "_frozen_importlib.ModuleSpec": {
        "function": "ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "alias": "ModuleSpec",
        "help": "Help on class ModuleSpec in module importlib._bootstrap:\n\nclass ModuleSpec(builtins.object)\n |  ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)\n |\n |  The specification for a module, used for loading.\n |\n |  A module's spec is the source for information about the module.  For\n |  data associated with the module, including source, use the spec's\n |  loader.\n |\n |  `name` is the absolute name of the module.  `loader` is the loader\n |  to use when loading the module.  `parent` is the name of the\n |  package the module is in.  The parent is derived from the name.\n |\n |  `is_package` determines if the module is considered a package or\n |  not.  On modules this is reflected by the `__path__` attribute.\n |\n |  `origin` is the specific location used by the loader from which to\n |  load the module, if that information is available.  When filename is\n |  set, origin will match.\n |\n |  `has_location` indicates that a spec's \"origin\" reflects a location.\n |  When this is True, `__file__` attribute of the module is set.\n |\n |  `cached` is the location of the cached bytecode file, if any.  It\n |  corresponds to the `__cached__` attribute.\n |\n |  `submodule_search_locations` is the sequence of path entries to\n |  search when importing submodules.  If set, is_package should be\n |  True--and False otherwise.\n |\n |  Packages are simply modules that (may) have submodules.  If a spec\n |  has a non-None value in `submodule_search_locations`, the import\n |  system will consider modules loaded from the spec as packages.\n |\n |  Only finders (see importlib.abc.MetaPathFinder and\n |  importlib.abc.PathEntryFinder) should modify ModuleSpec instances.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __init__(self, name, loader, *, origin=None, loader_state=None, is_package=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  parent\n |      The name of the module's parent.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  cached\n |\n |  has_location\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "other-params": ""
    },
    "_frozen_importlib._BlockingOnManager": {
        "function": "_BlockingOnManager(thread_id, lock)",
        "alias": "_BlockingOnManager",
        "help": "Help on class _BlockingOnManager in module importlib._bootstrap:\n\nclass _BlockingOnManager(builtins.object)\n |  _BlockingOnManager(thread_id, lock)\n |\n |  A context manager responsible to updating ``_blocking_on``.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Mark the running thread as waiting for self.lock. via _blocking_on.\n |\n |  __exit__(self, *args, **kwargs)\n |      Remove self.lock from this thread's _blocking_on list.\n |\n |  __init__(self, thread_id, lock)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _BlockingOnManager(thread_id, lock)",
        "other-params": ""
    },
    "_frozen_importlib._DeadlockError": {
        "function": "Error retrieving signature: no signature found for builtin type <class '_frozen_importlib._DeadlockError'>",
        "alias": "_DeadlockError",
        "help": "Help on class _DeadlockError in module importlib._bootstrap:\n\nclass _DeadlockError(builtins.RuntimeError)\n |  Method resolution order:\n |      _DeadlockError\n |      builtins.RuntimeError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.RuntimeError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.RuntimeError:\n |\n |  __new__(*args, **kwargs) class method of builtins.RuntimeError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class '_frozen_importlib._DeadlockError'>",
        "other-params": ""
    },
    "_frozen_importlib._DummyModuleLock": {
        "function": "_DummyModuleLock(name)",
        "alias": "_DummyModuleLock",
        "help": "Help on class _DummyModuleLock in module importlib._bootstrap:\n\nclass _DummyModuleLock(builtins.object)\n |  _DummyModuleLock(name)\n |\n |  A simple _ModuleLock equivalent for Python builds without\n |  multi-threading support.\n |\n |  Methods defined here:\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  acquire(self)\n |\n |  release(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _DummyModuleLock(name)",
        "other-params": ""
    },
    "_frozen_importlib._ImportLockContext": {
        "function": "_ImportLockContext()",
        "alias": "_ImportLockContext",
        "help": "Help on class _ImportLockContext in module importlib._bootstrap:\n\nclass _ImportLockContext(builtins.object)\n |  Context manager for the import lock.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Acquire the import lock.\n |\n |  __exit__(self, exc_type, exc_value, exc_traceback)\n |      Release the import lock regardless of any raised exceptions.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ImportLockContext()",
        "other-params": ""
    },
    "_frozen_importlib._List": {
        "function": "_List(iterable=(), /)",
        "alias": "_List",
        "help": "Help on class _List in module importlib._bootstrap:\n\nclass _List(builtins.list)\n |  _List(iterable=(), /)\n |\n |  # For a list that can have a weakref to it.\n |\n |  Method resolution order:\n |      _List\n |      builtins.list\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.list:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, index, /)\n |      Return self[index].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |\n |  __imul__(self, value, /)\n |      Implement self*=value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the list.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the list in memory, in bytes.\n |\n |  append(self, object, /)\n |      Append object to the end of the list.\n |\n |  clear(self, /)\n |      Remove all items from list.\n |\n |  copy(self, /)\n |      Return a shallow copy of the list.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  extend(self, iterable, /)\n |      Extend list by appending elements from the iterable.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  insert(self, index, object, /)\n |      Insert object before index.\n |\n |  pop(self, index=-1, /)\n |      Remove and return item at index (default last).\n |\n |      Raises IndexError if list is empty or index is out of range.\n |\n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |\n |  sort(self, /, *, key=None, reverse=False)\n |      Sort the list in ascending order and return None.\n |\n |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\n |      order of two equal elements is maintained).\n |\n |      If a key function is given, apply it once to each list item and sort them,\n |      ascending or descending, according to their function values.\n |\n |      The reverse flag can be set to sort in descending order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.list:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.list:\n |\n |  __new__(*args, **kwargs) class method of builtins.list\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.list:\n |\n |  __hash__ = None",
        "syntax": "Syntax: _List(iterable=(), /)",
        "other-params": ""
    },
    "_frozen_importlib._ModuleLock": {
        "function": "_ModuleLock(name)",
        "alias": "_ModuleLock",
        "help": "Help on class _ModuleLock in module importlib._bootstrap:\n\nclass _ModuleLock(builtins.object)\n |  _ModuleLock(name)\n |\n |  A recursive lock implementation which is able to detect deadlocks\n |  (e.g. thread 1 trying to take locks A then B, and thread 2 trying to\n |  take locks B then A).\n |\n |  Methods defined here:\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  acquire(self)\n |      Acquire the module lock.  If a potential deadlock is detected,\n |      a _DeadlockError is raised.\n |      Otherwise, the lock is always acquired and True is returned.\n |\n |  has_deadlock(self)\n |\n |  release(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ModuleLock(name)",
        "other-params": ""
    },
    "_frozen_importlib._ModuleLockManager": {
        "function": "_ModuleLockManager(name)",
        "alias": "_ModuleLockManager",
        "help": "Help on class _ModuleLockManager in module importlib._bootstrap:\n\nclass _ModuleLockManager(builtins.object)\n |  _ModuleLockManager(name)\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *args, **kwargs)\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ModuleLockManager(name)",
        "other-params": ""
    },
    "_frozen_importlib._WeakValueDictionary": {
        "function": "_WeakValueDictionary()",
        "alias": "_WeakValueDictionary",
        "help": "Help on class _WeakValueDictionary in module importlib._bootstrap:\n\nclass _WeakValueDictionary(builtins.object)\n |  # Copied from weakref.py with some simplifications and modifications unique to\n |  # bootstrapping importlib. Many methods were simply deleting for simplicity, so if they\n |  # are needed in the future they may work if simply copied back in.\n |\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  clear(self)\n |\n |  get(self, key, default=None)\n |\n |  setdefault(self, key, default=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _WeakValueDictionary()",
        "other-params": ""
    },
    "_frozen_importlib._builtin_from_name": {
        "function": "_builtin_from_name(name)",
        "alias": "_builtin_from_name",
        "help": "Help on function _builtin_from_name in module importlib._bootstrap:\n\n_builtin_from_name(name)",
        "syntax": "Syntax: _builtin_from_name(name)",
        "other-params": ""
    },
    "_frozen_importlib._calc___package__": {
        "function": "_calc___package__(globals)",
        "alias": "_calc___package__",
        "help": "Help on function _calc___package__ in module importlib._bootstrap:\n\n_calc___package__(globals)\n    Calculate what __package__ should be.\n\n    __package__ is not guaranteed to be defined or could be set to None\n    to represent that its proper value is unknown.",
        "syntax": "Syntax: _calc___package__(globals)",
        "other-params": ""
    },
    "_frozen_importlib._call_with_frames_removed": {
        "function": "_call_with_frames_removed(f, *args, **kwds)",
        "alias": "_call_with_frames_removed",
        "help": "Help on function _call_with_frames_removed in module importlib._bootstrap:\n\n_call_with_frames_removed(f, *args, **kwds)\n    remove_importlib_frames in import.c will always remove sequences\n    of importlib frames that end with a call to this function\n\n    Use it instead of a normal call in places where including the importlib\n    frames introduces unwanted noise into the traceback (e.g. when executing\n    module code)",
        "syntax": "Syntax: _call_with_frames_removed(f, *args, **kwds)",
        "other-params": ""
    },
    "_frozen_importlib._exec": {
        "function": "_exec(spec, module)",
        "alias": "_exec",
        "help": "Help on function _exec in module importlib._bootstrap:\n\n_exec(spec, module)\n    Execute the spec's specified module in an existing module's namespace.",
        "syntax": "Syntax: _exec(spec, module)",
        "other-params": ""
    },
    "_frozen_importlib._find_and_load": {
        "function": "_find_and_load(name, import_)",
        "alias": "_find_and_load",
        "help": "Help on function _find_and_load in module importlib._bootstrap:\n\n_find_and_load(name, import_)\n    Find and load the module.",
        "syntax": "Syntax: _find_and_load(name, import_)",
        "other-params": ""
    },
    "_frozen_importlib._find_and_load_unlocked": {
        "function": "_find_and_load_unlocked(name, import_)",
        "alias": "_find_and_load_unlocked",
        "help": "Help on function _find_and_load_unlocked in module importlib._bootstrap:\n\n_find_and_load_unlocked(name, import_)",
        "syntax": "Syntax: _find_and_load_unlocked(name, import_)",
        "other-params": ""
    },
    "_frozen_importlib._find_spec": {
        "function": "_find_spec(name, path, target=None)",
        "alias": "_find_spec",
        "help": "Help on function _find_spec in module importlib._bootstrap:\n\n_find_spec(name, path, target=None)\n    Find a module's spec.",
        "syntax": "Syntax: _find_spec(name, path, target=None)",
        "other-params": ""
    },
    "_frozen_importlib._gcd_import": {
        "function": "_gcd_import(name, package=None, level=0)",
        "alias": "_gcd_import",
        "help": "Help on function _gcd_import in module importlib._bootstrap:\n\n_gcd_import(name, package=None, level=0)\n    Import and return the module based on its name, the package the call is\n    being made from, and the level adjustment.\n\n    This function represents the greatest common denominator of functionality\n    between import_module and __import__. This includes setting __package__ if\n    the loader did not.",
        "syntax": "Syntax: _gcd_import(name, package=None, level=0)",
        "other-params": ""
    },
    "_frozen_importlib._get_module_lock": {
        "function": "_get_module_lock(name)",
        "alias": "_get_module_lock",
        "help": "Help on function _get_module_lock in module importlib._bootstrap:\n\n_get_module_lock(name)\n    Get or create the module lock for a given module name.\n\n    Acquire/release internally the global import lock to protect\n    _module_locks.",
        "syntax": "Syntax: _get_module_lock(name)",
        "other-params": ""
    },
    "_frozen_importlib._handle_fromlist": {
        "function": "_handle_fromlist(module, fromlist, import_, *, recursive=False)",
        "alias": "_handle_fromlist",
        "help": "Help on function _handle_fromlist in module importlib._bootstrap:\n\n_handle_fromlist(module, fromlist, import_, *, recursive=False)\n    Figure out what __import__ should return.\n\n    The import_ parameter is a callable which takes the name of module to\n    import. It is required to decouple the function from assuming importlib's\n    import implementation is desired.",
        "syntax": "Syntax: _handle_fromlist(module, fromlist, import_, *, recursive=False)",
        "other-params": ""
    },
    "_frozen_importlib._has_deadlocked": {
        "function": "_has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)",
        "alias": "_has_deadlocked",
        "help": "Help on function _has_deadlocked in module importlib._bootstrap:\n\n_has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)\n    Check if 'target_id' is holding the same lock as another thread(s).\n\n    The search within 'blocking_on' starts with the threads listed in\n    'candidate_ids'.  'seen_ids' contains any threads that are considered\n    already traversed in the search.\n\n    Keyword arguments:\n    target_id     -- The thread id to try to reach.\n    seen_ids      -- A set of threads that have already been visited.\n    candidate_ids -- The thread ids from which to begin.\n    blocking_on   -- A dict representing the thread/blocking-on graph.  This may\n                     be the same object as the global '_blocking_on' but it is\n                     a parameter to reduce the impact that global mutable\n                     state has on the result of this function.",
        "syntax": "Syntax: _has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)",
        "other-params": ""
    },
    "_frozen_importlib._init_module_attrs": {
        "function": "_init_module_attrs(spec, module, *, override=False)",
        "alias": "_init_module_attrs",
        "help": "Help on function _init_module_attrs in module importlib._bootstrap:\n\n_init_module_attrs(spec, module, *, override=False)",
        "syntax": "Syntax: _init_module_attrs(spec, module, *, override=False)",
        "other-params": ""
    },
    "_frozen_importlib._install": {
        "function": "_install(sys_module, _imp_module)",
        "alias": "_install",
        "help": "Help on function _install in module importlib._bootstrap:\n\n_install(sys_module, _imp_module)\n    Install importers for builtin and frozen modules",
        "syntax": "Syntax: _install(sys_module, _imp_module)",
        "other-params": ""
    },
    "_frozen_importlib._install_external_importers": {
        "function": "_install_external_importers()",
        "alias": "_install_external_importers",
        "help": "Help on function _install_external_importers in module importlib._bootstrap:\n\n_install_external_importers()\n    Install importers that require external filesystem access",
        "syntax": "Syntax: _install_external_importers()",
        "other-params": ""
    },
    "_frozen_importlib._load": {
        "function": "_load(spec)",
        "alias": "_load",
        "help": "Help on function _load in module importlib._bootstrap:\n\n_load(spec)\n    Return a new module object, loaded by the spec's loader.\n\n    The module is not added to its parent.\n\n    If a module is already in sys.modules, that existing module gets\n    clobbered.",
        "syntax": "Syntax: _load(spec)",
        "other-params": ""
    },
    "_frozen_importlib._load_backward_compatible": {
        "function": "_load_backward_compatible(spec)",
        "alias": "_load_backward_compatible",
        "help": "Help on function _load_backward_compatible in module importlib._bootstrap:\n\n_load_backward_compatible(spec)",
        "syntax": "Syntax: _load_backward_compatible(spec)",
        "other-params": ""
    },
    "_frozen_importlib._load_module_shim": {
        "function": "_load_module_shim(self, fullname)",
        "alias": "_load_module_shim",
        "help": "Help on function _load_module_shim in module importlib._bootstrap:\n\n_load_module_shim(self, fullname)\n    Load the specified module into sys.modules and return it.\n\n    This method is deprecated.  Use loader.exec_module() instead.",
        "syntax": "Syntax: _load_module_shim(self, fullname)",
        "other-params": ""
    },
    "_frozen_importlib._load_unlocked": {
        "function": "_load_unlocked(spec)",
        "alias": "_load_unlocked",
        "help": "Help on function _load_unlocked in module importlib._bootstrap:\n\n_load_unlocked(spec)",
        "syntax": "Syntax: _load_unlocked(spec)",
        "other-params": ""
    },
    "_frozen_importlib._lock_unlock_module": {
        "function": "_lock_unlock_module(name)",
        "alias": "_lock_unlock_module",
        "help": "Help on function _lock_unlock_module in module importlib._bootstrap:\n\n_lock_unlock_module(name)\n    Acquires then releases the module lock for a given module name.\n\n    This is used to ensure a module is completely initialized, in the\n    event it is being imported by another thread.",
        "syntax": "Syntax: _lock_unlock_module(name)",
        "other-params": ""
    },
    "_frozen_importlib._module_repr": {
        "function": "_module_repr(module)",
        "alias": "_module_repr",
        "help": "Help on function _module_repr in module importlib._bootstrap:\n\n_module_repr(module)\n    The implementation of ModuleType.__repr__().",
        "syntax": "Syntax: _module_repr(module)",
        "other-params": ""
    },
    "_frozen_importlib._module_repr_from_spec": {
        "function": "_module_repr_from_spec(spec)",
        "alias": "_module_repr_from_spec",
        "help": "Help on function _module_repr_from_spec in module importlib._bootstrap:\n\n_module_repr_from_spec(spec)\n    Return the repr to use for the module.",
        "syntax": "Syntax: _module_repr_from_spec(spec)",
        "other-params": ""
    },
    "_frozen_importlib._new_module": {
        "function": "_new_module(name)",
        "alias": "_new_module",
        "help": "Help on function _new_module in module importlib._bootstrap:\n\n_new_module(name)",
        "syntax": "Syntax: _new_module(name)",
        "other-params": ""
    },
    "_frozen_importlib._object_name": {
        "function": "_object_name(obj)",
        "alias": "_object_name",
        "help": "Help on function _object_name in module importlib._bootstrap:\n\n_object_name(obj)",
        "syntax": "Syntax: _object_name(obj)",
        "other-params": ""
    },
    "_frozen_importlib._requires_builtin": {
        "function": "_requires_builtin(fxn)",
        "alias": "_requires_builtin",
        "help": "Help on function _requires_builtin in module importlib._bootstrap:\n\n_requires_builtin(fxn)\n    Decorator to verify the named module is built-in.",
        "syntax": "Syntax: _requires_builtin(fxn)",
        "other-params": ""
    },
    "_frozen_importlib._requires_frozen": {
        "function": "_requires_frozen(fxn)",
        "alias": "_requires_frozen",
        "help": "Help on function _requires_frozen in module importlib._bootstrap:\n\n_requires_frozen(fxn)\n    Decorator to verify the named module is frozen.",
        "syntax": "Syntax: _requires_frozen(fxn)",
        "other-params": ""
    },
    "_frozen_importlib._resolve_name": {
        "function": "_resolve_name(name, package, level)",
        "alias": "_resolve_name",
        "help": "Help on function _resolve_name in module importlib._bootstrap:\n\n_resolve_name(name, package, level)\n    Resolve a relative module name to an absolute one.",
        "syntax": "Syntax: _resolve_name(name, package, level)",
        "other-params": ""
    },
    "_frozen_importlib._sanity_check": {
        "function": "_sanity_check(name, package, level)",
        "alias": "_sanity_check",
        "help": "Help on function _sanity_check in module importlib._bootstrap:\n\n_sanity_check(name, package, level)\n    Verify arguments are \"sane\".",
        "syntax": "Syntax: _sanity_check(name, package, level)",
        "other-params": ""
    },
    "_frozen_importlib._setup": {
        "function": "_setup(sys_module, _imp_module)",
        "alias": "_setup",
        "help": "Help on function _setup in module importlib._bootstrap:\n\n_setup(sys_module, _imp_module)\n    Setup importlib by importing needed built-in modules and injecting them\n    into the global namespace.\n\n    As sys is needed for sys.modules access and _imp is needed to load built-in\n    modules, those two modules must be explicitly passed in.",
        "syntax": "Syntax: _setup(sys_module, _imp_module)",
        "other-params": ""
    },
    "_frozen_importlib._spec_from_module": {
        "function": "_spec_from_module(module, loader=None, origin=None)",
        "alias": "_spec_from_module",
        "help": "Help on function _spec_from_module in module importlib._bootstrap:\n\n_spec_from_module(module, loader=None, origin=None)",
        "syntax": "Syntax: _spec_from_module(module, loader=None, origin=None)",
        "other-params": ""
    },
    "_frozen_importlib._verbose_message": {
        "function": "_verbose_message(message, *args, verbosity=1)",
        "alias": "_verbose_message",
        "help": "Help on function _verbose_message in module importlib._bootstrap:\n\n_verbose_message(message, *args, verbosity=1)\n    Print the message to stderr if -v/PYTHONVERBOSE is turned on.",
        "syntax": "Syntax: _verbose_message(message, *args, verbosity=1)",
        "other-params": ""
    },
    "_frozen_importlib._wrap": {
        "function": "_wrap(new, old)",
        "alias": "_wrap",
        "help": "Help on function _wrap in module importlib._bootstrap:\n\n_wrap(new, old)\n    Simple substitute for functools.update_wrapper.",
        "syntax": "Syntax: _wrap(new, old)",
        "other-params": ""
    },
    "_frozen_importlib.module_from_spec": {
        "function": "module_from_spec(spec)",
        "alias": "module_from_spec",
        "help": "Help on function module_from_spec in module importlib._bootstrap:\n\nmodule_from_spec(spec)\n    Create a module based on the provided spec.",
        "syntax": "Syntax: module_from_spec(spec)",
        "other-params": ""
    },
    "_frozen_importlib.spec_from_loader": {
        "function": "spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "alias": "spec_from_loader",
        "help": "Help on function spec_from_loader in module importlib._bootstrap:\n\nspec_from_loader(name, loader, *, origin=None, is_package=None)\n    Return a module spec based on various loader methods.",
        "syntax": "Syntax: spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "other-params": ""
    },
    "_frozen_importlib_external.AppleFrameworkLoader": {
        "function": "AppleFrameworkLoader(name, path)",
        "alias": "AppleFrameworkLoader",
        "help": "Help on class AppleFrameworkLoader in module importlib._bootstrap_external:\n\nclass AppleFrameworkLoader(ExtensionFileLoader)\n |  AppleFrameworkLoader(name, path)\n |\n |  A loader for modules that have been packaged as frameworks for\n |  compatibility with Apple's iOS App Store policies.\n |\n |  Method resolution order:\n |      AppleFrameworkLoader\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from ExtensionFileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: AppleFrameworkLoader(name, path)",
        "other-params": ""
    },
    "_frozen_importlib_external.ExtensionFileLoader": {
        "function": "ExtensionFileLoader(name, path)",
        "alias": "ExtensionFileLoader",
        "help": "Help on class ExtensionFileLoader in module importlib._bootstrap_external:\n\nclass ExtensionFileLoader(FileLoader, _LoaderBasics)\n |  ExtensionFileLoader(name, path)\n |\n |  Loader for extension modules.\n |\n |  The constructor is designed to work with FileFinder.\n |\n |  Method resolution order:\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: ExtensionFileLoader(name, path)",
        "other-params": ""
    },
    "_frozen_importlib_external.FileFinder": {
        "function": "FileFinder(path, *loader_details)",
        "alias": "FileFinder",
        "help": "Help on class FileFinder in module importlib._bootstrap_external:\n\nclass FileFinder(builtins.object)\n |  FileFinder(path, *loader_details)\n |\n |  File-based finder.\n |\n |  Interactions with the file system are cached for performance, being\n |  refreshed when the directory the finder is handling has been modified.\n |\n |  Methods defined here:\n |\n |  __init__(self, path, *loader_details)\n |      Initialize with the path to search on and a variable number of\n |      2-tuples containing the loader and the file suffixes the loader\n |      recognizes.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  find_spec(self, fullname, target=None)\n |      Try to find a spec for the specified module.\n |\n |      Returns the matching spec, or None if not found.\n |\n |  invalidate_caches(self)\n |      Invalidate the directory mtime.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  path_hook(*loader_details)\n |      A class method which returns a closure to use on sys.path_hook\n |      which will return an instance using the specified loaders and the path\n |      called on the closure.\n |\n |      If the path called on the closure is not a directory, ImportError is\n |      raised.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FileFinder(path, *loader_details)",
        "other-params": ""
    },
    "_frozen_importlib_external.FileLoader": {
        "function": "FileLoader(fullname, path)",
        "alias": "FileLoader",
        "help": "Help on class FileLoader in module importlib._bootstrap_external:\n\nclass FileLoader(builtins.object)\n |  FileLoader(fullname, path)\n |\n |  Base file loader class which implements the loader protocol methods that\n |  require file system usage.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FileLoader(fullname, path)",
        "other-params": ""
    },
    "_frozen_importlib_external.NamespaceLoader": {
        "function": "NamespaceLoader(name, path, path_finder)",
        "alias": "NamespaceLoader",
        "help": "Help on class NamespaceLoader in module importlib._bootstrap_external:\n\nclass NamespaceLoader(builtins.object)\n |  NamespaceLoader(name, path, path_finder)\n |\n |  # This class is actually exposed publicly in a namespace package's __loader__\n |  # attribute, so it should be available through a non-private name.\n |  # https://github.com/python/cpython/issues/92054\n |\n |  Methods defined here:\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |\n |  get_code(self, fullname)\n |\n |  get_resource_reader(self, module)\n |\n |  get_source(self, fullname)\n |\n |  is_package(self, fullname)\n |\n |  load_module(self, fullname)\n |      Load a namespace module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: NamespaceLoader(name, path, path_finder)",
        "other-params": ""
    },
    "_frozen_importlib_external.PathFinder": {
        "function": "PathFinder()",
        "alias": "PathFinder",
        "help": "Help on class PathFinder in module importlib._bootstrap_external:\n\nclass PathFinder(builtins.object)\n |  Meta path finder for sys.path and package __path__ attributes.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |      Try to find a spec for 'fullname' on sys.path or 'path'.\n |\n |      The search is based on sys.path_hooks and sys.path_importer_cache.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  find_distributions(*args, **kwargs)\n |      Find distributions.\n |\n |      Return an iterable of all Distribution instances capable of\n |      loading the metadata for packages matching ``context.name``\n |      (or all names if ``None`` indicated) along the paths in the list\n |      of directories ``context.path``.\n |\n |  invalidate_caches()\n |      Call the invalidate_caches() method on all path entry finders\n |      stored in sys.path_importer_cache (where implemented).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: PathFinder()",
        "other-params": ""
    },
    "_frozen_importlib_external.SourceFileLoader": {
        "function": "SourceFileLoader(fullname, path)",
        "alias": "SourceFileLoader",
        "help": "Help on class SourceFileLoader in module importlib._bootstrap_external:\n\nclass SourceFileLoader(FileLoader, SourceLoader)\n |  SourceFileLoader(fullname, path)\n |\n |  Concrete implementation of SourceLoader using the file system.\n |\n |  Method resolution order:\n |      SourceFileLoader\n |      FileLoader\n |      SourceLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  path_stats(self, path)\n |      Return the metadata for the path.\n |\n |  set_data(self, path, data, *, _mode=438)\n |      Write bytes data to a file.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from SourceLoader:\n |\n |  get_code(self, fullname)\n |      Concrete implementation of InspectLoader.get_code.\n |\n |      Reading of bytecode requires path_stats to be implemented. To write\n |      bytecode, set_data must also be implemented.\n |\n |  get_source(self, fullname)\n |      Concrete implementation of InspectLoader.get_source.\n |\n |  path_mtime(self, path)\n |      Optional method that returns the modification time (an int) for the\n |      specified path (a str).\n |\n |      Raises OSError when the path cannot be handled.\n |\n |  source_to_code(self, data, path, *, _optimize=-1)\n |      Return the code object compiled from source.\n |\n |      The 'data' argument can be any object type that compile() supports.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourceFileLoader(fullname, path)",
        "other-params": ""
    },
    "_frozen_importlib_external.SourceLoader": {
        "function": "SourceLoader()",
        "alias": "SourceLoader",
        "help": "Help on class SourceLoader in module importlib._bootstrap_external:\n\nclass SourceLoader(_LoaderBasics)\n |  Method resolution order:\n |      SourceLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  get_code(self, fullname)\n |      Concrete implementation of InspectLoader.get_code.\n |\n |      Reading of bytecode requires path_stats to be implemented. To write\n |      bytecode, set_data must also be implemented.\n |\n |  get_source(self, fullname)\n |      Concrete implementation of InspectLoader.get_source.\n |\n |  path_mtime(self, path)\n |      Optional method that returns the modification time (an int) for the\n |      specified path (a str).\n |\n |      Raises OSError when the path cannot be handled.\n |\n |  path_stats(self, path)\n |      Optional method returning a metadata dict for the specified\n |      path (a str).\n |\n |      Possible keys:\n |      - 'mtime' (mandatory) is the numeric timestamp of last source\n |        code modification;\n |      - 'size' (optional) is the size in bytes of the source code.\n |\n |      Implementing this method allows the loader to read bytecode files.\n |      Raises OSError when the path cannot be handled.\n |\n |  set_data(self, path, data)\n |      Optional method which writes data (bytes) to a file path (a str).\n |\n |      Implementing this method allows for the writing of bytecode files.\n |\n |  source_to_code(self, data, path, *, _optimize=-1)\n |      Return the code object compiled from source.\n |\n |      The 'data' argument can be any object type that compile() supports.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.\n |\n |  load_module(self, fullname)\n |      This method is deprecated.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _LoaderBasics:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: SourceLoader()",
        "other-params": ""
    },
    "_frozen_importlib_external.SourcelessFileLoader": {
        "function": "SourcelessFileLoader(fullname, path)",
        "alias": "SourcelessFileLoader",
        "help": "Help on class SourcelessFileLoader in module importlib._bootstrap_external:\n\nclass SourcelessFileLoader(FileLoader, _LoaderBasics)\n |  SourcelessFileLoader(fullname, path)\n |\n |  Loader which handles sourceless file imports.\n |\n |  Method resolution order:\n |      SourcelessFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  get_code(self, fullname)\n |\n |  get_source(self, fullname)\n |      Return None as there is no source code.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourcelessFileLoader(fullname, path)",
        "other-params": ""
    },
    "_frozen_importlib_external.WindowsRegistryFinder": {
        "function": "WindowsRegistryFinder()",
        "alias": "WindowsRegistryFinder",
        "help": "Help on class WindowsRegistryFinder in module importlib._bootstrap_external:\n\nclass WindowsRegistryFinder(builtins.object)\n |  Meta path finder for modules declared in the Windows registry.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  DEBUG_BUILD = False\n |\n |  REGISTRY_KEY = r'Software\\Python\\PythonCore\\{sys_version}\\Modules\\{ful...\n |\n |  REGISTRY_KEY_DEBUG = r'Software\\Python\\PythonCore\\{sys_version}\\Module...",
        "syntax": "Syntax: WindowsRegistryFinder()",
        "other-params": ""
    },
    "_frozen_importlib_external._LoaderBasics": {
        "function": "_LoaderBasics()",
        "alias": "_LoaderBasics",
        "help": "Help on class _LoaderBasics in module importlib._bootstrap_external:\n\nclass _LoaderBasics(builtins.object)\n |  Base class of common code needed by both SourceLoader and\n |  SourcelessFileLoader.\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.\n |\n |  load_module(self, fullname)\n |      This method is deprecated.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _LoaderBasics()",
        "other-params": ""
    },
    "_frozen_importlib_external._NamespaceLoader": {
        "function": "_NamespaceLoader(name, path, path_finder)",
        "alias": "_NamespaceLoader",
        "help": "Help on class NamespaceLoader in module importlib._bootstrap_external:\n\nclass NamespaceLoader(builtins.object)\n |  NamespaceLoader(name, path, path_finder)\n |\n |  # This class is actually exposed publicly in a namespace package's __loader__\n |  # attribute, so it should be available through a non-private name.\n |  # https://github.com/python/cpython/issues/92054\n |\n |  Methods defined here:\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |\n |  get_code(self, fullname)\n |\n |  get_resource_reader(self, module)\n |\n |  get_source(self, fullname)\n |\n |  is_package(self, fullname)\n |\n |  load_module(self, fullname)\n |      Load a namespace module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _NamespaceLoader(name, path, path_finder)",
        "other-params": ""
    },
    "_frozen_importlib_external._NamespacePath": {
        "function": "_NamespacePath(name, path, path_finder)",
        "alias": "_NamespacePath",
        "help": "Help on class _NamespacePath in module importlib._bootstrap_external:\n\nclass _NamespacePath(builtins.object)\n |  _NamespacePath(name, path, path_finder)\n |\n |  Represents a namespace package's path.  It uses the module name\n |  to find its parent module, and from there it looks up the parent's\n |  __path__.  When this changes, the module's own path is recomputed,\n |  using path_finder.  For top-level modules, the parent module's path\n |  is sys.path.\n |\n |  Methods defined here:\n |\n |  __contains__(self, item)\n |\n |  __getitem__(self, index)\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self)\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __setitem__(self, index, path)\n |\n |  append(self, item)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _NamespacePath(name, path, path_finder)",
        "other-params": ""
    },
    "_frozen_importlib_external._bless_my_loader": {
        "function": "_bless_my_loader(module_globals)",
        "alias": "_bless_my_loader",
        "help": "Help on function _bless_my_loader in module importlib._bootstrap_external:\n\n_bless_my_loader(module_globals)\n    Helper function for _warnings.c\n\n    See GH#97850 for details.",
        "syntax": "Syntax: _bless_my_loader(module_globals)",
        "other-params": ""
    },
    "_frozen_importlib_external._calc_mode": {
        "function": "_calc_mode(path)",
        "alias": "_calc_mode",
        "help": "Help on function _calc_mode in module importlib._bootstrap_external:\n\n_calc_mode(path)\n    Calculate the mode permissions for a bytecode file.",
        "syntax": "Syntax: _calc_mode(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._check_name": {
        "function": "_check_name(method)",
        "alias": "_check_name",
        "help": "Help on function _check_name in module importlib._bootstrap_external:\n\n_check_name(method)\n    Decorator to verify that the module being requested matches the one the\n    loader can handle.\n\n    The first argument (self) must define _name which the second argument is\n    compared against. If the comparison fails then ImportError is raised.",
        "syntax": "Syntax: _check_name(method)",
        "other-params": ""
    },
    "_frozen_importlib_external._classify_pyc": {
        "function": "_classify_pyc(data, name, exc_details)",
        "alias": "_classify_pyc",
        "help": "Help on function _classify_pyc in module importlib._bootstrap_external:\n\n_classify_pyc(data, name, exc_details)\n    Perform basic validity checking of a pyc header and return the flags field,\n    which determines how the pyc should be further validated against the source.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required, though.)\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    ImportError is raised when the magic number is incorrect or when the flags\n    field is invalid. EOFError is raised when the data is found to be truncated.",
        "syntax": "Syntax: _classify_pyc(data, name, exc_details)",
        "other-params": ""
    },
    "_frozen_importlib_external._code_to_hash_pyc": {
        "function": "_code_to_hash_pyc(code, source_hash, checked=True)",
        "alias": "_code_to_hash_pyc",
        "help": "Help on function _code_to_hash_pyc in module importlib._bootstrap_external:\n\n_code_to_hash_pyc(code, source_hash, checked=True)\n    Produce the data for a hash-based pyc.",
        "syntax": "Syntax: _code_to_hash_pyc(code, source_hash, checked=True)",
        "other-params": ""
    },
    "_frozen_importlib_external._code_to_timestamp_pyc": {
        "function": "_code_to_timestamp_pyc(code, mtime=0, source_size=0)",
        "alias": "_code_to_timestamp_pyc",
        "help": "Help on function _code_to_timestamp_pyc in module importlib._bootstrap_external:\n\n_code_to_timestamp_pyc(code, mtime=0, source_size=0)\n    Produce the data for a timestamp-based pyc.",
        "syntax": "Syntax: _code_to_timestamp_pyc(code, mtime=0, source_size=0)",
        "other-params": ""
    },
    "_frozen_importlib_external._code_type": {
        "function": "_code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "alias": "_code_type",
        "help": "Help on class code in module builtins:\n\nclass code(object)\n |  code(\n |      argcount,\n |      posonlyargcount,\n |      kwonlyargcount,\n |      nlocals,\n |      stacksize,\n |      flags,\n |      codestring,\n |      constants,\n |      names,\n |      varnames,\n |      filename,\n |      name,\n |      qualname,\n |      firstlineno,\n |      linetable,\n |      exceptiontable,\n |      freevars=(),\n |      cellvars=(),\n |      /\n |  )\n |\n |  Create a code object.  Not for the faint of heart.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __replace__(self, /, **changes)\n |      The same as replace().\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  co_lines(self, /)\n |\n |  co_positions(self, /)\n |\n |  replace(self, /, **changes)\n |      Return a copy of the code object with new values for the specified fields.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  co_argcount\n |\n |  co_cellvars\n |\n |  co_code\n |\n |  co_consts\n |\n |  co_exceptiontable\n |\n |  co_filename\n |\n |  co_firstlineno\n |\n |  co_flags\n |\n |  co_freevars\n |\n |  co_kwonlyargcount\n |\n |  co_linetable\n |\n |  co_lnotab\n |\n |  co_name\n |\n |  co_names\n |\n |  co_nlocals\n |\n |  co_posonlyargcount\n |\n |  co_qualname\n |\n |  co_stacksize\n |\n |  co_varnames",
        "syntax": "Syntax: _code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "other-params": ""
    },
    "_frozen_importlib_external._compile_bytecode": {
        "function": "_compile_bytecode(data, name=None, bytecode_path=None, source_path=None)",
        "alias": "_compile_bytecode",
        "help": "Help on function _compile_bytecode in module importlib._bootstrap_external:\n\n_compile_bytecode(data, name=None, bytecode_path=None, source_path=None)\n    Compile bytecode as found in a pyc.",
        "syntax": "Syntax: _compile_bytecode(data, name=None, bytecode_path=None, source_path=None)",
        "other-params": ""
    },
    "_frozen_importlib_external._fix_up_module": {
        "function": "_fix_up_module(ns, name, pathname, cpathname=None)",
        "alias": "_fix_up_module",
        "help": "Help on function _fix_up_module in module importlib._bootstrap_external:\n\n_fix_up_module(ns, name, pathname, cpathname=None)",
        "syntax": "Syntax: _fix_up_module(ns, name, pathname, cpathname=None)",
        "other-params": ""
    },
    "_frozen_importlib_external._get_cached": {
        "function": "_get_cached(filename)",
        "alias": "_get_cached",
        "help": "Help on function _get_cached in module importlib._bootstrap_external:\n\n_get_cached(filename)",
        "syntax": "Syntax: _get_cached(filename)",
        "other-params": ""
    },
    "_frozen_importlib_external._get_sourcefile": {
        "function": "_get_sourcefile(bytecode_path)",
        "alias": "_get_sourcefile",
        "help": "Help on function _get_sourcefile in module importlib._bootstrap_external:\n\n_get_sourcefile(bytecode_path)\n    Convert a bytecode file path to a source path (if possible).\n\n    This function exists purely for backwards-compatibility for\n    PyImport_ExecCodeModuleWithFilenames() in the C API.",
        "syntax": "Syntax: _get_sourcefile(bytecode_path)",
        "other-params": ""
    },
    "_frozen_importlib_external._get_supported_file_loaders": {
        "function": "_get_supported_file_loaders()",
        "alias": "_get_supported_file_loaders",
        "help": "Help on function _get_supported_file_loaders in module importlib._bootstrap_external:\n\n_get_supported_file_loaders()\n    Returns a list of file-based module loaders.\n\n    Each item is a tuple (loader, suffixes).",
        "syntax": "Syntax: _get_supported_file_loaders()",
        "other-params": ""
    },
    "_frozen_importlib_external._install": {
        "function": "_install(_bootstrap_module)",
        "alias": "_install",
        "help": "Help on function _install in module importlib._bootstrap_external:\n\n_install(_bootstrap_module)\n    Install the path-based import components.",
        "syntax": "Syntax: _install(_bootstrap_module)",
        "other-params": ""
    },
    "_frozen_importlib_external._make_relax_case": {
        "function": "_make_relax_case()",
        "alias": "_make_relax_case",
        "help": "Help on function _make_relax_case in module importlib._bootstrap_external:\n\n_make_relax_case()",
        "syntax": "Syntax: _make_relax_case()",
        "other-params": ""
    },
    "_frozen_importlib_external._pack_uint32": {
        "function": "_pack_uint32(x)",
        "alias": "_pack_uint32",
        "help": "Help on function _pack_uint32 in module importlib._bootstrap_external:\n\n_pack_uint32(x)\n    Convert a 32-bit integer to little-endian.",
        "syntax": "Syntax: _pack_uint32(x)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_abspath": {
        "function": "_path_abspath(path)",
        "alias": "_path_abspath",
        "help": "Help on function _path_abspath in module importlib._bootstrap_external:\n\n_path_abspath(path)\n    Replacement for os.path.abspath.",
        "syntax": "Syntax: _path_abspath(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_is_mode_type": {
        "function": "_path_is_mode_type(path, mode)",
        "alias": "_path_is_mode_type",
        "help": "Help on function _path_is_mode_type in module importlib._bootstrap_external:\n\n_path_is_mode_type(path, mode)\n    Test whether the path is the specified mode type.",
        "syntax": "Syntax: _path_is_mode_type(path, mode)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_isabs": {
        "function": "_path_isabs(path)",
        "alias": "_path_isabs",
        "help": "Help on function _path_isabs in module importlib._bootstrap_external:\n\n_path_isabs(path)\n    Replacement for os.path.isabs.",
        "syntax": "Syntax: _path_isabs(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_isdir": {
        "function": "_path_isdir(path)",
        "alias": "_path_isdir",
        "help": "Help on function _path_isdir in module importlib._bootstrap_external:\n\n_path_isdir(path)\n    Replacement for os.path.isdir.",
        "syntax": "Syntax: _path_isdir(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_isfile": {
        "function": "_path_isfile(path)",
        "alias": "_path_isfile",
        "help": "Help on function _path_isfile in module importlib._bootstrap_external:\n\n_path_isfile(path)\n    Replacement for os.path.isfile.",
        "syntax": "Syntax: _path_isfile(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_join": {
        "function": "_path_join(*path_parts)",
        "alias": "_path_join",
        "help": "Help on function _path_join in module importlib._bootstrap_external:\n\n_path_join(*path_parts)\n    Replacement for os.path.join().",
        "syntax": "Syntax: _path_join(*path_parts)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_split": {
        "function": "_path_split(path)",
        "alias": "_path_split",
        "help": "Help on function _path_split in module importlib._bootstrap_external:\n\n_path_split(path)\n    Replacement for os.path.split().",
        "syntax": "Syntax: _path_split(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._path_stat": {
        "function": "_path_stat(path)",
        "alias": "_path_stat",
        "help": "Help on function _path_stat in module importlib._bootstrap_external:\n\n_path_stat(path)\n    Stat the path.\n\n    Made a separate function to make it easier to override in experiments\n    (e.g. cache stat results).",
        "syntax": "Syntax: _path_stat(path)",
        "other-params": ""
    },
    "_frozen_importlib_external._relax_case": {
        "function": "_relax_case()",
        "alias": "_relax_case",
        "help": "Help on function _relax_case in module importlib._bootstrap_external:\n\n_relax_case()\n    True if filenames must be checked case-insensitively and ignore environment flags are not set.",
        "syntax": "Syntax: _relax_case()",
        "other-params": ""
    },
    "_frozen_importlib_external._set_bootstrap_module": {
        "function": "_set_bootstrap_module(_bootstrap_module)",
        "alias": "_set_bootstrap_module",
        "help": "Help on function _set_bootstrap_module in module importlib._bootstrap_external:\n\n_set_bootstrap_module(_bootstrap_module)",
        "syntax": "Syntax: _set_bootstrap_module(_bootstrap_module)",
        "other-params": ""
    },
    "_frozen_importlib_external._unpack_uint16": {
        "function": "_unpack_uint16(data)",
        "alias": "_unpack_uint16",
        "help": "Help on function _unpack_uint16 in module importlib._bootstrap_external:\n\n_unpack_uint16(data)\n    Convert 2 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint16(data)",
        "other-params": ""
    },
    "_frozen_importlib_external._unpack_uint32": {
        "function": "_unpack_uint32(data)",
        "alias": "_unpack_uint32",
        "help": "Help on function _unpack_uint32 in module importlib._bootstrap_external:\n\n_unpack_uint32(data)\n    Convert 4 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint32(data)",
        "other-params": ""
    },
    "_frozen_importlib_external._unpack_uint64": {
        "function": "_unpack_uint64(data)",
        "alias": "_unpack_uint64",
        "help": "Help on function _unpack_uint64 in module importlib._bootstrap_external:\n\n_unpack_uint64(data)\n    Convert 8 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint64(data)",
        "other-params": ""
    },
    "_frozen_importlib_external._validate_hash_pyc": {
        "function": "_validate_hash_pyc(data, source_hash, name, exc_details)",
        "alias": "_validate_hash_pyc",
        "help": "Help on function _validate_hash_pyc in module importlib._bootstrap_external:\n\n_validate_hash_pyc(data, source_hash, name, exc_details)\n    Validate a hash-based pyc by checking the real source hash against the one in\n    the pyc header.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required.)\n\n    *source_hash* is the importlib.util.source_hash() of the source file.\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    An ImportError is raised if the bytecode is stale.",
        "syntax": "Syntax: _validate_hash_pyc(data, source_hash, name, exc_details)",
        "other-params": ""
    },
    "_frozen_importlib_external._validate_timestamp_pyc": {
        "function": "_validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)",
        "alias": "_validate_timestamp_pyc",
        "help": "Help on function _validate_timestamp_pyc in module importlib._bootstrap_external:\n\n_validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)\n    Validate a pyc against the source last-modified time.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required.)\n\n    *source_mtime* is the last modified timestamp of the source file.\n\n    *source_size* is None or the size of the source file in bytes.\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    An ImportError is raised if the bytecode is stale.",
        "syntax": "Syntax: _validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)",
        "other-params": ""
    },
    "_frozen_importlib_external._write_atomic": {
        "function": "_write_atomic(path, data, mode=438)",
        "alias": "_write_atomic",
        "help": "Help on function _write_atomic in module importlib._bootstrap_external:\n\n_write_atomic(path, data, mode=438)\n    Best-effort function to write data to a path atomically.\n    Be prepared to handle a FileExistsError if concurrent writing of the\n    temporary file is attempted.",
        "syntax": "Syntax: _write_atomic(path, data, mode=438)",
        "other-params": ""
    },
    "_frozen_importlib_external.cache_from_source": {
        "function": "cache_from_source(path, debug_override=None, *, optimization=None)",
        "alias": "cache_from_source",
        "help": "Help on function cache_from_source in module importlib._bootstrap_external:\n\ncache_from_source(path, debug_override=None, *, optimization=None)\n    Given the path to a .py file, return the path to its .pyc file.\n\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError\n    is raised).\n\n    The debug_override parameter is deprecated. If debug_override is not None,\n    a True value is the same as setting 'optimization' to the empty string\n    while a False value is equivalent to setting 'optimization' to '1'.\n\n    If sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: cache_from_source(path, debug_override=None, *, optimization=None)",
        "other-params": ""
    },
    "_frozen_importlib_external.decode_source": {
        "function": "decode_source(source_bytes)",
        "alias": "decode_source",
        "help": "Help on function decode_source in module importlib._bootstrap_external:\n\ndecode_source(source_bytes)\n    Decode bytes representing source code and return the string.\n\n    Universal newline support is used in the decoding.",
        "syntax": "Syntax: decode_source(source_bytes)",
        "other-params": ""
    },
    "_frozen_importlib_external.source_from_cache": {
        "function": "source_from_cache(path)",
        "alias": "source_from_cache",
        "help": "Help on function source_from_cache in module importlib._bootstrap_external:\n\nsource_from_cache(path)\n    Given the path to a .pyc. file, return the path to its .py file.\n\n    The .pyc file does not need to exist; this simply returns the path to\n    the .py file calculated to correspond to the .pyc file.  If path does\n    not conform to PEP 3147/488 format, ValueError will be raised. If\n    sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: source_from_cache(path)",
        "other-params": ""
    },
    "_frozen_importlib_external.spec_from_file_location": {
        "function": "spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "alias": "spec_from_file_location",
        "help": "Help on function spec_from_file_location in module importlib._bootstrap_external:\n\nspec_from_file_location(\n    name,\n    location=None,\n    *,\n    loader=None,\n    submodule_search_locations=<object object at 0x000001950D0901C0>\n)\n    Return a module spec based on a file location.\n\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n\n    The loader must take a spec as its only __init__() arg.",
        "syntax": "Syntax: spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "other-params": ""
    },
    "zipimport.ZipImportError": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'zipimport.ZipImportError'>",
        "alias": "ZipImportError",
        "help": "Help on class ZipImportError in module zipimport:\n\nclass ZipImportError(builtins.ImportError)\n |  Method resolution order:\n |      ZipImportError\n |      builtins.ImportError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.ImportError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.ImportError:\n |\n |  msg\n |      exception message\n |\n |  name\n |      module name\n |\n |  name_from\n |      name imported from module\n |\n |  path\n |      module path\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'zipimport.ZipImportError'>",
        "other-params": ""
    },
    "zipimport._code_type": {
        "function": "_code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "alias": "_code_type",
        "help": "Help on class code in module builtins:\n\nclass code(object)\n |  code(\n |      argcount,\n |      posonlyargcount,\n |      kwonlyargcount,\n |      nlocals,\n |      stacksize,\n |      flags,\n |      codestring,\n |      constants,\n |      names,\n |      varnames,\n |      filename,\n |      name,\n |      qualname,\n |      firstlineno,\n |      linetable,\n |      exceptiontable,\n |      freevars=(),\n |      cellvars=(),\n |      /\n |  )\n |\n |  Create a code object.  Not for the faint of heart.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __replace__(self, /, **changes)\n |      The same as replace().\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  co_lines(self, /)\n |\n |  co_positions(self, /)\n |\n |  replace(self, /, **changes)\n |      Return a copy of the code object with new values for the specified fields.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  co_argcount\n |\n |  co_cellvars\n |\n |  co_code\n |\n |  co_consts\n |\n |  co_exceptiontable\n |\n |  co_filename\n |\n |  co_firstlineno\n |\n |  co_flags\n |\n |  co_freevars\n |\n |  co_kwonlyargcount\n |\n |  co_linetable\n |\n |  co_lnotab\n |\n |  co_name\n |\n |  co_names\n |\n |  co_nlocals\n |\n |  co_posonlyargcount\n |\n |  co_qualname\n |\n |  co_stacksize\n |\n |  co_varnames",
        "syntax": "Syntax: _code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "other-params": ""
    },
    "zipimport._compile_source": {
        "function": "_compile_source(pathname, source)",
        "alias": "_compile_source",
        "help": "Help on function _compile_source in module zipimport:\n\n_compile_source(pathname, source)",
        "syntax": "Syntax: _compile_source(pathname, source)",
        "other-params": ""
    },
    "zipimport._eq_mtime": {
        "function": "_eq_mtime(t1, t2)",
        "alias": "_eq_mtime",
        "help": "Help on function _eq_mtime in module zipimport:\n\n_eq_mtime(t1, t2)",
        "syntax": "Syntax: _eq_mtime(t1, t2)",
        "other-params": ""
    },
    "zipimport._get_data": {
        "function": "_get_data(archive, toc_entry)",
        "alias": "_get_data",
        "help": "Help on function _get_data in module zipimport:\n\n_get_data(archive, toc_entry)",
        "syntax": "Syntax: _get_data(archive, toc_entry)",
        "other-params": ""
    },
    "zipimport._get_decompress_func": {
        "function": "_get_decompress_func()",
        "alias": "_get_decompress_func",
        "help": "Help on function _get_decompress_func in module zipimport:\n\n_get_decompress_func()",
        "syntax": "Syntax: _get_decompress_func()",
        "other-params": ""
    },
    "zipimport._get_module_code": {
        "function": "_get_module_code(self, fullname)",
        "alias": "_get_module_code",
        "help": "Help on function _get_module_code in module zipimport:\n\n_get_module_code(self, fullname)",
        "syntax": "Syntax: _get_module_code(self, fullname)",
        "other-params": ""
    },
    "zipimport._get_module_info": {
        "function": "_get_module_info(self, fullname)",
        "alias": "_get_module_info",
        "help": "Help on function _get_module_info in module zipimport:\n\n_get_module_info(self, fullname)",
        "syntax": "Syntax: _get_module_info(self, fullname)",
        "other-params": ""
    },
    "zipimport._get_module_path": {
        "function": "_get_module_path(self, fullname)",
        "alias": "_get_module_path",
        "help": "Help on function _get_module_path in module zipimport:\n\n_get_module_path(self, fullname)",
        "syntax": "Syntax: _get_module_path(self, fullname)",
        "other-params": ""
    },
    "zipimport._get_mtime_and_size_of_source": {
        "function": "_get_mtime_and_size_of_source(self, path)",
        "alias": "_get_mtime_and_size_of_source",
        "help": "Help on function _get_mtime_and_size_of_source in module zipimport:\n\n_get_mtime_and_size_of_source(self, path)",
        "syntax": "Syntax: _get_mtime_and_size_of_source(self, path)",
        "other-params": ""
    },
    "zipimport._get_pyc_source": {
        "function": "_get_pyc_source(self, path)",
        "alias": "_get_pyc_source",
        "help": "Help on function _get_pyc_source in module zipimport:\n\n_get_pyc_source(self, path)",
        "syntax": "Syntax: _get_pyc_source(self, path)",
        "other-params": ""
    },
    "zipimport._is_dir": {
        "function": "_is_dir(self, path)",
        "alias": "_is_dir",
        "help": "Help on function _is_dir in module zipimport:\n\n_is_dir(self, path)",
        "syntax": "Syntax: _is_dir(self, path)",
        "other-params": ""
    },
    "zipimport._module_type": {
        "function": "_module_type(name, doc=None)",
        "alias": "_module_type",
        "help": "Help on class module in module builtins:\n\nclass module(object)\n |  module(name, doc=None)\n |\n |  Create a module object.\n |\n |  The name must be a string; the optional doc argument can have any type.\n |\n |  Methods defined here:\n |\n |  __dir__(self, /)\n |      __dir__() -> list\n |      specialized dir() implementation\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __dict__",
        "syntax": "Syntax: _module_type(name, doc=None)",
        "other-params": ""
    },
    "zipimport._normalize_line_endings": {
        "function": "_normalize_line_endings(source)",
        "alias": "_normalize_line_endings",
        "help": "Help on function _normalize_line_endings in module zipimport:\n\n_normalize_line_endings(source)",
        "syntax": "Syntax: _normalize_line_endings(source)",
        "other-params": ""
    },
    "zipimport._parse_dostime": {
        "function": "_parse_dostime(d, t)",
        "alias": "_parse_dostime",
        "help": "Help on function _parse_dostime in module zipimport:\n\n_parse_dostime(d, t)",
        "syntax": "Syntax: _parse_dostime(d, t)",
        "other-params": ""
    },
    "zipimport._read_directory": {
        "function": "_read_directory(archive)",
        "alias": "_read_directory",
        "help": "Help on function _read_directory in module zipimport:\n\n_read_directory(archive)",
        "syntax": "Syntax: _read_directory(archive)",
        "other-params": ""
    },
    "zipimport._unmarshal_code": {
        "function": "_unmarshal_code(self, pathname, fullpath, fullname, data)",
        "alias": "_unmarshal_code",
        "help": "Help on function _unmarshal_code in module zipimport:\n\n_unmarshal_code(self, pathname, fullpath, fullname, data)",
        "syntax": "Syntax: _unmarshal_code(self, pathname, fullpath, fullname, data)",
        "other-params": ""
    },
    "zipimport._unpack_uint16": {
        "function": "_unpack_uint16(data)",
        "alias": "_unpack_uint16",
        "help": "Help on function _unpack_uint16 in module importlib._bootstrap_external:\n\n_unpack_uint16(data)\n    Convert 2 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint16(data)",
        "other-params": ""
    },
    "zipimport._unpack_uint32": {
        "function": "_unpack_uint32(data)",
        "alias": "_unpack_uint32",
        "help": "Help on function _unpack_uint32 in module importlib._bootstrap_external:\n\n_unpack_uint32(data)\n    Convert 4 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint32(data)",
        "other-params": ""
    },
    "zipimport._unpack_uint64": {
        "function": "_unpack_uint64(data)",
        "alias": "_unpack_uint64",
        "help": "Help on function _unpack_uint64 in module importlib._bootstrap_external:\n\n_unpack_uint64(data)\n    Convert 8 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint64(data)",
        "other-params": ""
    },
    "zipimport.zipimporter": {
        "function": "zipimporter(path)",
        "alias": "zipimporter",
        "help": "Help on class zipimporter in module zipimport:\n\nclass zipimporter(_frozen_importlib_external._LoaderBasics)\n |  zipimporter(path)\n |\n |  zipimporter(archivepath) -> zipimporter object\n |\n |  Create a new zipimporter instance. 'archivepath' must be a path to\n |  a zipfile, or to a specific path inside a zipfile. For example, it can be\n |  '/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\n |  valid directory inside the archive.\n |\n |  'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\n |  archive.\n |\n |  The 'archive' attribute of zipimporter objects contains the name of the\n |  zipfile targeted.\n |\n |  Method resolution order:\n |      zipimporter\n |      _frozen_importlib_external._LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, path)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  find_spec(self, fullname, target=None)\n |      Create a ModuleSpec for the specified module.\n |\n |      Returns None if the module cannot be found.\n |\n |  get_code(self, fullname)\n |      get_code(fullname) -> code object.\n |\n |      Return the code object for the specified module. Raise ZipImportError\n |      if the module couldn't be imported.\n |\n |  get_data(self, pathname)\n |      get_data(pathname) -> string with file data.\n |\n |      Return the data associated with 'pathname'. Raise OSError if\n |      the file wasn't found.\n |\n |  get_filename(self, fullname)\n |      get_filename(fullname) -> filename string.\n |\n |      Return the filename for the specified module or raise ZipImportError\n |      if it couldn't be imported.\n |\n |  get_resource_reader(self, fullname)\n |      Return the ResourceReader for a module in a zip file.\n |\n |  get_source(self, fullname)\n |      get_source(fullname) -> source string.\n |\n |      Return the source code for the specified module. Raise ZipImportError\n |      if the module couldn't be found, return None if the archive does\n |      contain the module, but has no source for it.\n |\n |  invalidate_caches(self)\n |      Invalidates the cache of file data of the archive path.\n |\n |  is_package(self, fullname)\n |      is_package(fullname) -> bool.\n |\n |      Return True if the module specified by fullname is a package.\n |      Raise ZipImportError if the module couldn't be found.\n |\n |  load_module(self, fullname)\n |      load_module(fullname) -> module.\n |\n |      Load the module specified by 'fullname'. 'fullname' must be the\n |      fully qualified (dotted) module name. It returns the imported\n |      module, or raises ZipImportError if it could not be imported.\n |\n |      Deprecated since Python 3.10. Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _frozen_importlib_external._LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _frozen_importlib_external._LoaderBasics:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: zipimporter(path)",
        "other-params": ""
    },
    "codecs.BufferedIncrementalDecoder": {
        "function": "BufferedIncrementalDecoder(errors='strict')",
        "alias": "BufferedIncrementalDecoder",
        "help": "Help on class BufferedIncrementalDecoder in module codecs:\n\nclass BufferedIncrementalDecoder(IncrementalDecoder)\n |  BufferedIncrementalDecoder(errors='strict')\n |\n |  This subclass of IncrementalDecoder can be used as the baseclass for an\n |  incremental decoder if the decoder must be able to handle incomplete\n |  byte sequences.\n |\n |  Method resolution order:\n |      BufferedIncrementalDecoder\n |      IncrementalDecoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Create an IncrementalDecoder instance.\n |\n |      The IncrementalDecoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  decode(self, input, final=False)\n |      Decode input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the decoder.\n |\n |      This must be a (buffered_input, additional_state_info) tuple.\n |      buffered_input must be a bytes object containing bytes that\n |      were passed to decode() that have not yet been converted.\n |      additional_state_info must be a non-negative integer\n |      representing the state of the decoder WITHOUT yet having\n |      processed the contents of buffered_input.  In the initial state\n |      and after reset(), getstate() must return (b\"\", 0).\n |\n |  reset(self)\n |      Reset the decoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the decoder.\n |\n |      state must have been returned by getstate().  The effect of\n |      setstate((b\"\", 0)) must be equivalent to reset().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from IncrementalDecoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: BufferedIncrementalDecoder(errors='strict')",
        "other-params": ""
    },
    "codecs.BufferedIncrementalEncoder": {
        "function": "BufferedIncrementalEncoder(errors='strict')",
        "alias": "BufferedIncrementalEncoder",
        "help": "Help on class BufferedIncrementalEncoder in module codecs:\n\nclass BufferedIncrementalEncoder(IncrementalEncoder)\n |  BufferedIncrementalEncoder(errors='strict')\n |\n |  This subclass of IncrementalEncoder can be used as the baseclass for an\n |  incremental encoder if the encoder must keep some of the output in a\n |  buffer between calls to encode().\n |\n |  Method resolution order:\n |      BufferedIncrementalEncoder\n |      IncrementalEncoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Creates an IncrementalEncoder instance.\n |\n |      The IncrementalEncoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  encode(self, input, final=False)\n |      Encodes input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the encoder.\n |\n |  reset(self)\n |      Resets the encoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the encoder. state must have been\n |      returned by getstate().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from IncrementalEncoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: BufferedIncrementalEncoder(errors='strict')",
        "other-params": ""
    },
    "codecs.Codec": {
        "function": "Codec()",
        "alias": "Codec",
        "help": "Help on class Codec in module codecs:\n\nclass Codec(builtins.object)\n |  Defines the interface for stateless encoders/decoders.\n |\n |  The .encode()/.decode() methods may use different error\n |  handling schemes by providing the errors argument. These\n |  string values are predefined:\n |\n |   'strict' - raise a ValueError error (or a subclass)\n |   'ignore' - ignore the character and continue with the next\n |   'replace' - replace with a suitable replacement character;\n |              Python will use the official U+FFFD REPLACEMENT\n |              CHARACTER for the builtin Unicode codecs on\n |              decoding and '?' on encoding.\n |   'surrogateescape' - replace with private code points U+DCnn.\n |   'xmlcharrefreplace' - Replace with the appropriate XML\n |                         character reference (only for encoding).\n |   'backslashreplace'  - Replace with backslashed escape sequences.\n |   'namereplace'       - Replace with \\N{...} escape sequences\n |                         (only for encoding).\n |\n |  The set of allowed values can be extended via register_error.\n |\n |  Methods defined here:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Codec()",
        "other-params": ""
    },
    "codecs.CodecInfo": {
        "function": "CodecInfo(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None, *, _is_text_encoding=None)",
        "alias": "CodecInfo",
        "help": "Help on class CodecInfo in module codecs:\n\nclass CodecInfo(builtins.tuple)\n |  CodecInfo(\n |      encode,\n |      decode,\n |      streamreader=None,\n |      streamwriter=None,\n |      incrementalencoder=None,\n |      incrementaldecoder=None,\n |      name=None,\n |      *,\n |      _is_text_encoding=None\n |  )\n |\n |  Codec details when looking up the codec registry\n |\n |  Method resolution order:\n |      CodecInfo\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getnewargs__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(\n |      cls,\n |      encode,\n |      decode,\n |      streamreader=None,\n |      streamwriter=None,\n |      incrementalencoder=None,\n |      incrementaldecoder=None,\n |      name=None,\n |      *,\n |      _is_text_encoding=None\n |  )\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: CodecInfo(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None, *, _is_text_encoding=None)",
        "other-params": ""
    },
    "codecs.EncodedFile": {
        "function": "EncodedFile(file, data_encoding, file_encoding=None, errors='strict')",
        "alias": "EncodedFile",
        "help": "Help on function EncodedFile in module codecs:\n\nEncodedFile(file, data_encoding, file_encoding=None, errors='strict')\n    Return a wrapped version of file which provides transparent\n    encoding translation.\n\n    Data written to the wrapped file is decoded according\n    to the given data_encoding and then encoded to the underlying\n    file using file_encoding. The intermediate data type\n    will usually be Unicode but depends on the specified codecs.\n\n    Bytes read from the file are decoded using file_encoding and then\n    passed back to the caller encoded using data_encoding.\n\n    If file_encoding is not given, it defaults to data_encoding.\n\n    errors may be given to define the error handling. It defaults\n    to 'strict' which causes ValueErrors to be raised in case an\n    encoding error occurs.\n\n    The returned wrapped file object provides two extra attributes\n    .data_encoding and .file_encoding which reflect the given\n    parameters of the same name. The attributes can be used for\n    introspection by Python programs.",
        "syntax": "Syntax: EncodedFile(file, data_encoding, file_encoding=None, errors='strict')",
        "other-params": ""
    },
    "codecs.IncrementalDecoder": {
        "function": "IncrementalDecoder(errors='strict')",
        "alias": "IncrementalDecoder",
        "help": "Help on class IncrementalDecoder in module codecs:\n\nclass IncrementalDecoder(builtins.object)\n |  IncrementalDecoder(errors='strict')\n |\n |  An IncrementalDecoder decodes an input in multiple steps. The input can\n |  be passed piece by piece to the decode() method. The IncrementalDecoder\n |  remembers the state of the decoding process between calls to decode().\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Create an IncrementalDecoder instance.\n |\n |      The IncrementalDecoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  decode(self, input, final=False)\n |      Decode input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the decoder.\n |\n |      This must be a (buffered_input, additional_state_info) tuple.\n |      buffered_input must be a bytes object containing bytes that\n |      were passed to decode() that have not yet been converted.\n |      additional_state_info must be a non-negative integer\n |      representing the state of the decoder WITHOUT yet having\n |      processed the contents of buffered_input.  In the initial state\n |      and after reset(), getstate() must return (b\"\", 0).\n |\n |  reset(self)\n |      Reset the decoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the decoder.\n |\n |      state must have been returned by getstate().  The effect of\n |      setstate((b\"\", 0)) must be equivalent to reset().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalDecoder(errors='strict')",
        "other-params": ""
    },
    "codecs.IncrementalEncoder": {
        "function": "IncrementalEncoder(errors='strict')",
        "alias": "IncrementalEncoder",
        "help": "Help on class IncrementalEncoder in module codecs:\n\nclass IncrementalEncoder(builtins.object)\n |  IncrementalEncoder(errors='strict')\n |\n |  An IncrementalEncoder encodes an input in multiple steps. The input can\n |  be passed piece by piece to the encode() method. The IncrementalEncoder\n |  remembers the state of the encoding process between calls to encode().\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Creates an IncrementalEncoder instance.\n |\n |      The IncrementalEncoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  encode(self, input, final=False)\n |      Encodes input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the encoder.\n |\n |  reset(self)\n |      Resets the encoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the encoder. state must have been\n |      returned by getstate().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalEncoder(errors='strict')",
        "other-params": ""
    },
    "codecs.StreamReader": {
        "function": "StreamReader(stream, errors='strict')",
        "alias": "StreamReader",
        "help": "Help on class StreamReader in module codecs:\n\nclass StreamReader(Codec)\n |  StreamReader(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamReader\n |      Codec\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamReader instance.\n |\n |      stream must be a file-like object open for reading.\n |\n |      The StreamReader may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'backslashreplace' - Replace with backslashed escape sequences;\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  read(self, size=-1, chars=-1, firstline=False)\n |      Decodes data from the stream self.stream and returns the\n |      resulting object.\n |\n |      chars indicates the number of decoded code points or bytes to\n |      return. read() will never return more data than requested,\n |      but it might return less, if there is not enough available.\n |\n |      size indicates the approximate maximum number of decoded\n |      bytes or code points to read for decoding. The decoder\n |      can modify this setting as appropriate. The default value\n |      -1 indicates to read and decode as much as possible.  size\n |      is intended to prevent having to decode huge files in one\n |      step.\n |\n |      If firstline is true, and a UnicodeDecodeError happens\n |      after the first line terminator in the input only the first line\n |      will be returned, the rest of the input will be kept until the\n |      next call to read().\n |\n |      The method should use a greedy read strategy, meaning that\n |      it should read as much data as is allowed within the\n |      definition of the encoding and the given size, e.g.  if\n |      optional encoding endings or state markers are available\n |      on the stream, these should be read too.\n |\n |  readline(self, size=None, keepends=True)\n |      Read one line from the input stream and return the\n |      decoded data.\n |\n |      size, if given, is passed as size argument to the\n |      read() method.\n |\n |  readlines(self, sizehint=None, keepends=True)\n |      Read all lines available on the input stream\n |      and return them as a list.\n |\n |      Line breaks are implemented using the codec's decoder\n |      method and are included in the list entries.\n |\n |      sizehint, if given, is ignored since there is no efficient\n |      way to finding the true end-of-line.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Note that no stream repositioning should take place.\n |      This method is primarily intended to be able to recover\n |      from decoding errors.\n |\n |  seek(self, offset, whence=0)\n |      Set the input stream's current position.\n |\n |      Resets the codec buffers used for keeping state.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  charbuffertype = <class 'str'>\n |      str(object='') -> str\n |      str(bytes_or_buffer[, encoding[, errors]]) -> str\n |\n |      Create a new string object from the given object. If encoding or\n |      errors is specified, then the object must expose a data buffer\n |      that will be decoded using the given encoding and error handler.\n |      Otherwise, returns the result of object.__str__() (if defined)\n |      or repr(object).\n |      encoding defaults to 'utf-8'.\n |      errors defaults to 'strict'.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Codec:\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamReader(stream, errors='strict')",
        "other-params": ""
    },
    "codecs.StreamReaderWriter": {
        "function": "StreamReaderWriter(stream, Reader, Writer, errors='strict')",
        "alias": "StreamReaderWriter",
        "help": "Help on class StreamReaderWriter in module codecs:\n\nclass StreamReaderWriter(builtins.object)\n |  StreamReaderWriter(stream, Reader, Writer, errors='strict')\n |\n |  StreamReaderWriter instances allow wrapping streams which\n |  work in both read and write modes.\n |\n |  The design is such that one can use the factory functions\n |  returned by the codec.lookup() function to construct the\n |  instance.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, Reader, Writer, errors='strict')\n |      Creates a StreamReaderWriter instance.\n |\n |      stream must be a Stream-like object.\n |\n |      Reader, Writer must be factory functions or classes\n |      providing the StreamReader, StreamWriter interface resp.\n |\n |      Error handling is done in the same way as defined for the\n |      StreamWriter/Readers.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  read(self, size=-1)\n |\n |  readline(self, size=None)\n |\n |  readlines(self, sizehint=None)\n |\n |  reset(self)\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, data)\n |\n |  writelines(self, list)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  encoding = 'unknown'",
        "syntax": "Syntax: StreamReaderWriter(stream, Reader, Writer, errors='strict')",
        "other-params": ""
    },
    "codecs.StreamRecoder": {
        "function": "StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')",
        "alias": "StreamRecoder",
        "help": "Help on class StreamRecoder in module codecs:\n\nclass StreamRecoder(builtins.object)\n |  StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')\n |\n |  StreamRecoder instances translate data from one encoding to another.\n |\n |  They use the complete set of APIs returned by the\n |  codecs.lookup() function to implement their task.\n |\n |  Data written to the StreamRecoder is first decoded into an\n |  intermediate format (depending on the \"decode\" codec) and then\n |  written to the underlying stream using an instance of the provided\n |  Writer class.\n |\n |  In the other direction, data is read from the underlying stream using\n |  a Reader instance and then encoded and returned to the caller.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, encode, decode, Reader, Writer, errors='strict')\n |      Creates a StreamRecoder instance which implements a two-way\n |      conversion: encode and decode work on the frontend (the\n |      data visible to .read() and .write()) while Reader and Writer\n |      work on the backend (the data in stream).\n |\n |      You can use these objects to do transparent\n |      transcodings from e.g. latin-1 to utf-8 and back.\n |\n |      stream must be a file-like object.\n |\n |      encode and decode must adhere to the Codec interface; Reader and\n |      Writer must be factory functions or classes providing the\n |      StreamReader and StreamWriter interfaces resp.\n |\n |      Error handling is done in the same way as defined for the\n |      StreamWriter/Readers.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  read(self, size=-1)\n |\n |  readline(self, size=None)\n |\n |  readlines(self, sizehint=None)\n |\n |  reset(self)\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, data)\n |\n |  writelines(self, list)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  data_encoding = 'unknown'\n |\n |  file_encoding = 'unknown'",
        "syntax": "Syntax: StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')",
        "other-params": ""
    },
    "codecs.StreamWriter": {
        "function": "StreamWriter(stream, errors='strict')",
        "alias": "StreamWriter",
        "help": "Help on class StreamWriter in module codecs:\n\nclass StreamWriter(Codec)\n |  StreamWriter(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamWriter\n |      Codec\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamWriter instance.\n |\n |      stream must be a file-like object open for writing.\n |\n |      The StreamWriter may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'xmlcharrefreplace' - Replace with the appropriate XML\n |                             character reference.\n |       'backslashreplace'  - Replace with backslashed escape\n |                             sequences.\n |       'namereplace'       - Replace with \\N{...} escape sequences.\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Calling this method should ensure that the data on the\n |      output is put into a clean state, that allows appending\n |      of new fresh data without having to rescan the whole\n |      stream to recover state.\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, object)\n |      Writes the object's contents encoded to self.stream.\n |\n |  writelines(self, list)\n |      Writes the concatenated list of strings to the stream\n |      using .write().\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Codec:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamWriter(stream, errors='strict')",
        "other-params": ""
    },
    "codecs.ascii_decode": {
        "function": "ascii_decode(data, errors=None, /)",
        "alias": "ascii_decode",
        "help": "Help on built-in function ascii_decode in module _codecs:\n\nascii_decode(data, errors=None, /)",
        "syntax": "Syntax: ascii_decode(data, errors=None, /)",
        "other-params": ""
    },
    "codecs.ascii_encode": {
        "function": "ascii_encode(str, errors=None, /)",
        "alias": "ascii_encode",
        "help": "Help on built-in function ascii_encode in module _codecs:\n\nascii_encode(str, errors=None, /)",
        "syntax": "Syntax: ascii_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.backslashreplace_errors": {
        "function": "backslashreplace_errors(self, object, /)",
        "alias": "backslashreplace_errors",
        "help": "Help on built-in function backslashreplace_errors:\n\nbackslashreplace_errors(self, object, /)\n    Implements the 'backslashreplace' error handling, which replaces malformed data with a backslashed escape sequence.",
        "syntax": "Syntax: backslashreplace_errors(self, object, /)",
        "other-params": ""
    },
    "codecs.charmap_build": {
        "function": "charmap_build(map, /)",
        "alias": "charmap_build",
        "help": "Help on built-in function charmap_build in module _codecs:\n\ncharmap_build(map, /)",
        "syntax": "Syntax: charmap_build(map, /)",
        "other-params": ""
    },
    "codecs.charmap_decode": {
        "function": "charmap_decode(data, errors=None, mapping=None, /)",
        "alias": "charmap_decode",
        "help": "Help on built-in function charmap_decode in module _codecs:\n\ncharmap_decode(data, errors=None, mapping=None, /)",
        "syntax": "Syntax: charmap_decode(data, errors=None, mapping=None, /)",
        "other-params": ""
    },
    "codecs.charmap_encode": {
        "function": "charmap_encode(str, errors=None, mapping=None, /)",
        "alias": "charmap_encode",
        "help": "Help on built-in function charmap_encode in module _codecs:\n\ncharmap_encode(str, errors=None, mapping=None, /)",
        "syntax": "Syntax: charmap_encode(str, errors=None, mapping=None, /)",
        "other-params": ""
    },
    "codecs.code_page_decode": {
        "function": "code_page_decode(codepage, data, errors=None, final=False, /)",
        "alias": "code_page_decode",
        "help": "Help on built-in function code_page_decode in module _codecs:\n\ncode_page_decode(codepage, data, errors=None, final=False, /)",
        "syntax": "Syntax: code_page_decode(codepage, data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.code_page_encode": {
        "function": "code_page_encode(code_page, str, errors=None, /)",
        "alias": "code_page_encode",
        "help": "Help on built-in function code_page_encode in module _codecs:\n\ncode_page_encode(code_page, str, errors=None, /)",
        "syntax": "Syntax: code_page_encode(code_page, str, errors=None, /)",
        "other-params": ""
    },
    "codecs.decode": {
        "function": "decode(obj, encoding='utf-8', errors='strict')",
        "alias": "decode",
        "help": "Help on built-in function decode in module _codecs:\n\ndecode(obj, encoding='utf-8', errors='strict')\n    Decodes obj using the codec registered for encoding.\n\n    Default encoding is 'utf-8'.  errors may be given to set a\n    different error handling scheme.  Default is 'strict' meaning that encoding\n    errors raise a ValueError.  Other possible values are 'ignore', 'replace'\n    and 'backslashreplace' as well as any other name registered with\n    codecs.register_error that can handle ValueErrors.",
        "syntax": "Syntax: decode(obj, encoding='utf-8', errors='strict')",
        "other-params": ""
    },
    "codecs.encode": {
        "function": "encode(obj, encoding='utf-8', errors='strict')",
        "alias": "encode",
        "help": "Help on built-in function encode in module _codecs:\n\nencode(obj, encoding='utf-8', errors='strict')\n    Encodes obj using the codec registered for encoding.\n\n    The default encoding is 'utf-8'.  errors may be given to set a\n    different error handling scheme.  Default is 'strict' meaning that encoding\n    errors raise a ValueError.  Other possible values are 'ignore', 'replace'\n    and 'backslashreplace' as well as any other name registered with\n    codecs.register_error that can handle ValueErrors.",
        "syntax": "Syntax: encode(obj, encoding='utf-8', errors='strict')",
        "other-params": ""
    },
    "codecs.escape_decode": {
        "function": "escape_decode(data, errors=None, /)",
        "alias": "escape_decode",
        "help": "Help on built-in function escape_decode in module _codecs:\n\nescape_decode(data, errors=None, /)",
        "syntax": "Syntax: escape_decode(data, errors=None, /)",
        "other-params": ""
    },
    "codecs.escape_encode": {
        "function": "escape_encode(data, errors=None, /)",
        "alias": "escape_encode",
        "help": "Help on built-in function escape_encode in module _codecs:\n\nescape_encode(data, errors=None, /)",
        "syntax": "Syntax: escape_encode(data, errors=None, /)",
        "other-params": ""
    },
    "codecs.getdecoder": {
        "function": "getdecoder(encoding)",
        "alias": "getdecoder",
        "help": "Help on function getdecoder in module codecs:\n\ngetdecoder(encoding)\n    Lookup up the codec for the given encoding and return\n    its decoder function.\n\n    Raises a LookupError in case the encoding cannot be found.",
        "syntax": "Syntax: getdecoder(encoding)",
        "other-params": ""
    },
    "codecs.getencoder": {
        "function": "getencoder(encoding)",
        "alias": "getencoder",
        "help": "Help on function getencoder in module codecs:\n\ngetencoder(encoding)\n    Lookup up the codec for the given encoding and return\n    its encoder function.\n\n    Raises a LookupError in case the encoding cannot be found.",
        "syntax": "Syntax: getencoder(encoding)",
        "other-params": ""
    },
    "codecs.getincrementaldecoder": {
        "function": "getincrementaldecoder(encoding)",
        "alias": "getincrementaldecoder",
        "help": "Help on function getincrementaldecoder in module codecs:\n\ngetincrementaldecoder(encoding)\n    Lookup up the codec for the given encoding and return\n    its IncrementalDecoder class or factory function.\n\n    Raises a LookupError in case the encoding cannot be found\n    or the codecs doesn't provide an incremental decoder.",
        "syntax": "Syntax: getincrementaldecoder(encoding)",
        "other-params": ""
    },
    "codecs.getincrementalencoder": {
        "function": "getincrementalencoder(encoding)",
        "alias": "getincrementalencoder",
        "help": "Help on function getincrementalencoder in module codecs:\n\ngetincrementalencoder(encoding)\n    Lookup up the codec for the given encoding and return\n    its IncrementalEncoder class or factory function.\n\n    Raises a LookupError in case the encoding cannot be found\n    or the codecs doesn't provide an incremental encoder.",
        "syntax": "Syntax: getincrementalencoder(encoding)",
        "other-params": ""
    },
    "codecs.getreader": {
        "function": "getreader(encoding)",
        "alias": "getreader",
        "help": "Help on function getreader in module codecs:\n\ngetreader(encoding)\n    Lookup up the codec for the given encoding and return\n    its StreamReader class or factory function.\n\n    Raises a LookupError in case the encoding cannot be found.",
        "syntax": "Syntax: getreader(encoding)",
        "other-params": ""
    },
    "codecs.getwriter": {
        "function": "getwriter(encoding)",
        "alias": "getwriter",
        "help": "Help on function getwriter in module codecs:\n\ngetwriter(encoding)\n    Lookup up the codec for the given encoding and return\n    its StreamWriter class or factory function.\n\n    Raises a LookupError in case the encoding cannot be found.",
        "syntax": "Syntax: getwriter(encoding)",
        "other-params": ""
    },
    "codecs.ignore_errors": {
        "function": "ignore_errors(self, object, /)",
        "alias": "ignore_errors",
        "help": "Help on built-in function ignore_errors:\n\nignore_errors(self, object, /)\n    Implements the 'ignore' error handling, which ignores malformed data and continues.",
        "syntax": "Syntax: ignore_errors(self, object, /)",
        "other-params": ""
    },
    "codecs.iterdecode": {
        "function": "iterdecode(iterator, encoding, errors='strict', **kwargs)",
        "alias": "iterdecode",
        "help": "Help on function iterdecode in module codecs:\n\niterdecode(iterator, encoding, errors='strict', **kwargs)\n    Decoding iterator.\n\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.",
        "syntax": "Syntax: iterdecode(iterator, encoding, errors='strict', **kwargs)",
        "other-params": ""
    },
    "codecs.iterencode": {
        "function": "iterencode(iterator, encoding, errors='strict', **kwargs)",
        "alias": "iterencode",
        "help": "Help on function iterencode in module codecs:\n\niterencode(iterator, encoding, errors='strict', **kwargs)\n    Encoding iterator.\n\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.",
        "syntax": "Syntax: iterencode(iterator, encoding, errors='strict', **kwargs)",
        "other-params": ""
    },
    "codecs.latin_1_decode": {
        "function": "latin_1_decode(data, errors=None, /)",
        "alias": "latin_1_decode",
        "help": "Help on built-in function latin_1_decode in module _codecs:\n\nlatin_1_decode(data, errors=None, /)",
        "syntax": "Syntax: latin_1_decode(data, errors=None, /)",
        "other-params": ""
    },
    "codecs.latin_1_encode": {
        "function": "latin_1_encode(str, errors=None, /)",
        "alias": "latin_1_encode",
        "help": "Help on built-in function latin_1_encode in module _codecs:\n\nlatin_1_encode(str, errors=None, /)",
        "syntax": "Syntax: latin_1_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.lookup": {
        "function": "lookup(encoding, /)",
        "alias": "lookup",
        "help": "Help on built-in function lookup in module _codecs:\n\nlookup(encoding, /)\n    Looks up a codec tuple in the Python codec registry and returns a CodecInfo object.",
        "syntax": "Syntax: lookup(encoding, /)",
        "other-params": ""
    },
    "codecs.lookup_error": {
        "function": "lookup_error(name, /)",
        "alias": "lookup_error",
        "help": "Help on built-in function lookup_error in module _codecs:\n\nlookup_error(name, /)\n    lookup_error(errors) -> handler\n\n    Return the error handler for the specified error handling name or raise a\n    LookupError, if no handler exists under this name.",
        "syntax": "Syntax: lookup_error(name, /)",
        "other-params": ""
    },
    "codecs.make_encoding_map": {
        "function": "make_encoding_map(decoding_map)",
        "alias": "make_encoding_map",
        "help": "Help on function make_encoding_map in module codecs:\n\nmake_encoding_map(decoding_map)\n    Creates an encoding map from a decoding map.\n\n    If a target mapping in the decoding map occurs multiple\n    times, then that target is mapped to None (undefined mapping),\n    causing an exception when encountered by the charmap codec\n    during translation.\n\n    One example where this happens is cp875.py which decodes\n    multiple character to \\u001a.",
        "syntax": "Syntax: make_encoding_map(decoding_map)",
        "other-params": ""
    },
    "codecs.make_identity_dict": {
        "function": "make_identity_dict(rng)",
        "alias": "make_identity_dict",
        "help": "Help on function make_identity_dict in module codecs:\n\nmake_identity_dict(rng)\n    make_identity_dict(rng) -> dict\n\n    Return a dictionary where elements of the rng sequence are\n    mapped to themselves.",
        "syntax": "Syntax: make_identity_dict(rng)",
        "other-params": ""
    },
    "codecs.mbcs_decode": {
        "function": "mbcs_decode(data, errors=None, final=False, /)",
        "alias": "mbcs_decode",
        "help": "Help on built-in function mbcs_decode in module _codecs:\n\nmbcs_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: mbcs_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.mbcs_encode": {
        "function": "mbcs_encode(str, errors=None, /)",
        "alias": "mbcs_encode",
        "help": "Help on built-in function mbcs_encode in module _codecs:\n\nmbcs_encode(str, errors=None, /)",
        "syntax": "Syntax: mbcs_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.namereplace_errors": {
        "function": "namereplace_errors(self, object, /)",
        "alias": "namereplace_errors",
        "help": "Help on built-in function namereplace_errors:\n\nnamereplace_errors(self, object, /)\n    Implements the 'namereplace' error handling, which replaces an unencodable character with a \\N{...} escape sequence.",
        "syntax": "Syntax: namereplace_errors(self, object, /)",
        "other-params": ""
    },
    "codecs.oem_decode": {
        "function": "oem_decode(data, errors=None, final=False, /)",
        "alias": "oem_decode",
        "help": "Help on built-in function oem_decode in module _codecs:\n\noem_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: oem_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.oem_encode": {
        "function": "oem_encode(str, errors=None, /)",
        "alias": "oem_encode",
        "help": "Help on built-in function oem_encode in module _codecs:\n\noem_encode(str, errors=None, /)",
        "syntax": "Syntax: oem_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.open": {
        "function": "open(filename, mode='r', encoding=None, errors='strict', buffering=-1)",
        "alias": "open",
        "help": "Help on function open in module codecs:\n\nopen(filename, mode='r', encoding=None, errors='strict', buffering=-1)\n    Open an encoded file using the given mode and return\n    a wrapped version providing transparent encoding/decoding.\n\n    Note: The wrapped version will only accept the object format\n    defined by the codecs, i.e. Unicode objects for most builtin\n    codecs. Output is also codec dependent and will usually be\n    Unicode as well.\n\n    If encoding is not None, then the\n    underlying encoded files are always opened in binary mode.\n    The default file mode is 'r', meaning to open the file in read mode.\n\n    encoding specifies the encoding which is to be used for the\n    file.\n\n    errors may be given to define the error handling. It defaults\n    to 'strict' which causes ValueErrors to be raised in case an\n    encoding error occurs.\n\n    buffering has the same meaning as for the builtin open() API.\n    It defaults to -1 which means that the default buffer size will\n    be used.\n\n    The returned wrapped file object provides an extra attribute\n    .encoding which allows querying the used encoding. This\n    attribute is only available if an encoding was specified as\n    parameter.",
        "syntax": "Syntax: open(filename, mode='r', encoding=None, errors='strict', buffering=-1)",
        "other-params": ""
    },
    "codecs.raw_unicode_escape_decode": {
        "function": "raw_unicode_escape_decode(data, errors=None, final=True, /)",
        "alias": "raw_unicode_escape_decode",
        "help": "Help on built-in function raw_unicode_escape_decode in module _codecs:\n\nraw_unicode_escape_decode(data, errors=None, final=True, /)",
        "syntax": "Syntax: raw_unicode_escape_decode(data, errors=None, final=True, /)",
        "other-params": ""
    },
    "codecs.raw_unicode_escape_encode": {
        "function": "raw_unicode_escape_encode(str, errors=None, /)",
        "alias": "raw_unicode_escape_encode",
        "help": "Help on built-in function raw_unicode_escape_encode in module _codecs:\n\nraw_unicode_escape_encode(str, errors=None, /)",
        "syntax": "Syntax: raw_unicode_escape_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.readbuffer_encode": {
        "function": "readbuffer_encode(data, errors=None, /)",
        "alias": "readbuffer_encode",
        "help": "Help on built-in function readbuffer_encode in module _codecs:\n\nreadbuffer_encode(data, errors=None, /)",
        "syntax": "Syntax: readbuffer_encode(data, errors=None, /)",
        "other-params": ""
    },
    "codecs.register": {
        "function": "register(search_function, /)",
        "alias": "register",
        "help": "Help on built-in function register in module _codecs:\n\nregister(search_function, /)\n    Register a codec search function.\n\n    Search functions are expected to take one argument, the encoding name in\n    all lower case letters, and either return None, or a tuple of functions\n    (encoder, decoder, stream_reader, stream_writer) (or a CodecInfo object).",
        "syntax": "Syntax: register(search_function, /)",
        "other-params": ""
    },
    "codecs.register_error": {
        "function": "register_error(errors, handler, /)",
        "alias": "register_error",
        "help": "Help on built-in function register_error in module _codecs:\n\nregister_error(errors, handler, /)\n    Register the specified error handler under the name errors.\n\n    handler must be a callable object, that will be called with an exception\n    instance containing information about the location of the encoding/decoding\n    error and must return a (replacement, new position) tuple.",
        "syntax": "Syntax: register_error(errors, handler, /)",
        "other-params": ""
    },
    "codecs.replace_errors": {
        "function": "replace_errors(self, object, /)",
        "alias": "replace_errors",
        "help": "Help on built-in function replace_errors:\n\nreplace_errors(self, object, /)\n    Implements the 'replace' error handling, which replaces malformed data with a replacement marker.",
        "syntax": "Syntax: replace_errors(self, object, /)",
        "other-params": ""
    },
    "codecs.strict_errors": {
        "function": "strict_errors(self, object, /)",
        "alias": "strict_errors",
        "help": "Help on built-in function strict_errors:\n\nstrict_errors(self, object, /)\n    Implements the 'strict' error handling, which raises a UnicodeError on coding errors.",
        "syntax": "Syntax: strict_errors(self, object, /)",
        "other-params": ""
    },
    "codecs.unicode_escape_decode": {
        "function": "unicode_escape_decode(data, errors=None, final=True, /)",
        "alias": "unicode_escape_decode",
        "help": "Help on built-in function unicode_escape_decode in module _codecs:\n\nunicode_escape_decode(data, errors=None, final=True, /)",
        "syntax": "Syntax: unicode_escape_decode(data, errors=None, final=True, /)",
        "other-params": ""
    },
    "codecs.unicode_escape_encode": {
        "function": "unicode_escape_encode(str, errors=None, /)",
        "alias": "unicode_escape_encode",
        "help": "Help on built-in function unicode_escape_encode in module _codecs:\n\nunicode_escape_encode(str, errors=None, /)",
        "syntax": "Syntax: unicode_escape_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.unregister": {
        "function": "unregister(search_function, /)",
        "alias": "unregister",
        "help": "Help on built-in function unregister in module _codecs:\n\nunregister(search_function, /)\n    Unregister a codec search function and clear the registry's cache.\n\n    If the search function is not registered, do nothing.",
        "syntax": "Syntax: unregister(search_function, /)",
        "other-params": ""
    },
    "codecs.utf_16_be_decode": {
        "function": "utf_16_be_decode(data, errors=None, final=False, /)",
        "alias": "utf_16_be_decode",
        "help": "Help on built-in function utf_16_be_decode in module _codecs:\n\nutf_16_be_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_16_be_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_16_be_encode": {
        "function": "utf_16_be_encode(str, errors=None, /)",
        "alias": "utf_16_be_encode",
        "help": "Help on built-in function utf_16_be_encode in module _codecs:\n\nutf_16_be_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_16_be_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.utf_16_decode": {
        "function": "utf_16_decode(data, errors=None, final=False, /)",
        "alias": "utf_16_decode",
        "help": "Help on built-in function utf_16_decode in module _codecs:\n\nutf_16_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_16_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_16_encode": {
        "function": "utf_16_encode(str, errors=None, byteorder=0, /)",
        "alias": "utf_16_encode",
        "help": "Help on built-in function utf_16_encode in module _codecs:\n\nutf_16_encode(str, errors=None, byteorder=0, /)",
        "syntax": "Syntax: utf_16_encode(str, errors=None, byteorder=0, /)",
        "other-params": ""
    },
    "codecs.utf_16_ex_decode": {
        "function": "utf_16_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "alias": "utf_16_ex_decode",
        "help": "Help on built-in function utf_16_ex_decode in module _codecs:\n\nutf_16_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "syntax": "Syntax: utf_16_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_16_le_decode": {
        "function": "utf_16_le_decode(data, errors=None, final=False, /)",
        "alias": "utf_16_le_decode",
        "help": "Help on built-in function utf_16_le_decode in module _codecs:\n\nutf_16_le_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_16_le_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_16_le_encode": {
        "function": "utf_16_le_encode(str, errors=None, /)",
        "alias": "utf_16_le_encode",
        "help": "Help on built-in function utf_16_le_encode in module _codecs:\n\nutf_16_le_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_16_le_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.utf_32_be_decode": {
        "function": "utf_32_be_decode(data, errors=None, final=False, /)",
        "alias": "utf_32_be_decode",
        "help": "Help on built-in function utf_32_be_decode in module _codecs:\n\nutf_32_be_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_32_be_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_32_be_encode": {
        "function": "utf_32_be_encode(str, errors=None, /)",
        "alias": "utf_32_be_encode",
        "help": "Help on built-in function utf_32_be_encode in module _codecs:\n\nutf_32_be_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_32_be_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.utf_32_decode": {
        "function": "utf_32_decode(data, errors=None, final=False, /)",
        "alias": "utf_32_decode",
        "help": "Help on built-in function utf_32_decode in module _codecs:\n\nutf_32_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_32_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_32_encode": {
        "function": "utf_32_encode(str, errors=None, byteorder=0, /)",
        "alias": "utf_32_encode",
        "help": "Help on built-in function utf_32_encode in module _codecs:\n\nutf_32_encode(str, errors=None, byteorder=0, /)",
        "syntax": "Syntax: utf_32_encode(str, errors=None, byteorder=0, /)",
        "other-params": ""
    },
    "codecs.utf_32_ex_decode": {
        "function": "utf_32_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "alias": "utf_32_ex_decode",
        "help": "Help on built-in function utf_32_ex_decode in module _codecs:\n\nutf_32_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "syntax": "Syntax: utf_32_ex_decode(data, errors=None, byteorder=0, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_32_le_decode": {
        "function": "utf_32_le_decode(data, errors=None, final=False, /)",
        "alias": "utf_32_le_decode",
        "help": "Help on built-in function utf_32_le_decode in module _codecs:\n\nutf_32_le_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_32_le_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_32_le_encode": {
        "function": "utf_32_le_encode(str, errors=None, /)",
        "alias": "utf_32_le_encode",
        "help": "Help on built-in function utf_32_le_encode in module _codecs:\n\nutf_32_le_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_32_le_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.utf_7_decode": {
        "function": "utf_7_decode(data, errors=None, final=False, /)",
        "alias": "utf_7_decode",
        "help": "Help on built-in function utf_7_decode in module _codecs:\n\nutf_7_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_7_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_7_encode": {
        "function": "utf_7_encode(str, errors=None, /)",
        "alias": "utf_7_encode",
        "help": "Help on built-in function utf_7_encode in module _codecs:\n\nutf_7_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_7_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.utf_8_decode": {
        "function": "utf_8_decode(data, errors=None, final=False, /)",
        "alias": "utf_8_decode",
        "help": "Help on built-in function utf_8_decode in module _codecs:\n\nutf_8_decode(data, errors=None, final=False, /)",
        "syntax": "Syntax: utf_8_decode(data, errors=None, final=False, /)",
        "other-params": ""
    },
    "codecs.utf_8_encode": {
        "function": "utf_8_encode(str, errors=None, /)",
        "alias": "utf_8_encode",
        "help": "Help on built-in function utf_8_encode in module _codecs:\n\nutf_8_encode(str, errors=None, /)",
        "syntax": "Syntax: utf_8_encode(str, errors=None, /)",
        "other-params": ""
    },
    "codecs.xmlcharrefreplace_errors": {
        "function": "xmlcharrefreplace_errors(self, object, /)",
        "alias": "xmlcharrefreplace_errors",
        "help": "Help on built-in function xmlcharrefreplace_errors:\n\nxmlcharrefreplace_errors(self, object, /)\n    Implements the 'xmlcharrefreplace' error handling, which replaces an unencodable character with the appropriate XML character reference.",
        "syntax": "Syntax: xmlcharrefreplace_errors(self, object, /)",
        "other-params": ""
    },
    "encodings.CodecRegistryError": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'encodings.CodecRegistryError'>",
        "alias": "CodecRegistryError",
        "help": "Help on class CodecRegistryError in module encodings:\n\nclass CodecRegistryError(builtins.LookupError, builtins.SystemError)\n |  Method resolution order:\n |      CodecRegistryError\n |      builtins.LookupError\n |      builtins.SystemError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.LookupError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.LookupError:\n |\n |  __new__(*args, **kwargs) class method of builtins.LookupError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'encodings.CodecRegistryError'>",
        "other-params": ""
    },
    "encodings._alias_mbcs": {
        "function": "_alias_mbcs(encoding)",
        "alias": "_alias_mbcs",
        "help": "Help on function _alias_mbcs in module encodings:\n\n_alias_mbcs(encoding)\n    # bpo-671666, bpo-46668: If Python does not implement a codec for current\n    # Windows ANSI code page, use the \"mbcs\" codec instead:\n    # WideCharToMultiByte() and MultiByteToWideChar() functions with CP_ACP.\n    # Python does not support custom code pages.",
        "syntax": "Syntax: _alias_mbcs(encoding)",
        "other-params": ""
    },
    "encodings.normalize_encoding": {
        "function": "normalize_encoding(encoding)",
        "alias": "normalize_encoding",
        "help": "Help on function normalize_encoding in module encodings:\n\nnormalize_encoding(encoding)\n    Normalize an encoding name.\n\n    Normalization works as follows: all non-alphanumeric\n    characters except the dot used for Python package names are\n    collapsed and replaced with a single underscore, e.g. '  -;#'\n    becomes '_'. Leading and trailing underscores are removed.\n\n    Note that encoding names should be ASCII only.",
        "syntax": "Syntax: normalize_encoding(encoding)",
        "other-params": ""
    },
    "encodings.search_function": {
        "function": "search_function(encoding)",
        "alias": "search_function",
        "help": "Help on function search_function in module encodings:\n\nsearch_function(encoding)",
        "syntax": "Syntax: search_function(encoding)",
        "other-params": ""
    },
    "encodings.utf_8.IncrementalDecoder": {
        "function": "IncrementalDecoder(errors='strict')",
        "alias": "IncrementalDecoder",
        "help": "Help on class IncrementalDecoder in module encodings.utf_8:\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder)\n |  IncrementalDecoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalDecoder\n |      codecs.BufferedIncrementalDecoder\n |      codecs.IncrementalDecoder\n |      builtins.object\n |\n |  Methods inherited from codecs.BufferedIncrementalDecoder:\n |\n |  __init__(self, errors='strict')\n |      Create an IncrementalDecoder instance.\n |\n |      The IncrementalDecoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  decode(self, input, final=False)\n |      Decode input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the decoder.\n |\n |      This must be a (buffered_input, additional_state_info) tuple.\n |      buffered_input must be a bytes object containing bytes that\n |      were passed to decode() that have not yet been converted.\n |      additional_state_info must be a non-negative integer\n |      representing the state of the decoder WITHOUT yet having\n |      processed the contents of buffered_input.  In the initial state\n |      and after reset(), getstate() must return (b\"\", 0).\n |\n |  reset(self)\n |      Reset the decoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the decoder.\n |\n |      state must have been returned by getstate().  The effect of\n |      setstate((b\"\", 0)) must be equivalent to reset().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalDecoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalDecoder(errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8.IncrementalEncoder": {
        "function": "IncrementalEncoder(errors='strict')",
        "alias": "IncrementalEncoder",
        "help": "Help on class IncrementalEncoder in module encodings.utf_8:\n\nclass IncrementalEncoder(codecs.IncrementalEncoder)\n |  IncrementalEncoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalEncoder\n |      codecs.IncrementalEncoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  encode(self, input, final=False)\n |      Encodes input and returns the resulting object.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.IncrementalEncoder:\n |\n |  __init__(self, errors='strict')\n |      Creates an IncrementalEncoder instance.\n |\n |      The IncrementalEncoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  getstate(self)\n |      Return the current state of the encoder.\n |\n |  reset(self)\n |      Resets the encoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the encoder. state must have been\n |      returned by getstate().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalEncoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalEncoder(errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8.StreamReader": {
        "function": "StreamReader(stream, errors='strict')",
        "alias": "StreamReader",
        "help": "Help on class StreamReader in module encodings.utf_8:\n\nclass StreamReader(codecs.StreamReader)\n |  StreamReader(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamReader\n |      codecs.StreamReader\n |      codecs.Codec\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  decode = utf_8_decode(data, errors=None, final=False, /)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamReader:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamReader instance.\n |\n |      stream must be a file-like object open for reading.\n |\n |      The StreamReader may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'backslashreplace' - Replace with backslashed escape sequences;\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  read(self, size=-1, chars=-1, firstline=False)\n |      Decodes data from the stream self.stream and returns the\n |      resulting object.\n |\n |      chars indicates the number of decoded code points or bytes to\n |      return. read() will never return more data than requested,\n |      but it might return less, if there is not enough available.\n |\n |      size indicates the approximate maximum number of decoded\n |      bytes or code points to read for decoding. The decoder\n |      can modify this setting as appropriate. The default value\n |      -1 indicates to read and decode as much as possible.  size\n |      is intended to prevent having to decode huge files in one\n |      step.\n |\n |      If firstline is true, and a UnicodeDecodeError happens\n |      after the first line terminator in the input only the first line\n |      will be returned, the rest of the input will be kept until the\n |      next call to read().\n |\n |      The method should use a greedy read strategy, meaning that\n |      it should read as much data as is allowed within the\n |      definition of the encoding and the given size, e.g.  if\n |      optional encoding endings or state markers are available\n |      on the stream, these should be read too.\n |\n |  readline(self, size=None, keepends=True)\n |      Read one line from the input stream and return the\n |      decoded data.\n |\n |      size, if given, is passed as size argument to the\n |      read() method.\n |\n |  readlines(self, sizehint=None, keepends=True)\n |      Read all lines available on the input stream\n |      and return them as a list.\n |\n |      Line breaks are implemented using the codec's decoder\n |      method and are included in the list entries.\n |\n |      sizehint, if given, is ignored since there is no efficient\n |      way to finding the true end-of-line.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Note that no stream repositioning should take place.\n |      This method is primarily intended to be able to recover\n |      from decoding errors.\n |\n |  seek(self, offset, whence=0)\n |      Set the input stream's current position.\n |\n |      Resets the codec buffers used for keeping state.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from codecs.StreamReader:\n |\n |  charbuffertype = <class 'str'>\n |      str(object='') -> str\n |      str(bytes_or_buffer[, encoding[, errors]]) -> str\n |\n |      Create a new string object from the given object. If encoding or\n |      errors is specified, then the object must expose a data buffer\n |      that will be decoded using the given encoding and error handler.\n |      Otherwise, returns the result of object.__str__() (if defined)\n |      or repr(object).\n |      encoding defaults to 'utf-8'.\n |      errors defaults to 'strict'.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.Codec:\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamReader(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8.StreamWriter": {
        "function": "StreamWriter(stream, errors='strict')",
        "alias": "StreamWriter",
        "help": "Help on class StreamWriter in module encodings.utf_8:\n\nclass StreamWriter(codecs.StreamWriter)\n |  StreamWriter(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamWriter\n |      codecs.StreamWriter\n |      codecs.Codec\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  encode = utf_8_encode(str, errors=None, /)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamWriter:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamWriter instance.\n |\n |      stream must be a file-like object open for writing.\n |\n |      The StreamWriter may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'xmlcharrefreplace' - Replace with the appropriate XML\n |                             character reference.\n |       'backslashreplace'  - Replace with backslashed escape\n |                             sequences.\n |       'namereplace'       - Replace with \\N{...} escape sequences.\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Calling this method should ensure that the data on the\n |      output is put into a clean state, that allows appending\n |      of new fresh data without having to rescan the whole\n |      stream to recover state.\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, object)\n |      Writes the object's contents encoded to self.stream.\n |\n |  writelines(self, list)\n |      Writes the concatenated list of strings to the stream\n |      using .write().\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.Codec:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamWriter(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8.decode": {
        "function": "decode(input, errors='strict')",
        "alias": "decode",
        "help": "Help on function decode in module encodings.utf_8:\n\ndecode(input, errors='strict')",
        "syntax": "Syntax: decode(input, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8.encode": {
        "function": "encode(str, errors=None, /)",
        "alias": "encode",
        "help": "Help on built-in function utf_8_encode in module _codecs:\n\nutf_8_encode(str, errors=None, /)",
        "syntax": "Syntax: encode(str, errors=None, /)",
        "other-params": ""
    },
    "encodings.utf_8.getregentry": {
        "function": "getregentry()",
        "alias": "getregentry",
        "help": "Help on function getregentry in module encodings.utf_8:\n\ngetregentry()",
        "syntax": "Syntax: getregentry()",
        "other-params": ""
    },
    "encodings.cp1252.Codec": {
        "function": "Codec()",
        "alias": "Codec",
        "help": "Help on class Codec in module encodings.cp1252:\n\nclass Codec(codecs.Codec)\n |  Method resolution order:\n |      Codec\n |      codecs.Codec\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Codec()",
        "other-params": ""
    },
    "encodings.cp1252.IncrementalDecoder": {
        "function": "IncrementalDecoder(errors='strict')",
        "alias": "IncrementalDecoder",
        "help": "Help on class IncrementalDecoder in module encodings.cp1252:\n\nclass IncrementalDecoder(codecs.IncrementalDecoder)\n |  IncrementalDecoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalDecoder\n |      codecs.IncrementalDecoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  decode(self, input, final=False)\n |      Decode input and returns the resulting object.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.IncrementalDecoder:\n |\n |  __init__(self, errors='strict')\n |      Create an IncrementalDecoder instance.\n |\n |      The IncrementalDecoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  getstate(self)\n |      Return the current state of the decoder.\n |\n |      This must be a (buffered_input, additional_state_info) tuple.\n |      buffered_input must be a bytes object containing bytes that\n |      were passed to decode() that have not yet been converted.\n |      additional_state_info must be a non-negative integer\n |      representing the state of the decoder WITHOUT yet having\n |      processed the contents of buffered_input.  In the initial state\n |      and after reset(), getstate() must return (b\"\", 0).\n |\n |  reset(self)\n |      Reset the decoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the decoder.\n |\n |      state must have been returned by getstate().  The effect of\n |      setstate((b\"\", 0)) must be equivalent to reset().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalDecoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalDecoder(errors='strict')",
        "other-params": ""
    },
    "encodings.cp1252.IncrementalEncoder": {
        "function": "IncrementalEncoder(errors='strict')",
        "alias": "IncrementalEncoder",
        "help": "Help on class IncrementalEncoder in module encodings.cp1252:\n\nclass IncrementalEncoder(codecs.IncrementalEncoder)\n |  IncrementalEncoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalEncoder\n |      codecs.IncrementalEncoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  encode(self, input, final=False)\n |      Encodes input and returns the resulting object.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.IncrementalEncoder:\n |\n |  __init__(self, errors='strict')\n |      Creates an IncrementalEncoder instance.\n |\n |      The IncrementalEncoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  getstate(self)\n |      Return the current state of the encoder.\n |\n |  reset(self)\n |      Resets the encoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the encoder. state must have been\n |      returned by getstate().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalEncoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalEncoder(errors='strict')",
        "other-params": ""
    },
    "encodings.cp1252.StreamReader": {
        "function": "StreamReader(stream, errors='strict')",
        "alias": "StreamReader",
        "help": "Help on class StreamReader in module encodings.cp1252:\n\nclass StreamReader(Codec, codecs.StreamReader)\n |  StreamReader(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamReader\n |      Codec\n |      codecs.StreamReader\n |      codecs.Codec\n |      builtins.object\n |\n |  Methods inherited from Codec:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamReader:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamReader instance.\n |\n |      stream must be a file-like object open for reading.\n |\n |      The StreamReader may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'backslashreplace' - Replace with backslashed escape sequences;\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  read(self, size=-1, chars=-1, firstline=False)\n |      Decodes data from the stream self.stream and returns the\n |      resulting object.\n |\n |      chars indicates the number of decoded code points or bytes to\n |      return. read() will never return more data than requested,\n |      but it might return less, if there is not enough available.\n |\n |      size indicates the approximate maximum number of decoded\n |      bytes or code points to read for decoding. The decoder\n |      can modify this setting as appropriate. The default value\n |      -1 indicates to read and decode as much as possible.  size\n |      is intended to prevent having to decode huge files in one\n |      step.\n |\n |      If firstline is true, and a UnicodeDecodeError happens\n |      after the first line terminator in the input only the first line\n |      will be returned, the rest of the input will be kept until the\n |      next call to read().\n |\n |      The method should use a greedy read strategy, meaning that\n |      it should read as much data as is allowed within the\n |      definition of the encoding and the given size, e.g.  if\n |      optional encoding endings or state markers are available\n |      on the stream, these should be read too.\n |\n |  readline(self, size=None, keepends=True)\n |      Read one line from the input stream and return the\n |      decoded data.\n |\n |      size, if given, is passed as size argument to the\n |      read() method.\n |\n |  readlines(self, sizehint=None, keepends=True)\n |      Read all lines available on the input stream\n |      and return them as a list.\n |\n |      Line breaks are implemented using the codec's decoder\n |      method and are included in the list entries.\n |\n |      sizehint, if given, is ignored since there is no efficient\n |      way to finding the true end-of-line.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Note that no stream repositioning should take place.\n |      This method is primarily intended to be able to recover\n |      from decoding errors.\n |\n |  seek(self, offset, whence=0)\n |      Set the input stream's current position.\n |\n |      Resets the codec buffers used for keeping state.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from codecs.StreamReader:\n |\n |  charbuffertype = <class 'str'>\n |      str(object='') -> str\n |      str(bytes_or_buffer[, encoding[, errors]]) -> str\n |\n |      Create a new string object from the given object. If encoding or\n |      errors is specified, then the object must expose a data buffer\n |      that will be decoded using the given encoding and error handler.\n |      Otherwise, returns the result of object.__str__() (if defined)\n |      or repr(object).\n |      encoding defaults to 'utf-8'.\n |      errors defaults to 'strict'.\n |\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamReader(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.cp1252.StreamWriter": {
        "function": "StreamWriter(stream, errors='strict')",
        "alias": "StreamWriter",
        "help": "Help on class StreamWriter in module encodings.cp1252:\n\nclass StreamWriter(Codec, codecs.StreamWriter)\n |  StreamWriter(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamWriter\n |      Codec\n |      codecs.StreamWriter\n |      codecs.Codec\n |      builtins.object\n |\n |  Methods inherited from Codec:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamWriter:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamWriter instance.\n |\n |      stream must be a file-like object open for writing.\n |\n |      The StreamWriter may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'xmlcharrefreplace' - Replace with the appropriate XML\n |                             character reference.\n |       'backslashreplace'  - Replace with backslashed escape\n |                             sequences.\n |       'namereplace'       - Replace with \\N{...} escape sequences.\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Calling this method should ensure that the data on the\n |      output is put into a clean state, that allows appending\n |      of new fresh data without having to rescan the whole\n |      stream to recover state.\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, object)\n |      Writes the object's contents encoded to self.stream.\n |\n |  writelines(self, list)\n |      Writes the concatenated list of strings to the stream\n |      using .write().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamWriter(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.cp1252.getregentry": {
        "function": "getregentry()",
        "alias": "getregentry",
        "help": "Help on function getregentry in module encodings.cp1252:\n\ngetregentry()",
        "syntax": "Syntax: getregentry()",
        "other-params": ""
    },
    "abc.ABC": {
        "function": "ABC()",
        "alias": "ABC",
        "help": "Help on class ABC in module abc:\n\nclass ABC(builtins.object)\n |  Helper class that provides a standard way to create an ABC using\n |  inheritance.\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()",
        "syntax": "Syntax: ABC()",
        "other-params": ""
    },
    "abc.ABCMeta": {
        "function": "ABCMeta(name, bases, namespace, /, **kwargs)",
        "alias": "ABCMeta",
        "help": "Help on class ABCMeta in module abc:\n\nclass ABCMeta(builtins.type)\n |  ABCMeta(name, bases, namespace, /, **kwargs)\n |\n |  Metaclass for defining Abstract Base Classes (ABCs).\n |\n |  Use this metaclass to create an ABC.  An ABC can be subclassed\n |  directly, and then acts as a mix-in class.  You can also register\n |  unrelated concrete classes (even built-in classes) and unrelated\n |  ABCs as 'virtual subclasses' -- these and their descendants will\n |  be considered subclasses of the registering ABC by the built-in\n |  issubclass() function, but the registering ABC won't show up in\n |  their MRO (Method Resolution Order) nor will method\n |  implementations defined by the registering ABC be callable (not\n |  even via super()).\n |\n |  Method resolution order:\n |      ABCMeta\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __instancecheck__(cls, instance)\n |      Override for isinstance(instance, cls).\n |\n |  __subclasscheck__(cls, subclass)\n |      Override for issubclass(subclass, cls).\n |\n |  register(cls, subclass)\n |      Register a virtual subclass of an ABC.\n |\n |      Returns the subclass, to allow usage as a class decorator.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(mcls, name, bases, namespace, /, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __dir__(self, /)\n |      Specialized __dir__ implementation for types.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.type:\n |\n |  __prepare__(name, bases, /, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'type'>\n |      type(object) -> the object's type\n |      type(name, bases, dict, **kwds) -> a new type\n |\n |\n |  __bases__ = (<class 'type'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155896320\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: ABCMeta(name, bases, namespace, /, **kwargs)",
        "other-params": ""
    },
    "abc._abc_init": {
        "function": "_abc_init(self, /)",
        "alias": "_abc_init",
        "help": "Help on built-in function _abc_init in module _abc:\n\n_abc_init(self, /)\n    Internal ABC helper for class set-up. Should be never used outside abc module.",
        "syntax": "Syntax: _abc_init(self, /)",
        "other-params": ""
    },
    "abc._abc_instancecheck": {
        "function": "_abc_instancecheck(self, instance, /)",
        "alias": "_abc_instancecheck",
        "help": "Help on built-in function _abc_instancecheck in module _abc:\n\n_abc_instancecheck(self, instance, /)\n    Internal ABC helper for instance checks. Should be never used outside abc module.",
        "syntax": "Syntax: _abc_instancecheck(self, instance, /)",
        "other-params": ""
    },
    "abc._abc_register": {
        "function": "_abc_register(self, subclass, /)",
        "alias": "_abc_register",
        "help": "Help on built-in function _abc_register in module _abc:\n\n_abc_register(self, subclass, /)\n    Internal ABC helper for subclasss registration. Should be never used outside abc module.",
        "syntax": "Syntax: _abc_register(self, subclass, /)",
        "other-params": ""
    },
    "abc._abc_subclasscheck": {
        "function": "_abc_subclasscheck(self, subclass, /)",
        "alias": "_abc_subclasscheck",
        "help": "Help on built-in function _abc_subclasscheck in module _abc:\n\n_abc_subclasscheck(self, subclass, /)\n    Internal ABC helper for subclasss checks. Should be never used outside abc module.",
        "syntax": "Syntax: _abc_subclasscheck(self, subclass, /)",
        "other-params": ""
    },
    "abc._get_dump": {
        "function": "_get_dump(self, /)",
        "alias": "_get_dump",
        "help": "Help on built-in function _get_dump in module _abc:\n\n_get_dump(self, /)\n    Internal ABC helper for cache and registry debugging.\n\n    Return shallow copies of registry, of both caches, and\n    negative cache version. Don't call this function directly,\n    instead use ABC._dump_registry() for a nice repr.",
        "syntax": "Syntax: _get_dump(self, /)",
        "other-params": ""
    },
    "abc._reset_caches": {
        "function": "_reset_caches(self, /)",
        "alias": "_reset_caches",
        "help": "Help on built-in function _reset_caches in module _abc:\n\n_reset_caches(self, /)\n    Internal ABC helper to reset both caches of a given class.\n\n    Should be only used by refleak.py",
        "syntax": "Syntax: _reset_caches(self, /)",
        "other-params": ""
    },
    "abc._reset_registry": {
        "function": "_reset_registry(self, /)",
        "alias": "_reset_registry",
        "help": "Help on built-in function _reset_registry in module _abc:\n\n_reset_registry(self, /)\n    Internal ABC helper to reset registry of a given class.\n\n    Should be only used by refleak.py",
        "syntax": "Syntax: _reset_registry(self, /)",
        "other-params": ""
    },
    "abc.abstractclassmethod": {
        "function": "abstractclassmethod(callable)",
        "alias": "abstractclassmethod",
        "help": "Help on class abstractclassmethod in module abc:\n\nclass abstractclassmethod(builtins.classmethod)\n |  abstractclassmethod(callable)\n |\n |  A decorator indicating abstract classmethods.\n |\n |  Deprecated, use 'classmethod' with 'abstractmethod' instead:\n |\n |      class C(ABC):\n |          @classmethod\n |          @abstractmethod\n |          def my_abstract_classmethod(cls, ...):\n |              ...\n |\n |  Method resolution order:\n |      abstractclassmethod\n |      builtins.classmethod\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, callable)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __isabstractmethod__ = True\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.classmethod:\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.classmethod:\n |\n |  __new__(*args, **kwargs) class method of builtins.classmethod\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.classmethod:\n |\n |  __dict__\n |\n |  __func__\n |\n |  __wrapped__",
        "syntax": "Syntax: abstractclassmethod(callable)",
        "other-params": ""
    },
    "abc.abstractmethod": {
        "function": "abstractmethod(funcobj)",
        "alias": "abstractmethod",
        "help": "Help on function abstractmethod in module abc:\n\nabstractmethod(funcobj)\n    A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...",
        "syntax": "Syntax: abstractmethod(funcobj)",
        "other-params": ""
    },
    "abc.abstractproperty": {
        "function": "abstractproperty(fget=None, fset=None, fdel=None, doc=None)",
        "alias": "abstractproperty",
        "help": "Help on class abstractproperty in module abc:\n\nclass abstractproperty(builtins.property)\n |  abstractproperty(fget=None, fset=None, fdel=None, doc=None)\n |\n |  A decorator indicating abstract properties.\n |\n |  Deprecated, use 'property' with 'abstractmethod' instead:\n |\n |      class C(ABC):\n |          @property\n |          @abstractmethod\n |          def my_abstract_property(self):\n |              ...\n |\n |  Method resolution order:\n |      abstractproperty\n |      builtins.property\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __isabstractmethod__ = True\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.property:\n |\n |  __delete__(self, instance, /)\n |      Delete an attribute of instance.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __set__(self, instance, value, /)\n |      Set an attribute of instance to value.\n |\n |  __set_name__(self, owner, name, /)\n |      Method to set name of a property.\n |\n |  deleter(self, object, /)\n |      Descriptor to obtain a copy of the property with a different deleter.\n |\n |  getter(self, object, /)\n |      Descriptor to obtain a copy of the property with a different getter.\n |\n |  setter(self, object, /)\n |      Descriptor to obtain a copy of the property with a different setter.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.property:\n |\n |  __new__(*args, **kwargs) class method of builtins.property\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.property:\n |\n |  fdel\n |\n |  fget\n |\n |  fset",
        "syntax": "Syntax: abstractproperty(fget=None, fset=None, fdel=None, doc=None)",
        "other-params": ""
    },
    "abc.abstractstaticmethod": {
        "function": "abstractstaticmethod(callable)",
        "alias": "abstractstaticmethod",
        "help": "Help on class abstractstaticmethod in module abc:\n\nclass abstractstaticmethod(builtins.staticmethod)\n |  abstractstaticmethod(callable)\n |\n |  A decorator indicating abstract staticmethods.\n |\n |  Deprecated, use 'staticmethod' with 'abstractmethod' instead:\n |\n |      class C(ABC):\n |          @staticmethod\n |          @abstractmethod\n |          def my_abstract_staticmethod(...):\n |              ...\n |\n |  Method resolution order:\n |      abstractstaticmethod\n |      builtins.staticmethod\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, callable)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __isabstractmethod__ = True\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.staticmethod:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.staticmethod:\n |\n |  __new__(*args, **kwargs) class method of builtins.staticmethod\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.staticmethod:\n |\n |  __dict__\n |\n |  __func__\n |\n |  __wrapped__",
        "syntax": "Syntax: abstractstaticmethod(callable)",
        "other-params": ""
    },
    "abc.get_cache_token": {
        "function": "get_cache_token()",
        "alias": "get_cache_token",
        "help": "Help on built-in function get_cache_token in module _abc:\n\nget_cache_token()\n    Returns the current ABC cache token.\n\n    The token is an opaque object (supporting equality testing) identifying the\n    current version of the ABC cache for virtual subclasses. The token changes\n    with every call to register() on any ABC.",
        "syntax": "Syntax: get_cache_token()",
        "other-params": ""
    },
    "abc.update_abstractmethods": {
        "function": "update_abstractmethods(cls)",
        "alias": "update_abstractmethods",
        "help": "Help on function update_abstractmethods in module abc:\n\nupdate_abstractmethods(cls)\n    Recalculate the set of abstract methods of an abstract class.\n\n    If a class has had one of its abstract methods implemented after the\n    class was created, the method will not be considered implemented until\n    this function is called. Alternatively, if a new abstract method has been\n    added to the class, it will only be considered an abstract method of the\n    class after this function is called.\n\n    This function should be called before any use is made of the class,\n    usually in class decorators that add methods to the subject class.\n\n    Returns cls, to allow usage as a class decorator.\n\n    If cls is not an instance of ABCMeta, does nothing.",
        "syntax": "Syntax: update_abstractmethods(cls)",
        "other-params": ""
    },
    "io.BlockingIOError": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'BlockingIOError'>",
        "alias": "BlockingIOError",
        "help": "Help on class BlockingIOError in module builtins:\n\nclass BlockingIOError(OSError)\n |  I/O operation would block.\n |\n |  Method resolution order:\n |      BlockingIOError\n |      OSError\n |      Exception\n |      BaseException\n |      object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from OSError:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from OSError:\n |\n |  __new__(*args, **kwargs) class method of builtins.OSError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from OSError:\n |\n |  characters_written\n |\n |  errno\n |      POSIX exception code\n |\n |  filename\n |      exception filename\n |\n |  filename2\n |      second exception filename\n |\n |  strerror\n |      exception strerror\n |\n |  winerror\n |      Win32 exception code\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'BlockingIOError'>",
        "other-params": ""
    },
    "io.BufferedIOBase": {
        "function": "BufferedIOBase()",
        "alias": "BufferedIOBase",
        "help": "Help on class BufferedIOBase in module io:\n\nclass BufferedIOBase(_io._BufferedIOBase, IOBase)\n |  Base class for buffered IO objects.\n |\n |  The main difference with RawIOBase is that the read() method\n |  supports omitting the size argument, and does not have a default\n |  implementation that defers to readinto().\n |\n |  In addition, read(), readinto() and write() may raise\n |  BlockingIOError if the underlying raw stream is in non-blocking\n |  mode and not ready; unlike their raw counterparts, they will never\n |  return None.\n |\n |  A typical implementation should not inherit from a RawIOBase\n |  implementation, but wrap one.\n |\n |  Method resolution order:\n |      BufferedIOBase\n |      _io._BufferedIOBase\n |      IOBase\n |      _io._IOBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._BufferedIOBase:\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  read(self, size=-1, /)\n |      Read and return up to n bytes.\n |\n |      If the size argument is omitted, None, or negative, read and\n |      return all data until EOF.\n |\n |      If the size argument is positive, and the underlying raw stream is\n |      not 'interactive', multiple raw reads may be issued to satisfy\n |      the byte count (unless EOF is reached first).\n |      However, for interactive raw streams (as well as sockets and pipes),\n |      at most one raw read will be issued, and a short result does not\n |      imply that EOF is imminent.\n |\n |      Return an empty bytes object on EOF.\n |\n |      Return None if the underlying raw stream was open in non-blocking\n |      mode and no data is available at the moment.\n |\n |  read1(self, size=-1, /)\n |      Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n |\n |      Return an empty bytes object on EOF.\n |      A short result does not imply that EOF is imminent.\n |\n |  readinto(self, buffer, /)\n |\n |  readinto1(self, buffer, /)\n |\n |  write(self, b, /)\n |      Write buffer b to the IO stream.\n |\n |      Return the number of bytes written, which is always\n |      the length of b in bytes.\n |\n |      Raise BlockingIOError if the buffer is full and the\n |      underlying raw stream cannot accept more data at the moment.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _io._IOBase:\n |\n |  __dict__\n |\n |  closed",
        "syntax": "Syntax: BufferedIOBase()",
        "other-params": ""
    },
    "io.BufferedRWPair": {
        "function": "BufferedRWPair(reader, writer, buffer_size=8192, /)",
        "alias": "BufferedRWPair",
        "help": "Help on class BufferedRWPair in module _io:\n\nclass BufferedRWPair(_BufferedIOBase)\n |  BufferedRWPair(reader, writer, buffer_size=8192, /)\n |\n |  A buffered reader and writer object together.\n |\n |  A buffered reader object and buffered writer object put together to\n |  form a sequential IO object that can read and write. This is typically\n |  used with a socket or two-way pipe.\n |\n |  reader and writer are RawIOBase objects that are readable and\n |  writeable respectively. If the buffer_size is omitted it defaults to\n |  DEFAULT_BUFFER_SIZE.\n |\n |  Method resolution order:\n |      BufferedRWPair\n |      _BufferedIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  peek(...)\n |\n |  read(...)\n |      Read and return up to n bytes.\n |\n |      If the size argument is omitted, None, or negative, read and\n |      return all data until EOF.\n |\n |      If the size argument is positive, and the underlying raw stream is\n |      not 'interactive', multiple raw reads may be issued to satisfy\n |      the byte count (unless EOF is reached first).\n |      However, for interactive raw streams (as well as sockets and pipes),\n |      at most one raw read will be issued, and a short result does not\n |      imply that EOF is imminent.\n |\n |      Return an empty bytes object on EOF.\n |\n |      Return None if the underlying raw stream was open in non-blocking\n |      mode and no data is available at the moment.\n |\n |  read1(...)\n |      Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n |\n |      Return an empty bytes object on EOF.\n |      A short result does not imply that EOF is imminent.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readinto(...)\n |\n |  readinto1(...)\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  write(...)\n |      Write buffer b to the IO stream.\n |\n |      Return the number of bytes written, which is always\n |      the length of b in bytes.\n |\n |      Raise BlockingIOError if the buffer is full and the\n |      underlying raw stream cannot accept more data at the moment.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BufferedIOBase:\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: BufferedRWPair(reader, writer, buffer_size=8192, /)",
        "other-params": ""
    },
    "io.BufferedRandom": {
        "function": "BufferedRandom(raw, buffer_size=8192)",
        "alias": "BufferedRandom",
        "help": "Help on class BufferedRandom in module _io:\n\nclass BufferedRandom(_BufferedIOBase)\n |  BufferedRandom(raw, buffer_size=8192)\n |\n |  A buffered interface to random access streams.\n |\n |  The constructor creates a reader and writer for a seekable stream,\n |  raw, given in the first argument. If the buffer_size is omitted it\n |  defaults to DEFAULT_BUFFER_SIZE.\n |\n |  Method resolution order:\n |      BufferedRandom\n |      _BufferedIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __reduce_ex__(self, object, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  peek(self, size=0, /)\n |\n |  read(self, size=-1, /)\n |      Read and return up to n bytes.\n |\n |      If the size argument is omitted, None, or negative, read and\n |      return all data until EOF.\n |\n |      If the size argument is positive, and the underlying raw stream is\n |      not 'interactive', multiple raw reads may be issued to satisfy\n |      the byte count (unless EOF is reached first).\n |      However, for interactive raw streams (as well as sockets and pipes),\n |      at most one raw read will be issued, and a short result does not\n |      imply that EOF is imminent.\n |\n |      Return an empty bytes object on EOF.\n |\n |      Return None if the underlying raw stream was open in non-blocking\n |      mode and no data is available at the moment.\n |\n |  read1(self, size=-1, /)\n |      Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n |\n |      Return an empty bytes object on EOF.\n |      A short result does not imply that EOF is imminent.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readinto(self, buffer, /)\n |\n |  readinto1(self, buffer, /)\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  seek(self, target, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, pos=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  write(self, buffer, /)\n |      Write buffer b to the IO stream.\n |\n |      Return the number of bytes written, which is always\n |      the length of b in bytes.\n |\n |      Raise BlockingIOError if the buffer is full and the\n |      underlying raw stream cannot accept more data at the moment.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |\n |  mode\n |\n |  name\n |\n |  raw\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: BufferedRandom(raw, buffer_size=8192)",
        "other-params": ""
    },
    "io.BufferedReader": {
        "function": "BufferedReader(raw, buffer_size=8192)",
        "alias": "BufferedReader",
        "help": "Help on class BufferedReader in module _io:\n\nclass BufferedReader(_BufferedIOBase)\n |  BufferedReader(raw, buffer_size=8192)\n |\n |  Create a new buffered reader using the given readable raw IO object.\n |\n |  Method resolution order:\n |      BufferedReader\n |      _BufferedIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __reduce_ex__(self, object, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  peek(self, size=0, /)\n |\n |  read(self, size=-1, /)\n |      Read and return up to n bytes.\n |\n |      If the size argument is omitted, None, or negative, read and\n |      return all data until EOF.\n |\n |      If the size argument is positive, and the underlying raw stream is\n |      not 'interactive', multiple raw reads may be issued to satisfy\n |      the byte count (unless EOF is reached first).\n |      However, for interactive raw streams (as well as sockets and pipes),\n |      at most one raw read will be issued, and a short result does not\n |      imply that EOF is imminent.\n |\n |      Return an empty bytes object on EOF.\n |\n |      Return None if the underlying raw stream was open in non-blocking\n |      mode and no data is available at the moment.\n |\n |  read1(self, size=-1, /)\n |      Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n |\n |      Return an empty bytes object on EOF.\n |      A short result does not imply that EOF is imminent.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readinto(self, buffer, /)\n |\n |  readinto1(self, buffer, /)\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  seek(self, target, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, pos=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |\n |  mode\n |\n |  name\n |\n |  raw\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BufferedIOBase:\n |\n |  write(self, b, /)\n |      Write buffer b to the IO stream.\n |\n |      Return the number of bytes written, which is always\n |      the length of b in bytes.\n |\n |      Raise BlockingIOError if the buffer is full and the\n |      underlying raw stream cannot accept more data at the moment.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: BufferedReader(raw, buffer_size=8192)",
        "other-params": ""
    },
    "io.BufferedWriter": {
        "function": "BufferedWriter(raw, buffer_size=8192)",
        "alias": "BufferedWriter",
        "help": "Help on class BufferedWriter in module _io:\n\nclass BufferedWriter(_BufferedIOBase)\n |  BufferedWriter(raw, buffer_size=8192)\n |\n |  A buffer for a writeable sequential RawIO object.\n |\n |  The constructor creates a BufferedWriter for the given writeable raw\n |  stream. If the buffer_size is not given, it defaults to\n |  DEFAULT_BUFFER_SIZE.\n |\n |  Method resolution order:\n |      BufferedWriter\n |      _BufferedIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __reduce_ex__(self, object, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  seek(self, target, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, pos=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  write(self, buffer, /)\n |      Write buffer b to the IO stream.\n |\n |      Return the number of bytes written, which is always\n |      the length of b in bytes.\n |\n |      Raise BlockingIOError if the buffer is full and the\n |      underlying raw stream cannot accept more data at the moment.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |\n |  mode\n |\n |  name\n |\n |  raw\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BufferedIOBase:\n |\n |  read(self, size=-1, /)\n |      Read and return up to n bytes.\n |\n |      If the size argument is omitted, None, or negative, read and\n |      return all data until EOF.\n |\n |      If the size argument is positive, and the underlying raw stream is\n |      not 'interactive', multiple raw reads may be issued to satisfy\n |      the byte count (unless EOF is reached first).\n |      However, for interactive raw streams (as well as sockets and pipes),\n |      at most one raw read will be issued, and a short result does not\n |      imply that EOF is imminent.\n |\n |      Return an empty bytes object on EOF.\n |\n |      Return None if the underlying raw stream was open in non-blocking\n |      mode and no data is available at the moment.\n |\n |  read1(self, size=-1, /)\n |      Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n |\n |      Return an empty bytes object on EOF.\n |      A short result does not imply that EOF is imminent.\n |\n |  readinto(self, buffer, /)\n |\n |  readinto1(self, buffer, /)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: BufferedWriter(raw, buffer_size=8192)",
        "other-params": ""
    },
    "io.BytesIO": {
        "function": "BytesIO(initial_bytes=b'')",
        "alias": "BytesIO",
        "help": "Help on class BytesIO in module _io:\n\nclass BytesIO(_BufferedIOBase)\n |  BytesIO(initial_bytes=b'')\n |\n |  Buffered I/O implementation using an in-memory bytes buffer.\n |\n |  Method resolution order:\n |      BytesIO\n |      _BufferedIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getstate__(self, /)\n |      Helper for pickle.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  close(self, /)\n |      Disable all I/O operations.\n |\n |  flush(self, /)\n |      Does nothing.\n |\n |  getbuffer(self, /)\n |      Get a read-write view over the contents of the BytesIO object.\n |\n |  getvalue(self, /)\n |      Retrieve the entire contents of the BytesIO object.\n |\n |  isatty(self, /)\n |      Always returns False.\n |\n |      BytesIO objects are not connected to a TTY-like device.\n |\n |  read(self, size=-1, /)\n |      Read at most size bytes, returned as a bytes object.\n |\n |      If the size argument is negative, read until EOF is reached.\n |      Return an empty bytes object at EOF.\n |\n |  read1(self, size=-1, /)\n |      Read at most size bytes, returned as a bytes object.\n |\n |      If the size argument is negative or omitted, read until EOF is reached.\n |      Return an empty bytes object at EOF.\n |\n |  readable(self, /)\n |      Returns True if the IO object can be read.\n |\n |  readinto(self, buffer, /)\n |      Read bytes into buffer.\n |\n |      Returns number of bytes read (0 for EOF), or None if the object\n |      is set not to block and has no data to read.\n |\n |  readline(self, size=-1, /)\n |      Next line from the file, as a bytes object.\n |\n |      Retain newline.  A non-negative size argument limits the maximum\n |      number of bytes to return (an incomplete line may be returned then).\n |      Return an empty bytes object at EOF.\n |\n |  readlines(self, size=None, /)\n |      List of bytes objects, each a line from the file.\n |\n |      Call readline() repeatedly and return a list of the lines so read.\n |      The optional size argument, if given, is an approximate bound on the\n |      total number of bytes in the lines returned.\n |\n |  seek(self, pos, whence=0, /)\n |      Change stream position.\n |\n |      Seek to byte offset pos relative to position indicated by whence:\n |           0  Start of stream (the default).  pos should be >= 0;\n |           1  Current position - pos may be negative;\n |           2  End of stream - pos usually negative.\n |      Returns the new absolute position.\n |\n |  seekable(self, /)\n |      Returns True if the IO object can be seeked.\n |\n |  tell(self, /)\n |      Current file position, an integer.\n |\n |  truncate(self, size=None, /)\n |      Truncate the file to at most size bytes.\n |\n |      Size defaults to the current file position, as returned by tell().\n |      The current file position is unchanged.  Returns the new size.\n |\n |  writable(self, /)\n |      Returns True if the IO object can be written.\n |\n |  write(self, b, /)\n |      Write bytes to file.\n |\n |      Return the number of bytes written.\n |\n |  writelines(self, lines, /)\n |      Write lines to the file.\n |\n |      Note that newlines are not added.  lines can be any iterable object\n |      producing bytes-like objects. This is equivalent to calling write() for\n |      each element.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |      True if the file is closed.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BufferedIOBase:\n |\n |  detach(self, /)\n |      Disconnect this buffer from its underlying raw stream and return it.\n |\n |      After the raw stream has been detached, the buffer is in an unusable\n |      state.\n |\n |  readinto1(self, buffer, /)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: BytesIO(initial_bytes=b'')",
        "other-params": ""
    },
    "io.FileIO": {
        "function": "FileIO(file, mode='r', closefd=True, opener=None)",
        "alias": "FileIO",
        "help": "Help on class FileIO in module _io:\n\nclass FileIO(_RawIOBase)\n |  FileIO(file, mode='r', closefd=True, opener=None)\n |\n |  Open a file.\n |\n |  The mode can be 'r' (default), 'w', 'x' or 'a' for reading,\n |  writing, exclusive creation or appending.  The file will be created if it\n |  doesn't exist when opened for writing or appending; it will be truncated\n |  when opened for writing.  A FileExistsError will be raised if it already\n |  exists when opened for creating. Opening a file for creating implies\n |  writing so this mode behaves in a similar way to 'w'.Add a '+' to the mode\n |  to allow simultaneous reading and writing. A custom opener can be used by\n |  passing a callable as *opener*. The underlying file descriptor for the file\n |  object is then obtained by calling opener with (*name*, *flags*).\n |  *opener* must return an open file descriptor (passing os.open as *opener*\n |  results in functionality similar to passing None).\n |\n |  Method resolution order:\n |      FileIO\n |      _RawIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __reduce_ex__(self, object, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  close(self, /)\n |      Close the file.\n |\n |      A closed file cannot be used for further I/O operations.  close() may be\n |      called more than once without error.\n |\n |  fileno(self, /)\n |      Return the underlying file descriptor (an integer).\n |\n |  isatty(self, /)\n |      True if the file is connected to a TTY device.\n |\n |  read(self, size=-1, /)\n |      Read at most size bytes, returned as bytes.\n |\n |      Only makes one system call, so less data may be returned than requested.\n |      In non-blocking mode, returns None if no data is available.\n |      Return an empty bytes object at EOF.\n |\n |  readable(self, /)\n |      True if file was opened in a read mode.\n |\n |  readall(self, /)\n |      Read all data from the file, returned as bytes.\n |\n |      In non-blocking mode, returns as much as is immediately available,\n |      or None if no data is available.  Return an empty bytes object at EOF.\n |\n |  readinto(self, buffer, /)\n |      Same as RawIOBase.readinto().\n |\n |  seek(self, pos, whence=0, /)\n |      Move to new file position and return the file position.\n |\n |      Argument offset is a byte count.  Optional argument whence defaults to\n |      SEEK_SET or 0 (offset from start of file, offset should be >= 0); other values\n |      are SEEK_CUR or 1 (move relative to current position, positive or negative),\n |      and SEEK_END or 2 (move relative to end of file, usually negative, although\n |      many platforms allow seeking beyond the end of a file).\n |\n |      Note that not all file objects are seekable.\n |\n |  seekable(self, /)\n |      True if file supports random-access.\n |\n |  tell(self, /)\n |      Current file position.\n |\n |      Can raise OSError for non seekable files.\n |\n |  truncate(self, size=None, /)\n |      Truncate the file to at most size bytes and return the truncated size.\n |\n |      Size defaults to the current file position, as returned by tell().\n |      The current file position is changed to the value of size.\n |\n |  writable(self, /)\n |      True if file was opened in a write mode.\n |\n |  write(self, b, /)\n |      Write buffer b to file, return number of bytes written.\n |\n |      Only makes one system call, so not all of the data may be written.\n |      The number of bytes actually written is returned.  In non-blocking mode,\n |      returns None if the write would block.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |      True if the file is closed\n |\n |  closefd\n |      True if the file descriptor will be closed by close().\n |\n |  mode\n |      String giving the file mode\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: FileIO(file, mode='r', closefd=True, opener=None)",
        "other-params": ""
    },
    "io.IOBase": {
        "function": "IOBase()",
        "alias": "IOBase",
        "help": "Help on class IOBase in module io:\n\nclass IOBase(_io._IOBase)\n |  The abstract base class for all I/O classes.\n |\n |  This class provides dummy implementations for many methods that\n |  derived classes can override selectively; the default implementations\n |  represent a file that cannot be read, written or seeked.\n |\n |  Even though IOBase does not declare read, readinto, or write because\n |  their signatures will vary, implementations and clients should\n |  consider those methods part of the interface. Also, implementations\n |  may raise UnsupportedOperation when operations they do not support are\n |  called.\n |\n |  The basic type used for binary data read from or written to a file is\n |  bytes. Other bytes-like objects are accepted as method arguments too.\n |  In some cases (such as readinto), a writable object is required. Text\n |  I/O classes work with str data.\n |\n |  Note that calling any method (except additional calls to close(),\n |  which are ignored) on a closed stream should raise a ValueError.\n |\n |  IOBase (and its subclasses) support the iterator protocol, meaning\n |  that an IOBase object can be iterated over yielding the lines in a\n |  stream.\n |\n |  IOBase also supports the :keyword:`with` statement. In this example,\n |  fp is closed after the suite of the with statement is complete:\n |\n |  with open('spam.txt', 'r') as fp:\n |      fp.write('Spam and eggs!')\n |\n |  Method resolution order:\n |      IOBase\n |      _io._IOBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _io._IOBase:\n |\n |  __dict__\n |\n |  closed",
        "syntax": "Syntax: IOBase()",
        "other-params": ""
    },
    "io.IncrementalNewlineDecoder": {
        "function": "IncrementalNewlineDecoder(decoder, translate, errors='strict')",
        "alias": "IncrementalNewlineDecoder",
        "help": "Help on class IncrementalNewlineDecoder in module _io:\n\nclass IncrementalNewlineDecoder(builtins.object)\n |  IncrementalNewlineDecoder(decoder, translate, errors='strict')\n |\n |  Codec used when reading a file in universal newlines mode.\n |\n |  It wraps another incremental decoder, translating \\r\\n and \\r into \\n.\n |  It also records the types of newlines encountered.  When used with\n |  translate=False, it ensures that the newline sequence is returned in\n |  one piece. When used with decoder=None, it expects unicode strings as\n |  decode input and translates newlines without first invoking an external\n |  decoder.\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  decode(self, /, input, final=False)\n |\n |  getstate(self, /)\n |\n |  reset(self, /)\n |\n |  setstate(self, state, /)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  newlines",
        "syntax": "Syntax: IncrementalNewlineDecoder(decoder, translate, errors='strict')",
        "other-params": ""
    },
    "io.RawIOBase": {
        "function": "RawIOBase()",
        "alias": "RawIOBase",
        "help": "Help on class RawIOBase in module io:\n\nclass RawIOBase(_io._RawIOBase, IOBase)\n |  Base class for raw binary I/O.\n |\n |  Method resolution order:\n |      RawIOBase\n |      _io._RawIOBase\n |      IOBase\n |      _io._IOBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._RawIOBase:\n |\n |  read(self, size=-1, /)\n |\n |  readall(self, /)\n |      Read until EOF, using multiple read() call.\n |\n |  readinto(...)\n |\n |  write(...)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _io._IOBase:\n |\n |  __dict__\n |\n |  closed",
        "syntax": "Syntax: RawIOBase()",
        "other-params": ""
    },
    "io.StringIO": {
        "function": "StringIO(initial_value='', newline='\\n')",
        "alias": "StringIO",
        "help": "Help on class StringIO in module _io:\n\nclass StringIO(_TextIOBase)\n |  StringIO(initial_value='', newline='\\n')\n |\n |  Text I/O implementation using an in-memory buffer.\n |\n |  The initial_value argument sets the value of object.  The newline\n |  argument is like the one of TextIOWrapper's constructor.\n |\n |  Method resolution order:\n |      StringIO\n |      _TextIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getstate__(self, /)\n |      Helper for pickle.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __setstate__(self, state, /)\n |\n |  close(self, /)\n |      Close the IO object.\n |\n |      Attempting any further operation after the object is closed\n |      will raise a ValueError.\n |\n |      This method has no effect if the file is already closed.\n |\n |  getvalue(self, /)\n |      Retrieve the entire contents of the object.\n |\n |  read(self, size=-1, /)\n |      Read at most size characters, returned as a string.\n |\n |      If the argument is negative or omitted, read until EOF\n |      is reached. Return an empty string at EOF.\n |\n |  readable(self, /)\n |      Returns True if the IO object can be read.\n |\n |  readline(self, size=-1, /)\n |      Read until newline or EOF.\n |\n |      Returns an empty string if EOF is hit immediately.\n |\n |  seek(self, pos, whence=0, /)\n |      Change stream position.\n |\n |      Seek to character offset pos relative to position indicated by whence:\n |          0  Start of stream (the default).  pos should be >= 0;\n |          1  Current position - pos must be 0;\n |          2  End of stream - pos must be 0.\n |      Returns the new absolute position.\n |\n |  seekable(self, /)\n |      Returns True if the IO object can be seeked.\n |\n |  tell(self, /)\n |      Tell the current file position.\n |\n |  truncate(self, pos=None, /)\n |      Truncate size to pos.\n |\n |      The pos argument defaults to the current file position, as\n |      returned by tell().  The current file position is unchanged.\n |      Returns the new absolute position.\n |\n |  writable(self, /)\n |      Returns True if the IO object can be written.\n |\n |  write(self, s, /)\n |      Write string to file.\n |\n |      Returns the number of characters written, which is always equal to\n |      the length of the string.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |\n |  line_buffering\n |\n |  newlines\n |      Line endings translated so far.\n |\n |      Only line endings translated during reading are considered.\n |\n |      Subclasses should override.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _TextIOBase:\n |\n |  detach(self, /)\n |      Separate the underlying buffer from the TextIOBase and return it.\n |\n |      After the underlying buffer has been detached, the TextIO is in an unusable state.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _TextIOBase:\n |\n |  encoding\n |      Encoding of the text stream.\n |\n |      Subclasses should override.\n |\n |  errors\n |      The error setting of the decoder or encoder.\n |\n |      Subclasses should override.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: StringIO(initial_value='', newline='\\n')",
        "other-params": ""
    },
    "io.TextIOBase": {
        "function": "TextIOBase()",
        "alias": "TextIOBase",
        "help": "Help on class TextIOBase in module io:\n\nclass TextIOBase(_io._TextIOBase, IOBase)\n |  Base class for text I/O.\n |\n |  This class provides a character and line based interface to stream\n |  I/O. There is no readinto method because Python's character strings\n |  are immutable.\n |\n |  Method resolution order:\n |      TextIOBase\n |      _io._TextIOBase\n |      IOBase\n |      _io._IOBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._TextIOBase:\n |\n |  detach(self, /)\n |      Separate the underlying buffer from the TextIOBase and return it.\n |\n |      After the underlying buffer has been detached, the TextIO is in an unusable state.\n |\n |  read(self, size=-1, /)\n |      Read at most size characters from stream.\n |\n |      Read from underlying buffer until we have size characters or we hit EOF.\n |      If size is negative or omitted, read until EOF.\n |\n |  readline(self, size=-1, /)\n |      Read until newline or EOF.\n |\n |      Return an empty string if EOF is hit immediately.\n |      If size is specified, at most size characters will be read.\n |\n |  write(self, s, /)\n |      Write string s to stream.\n |\n |      Return the number of characters written\n |      (which is always equal to the length of the string).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _io._TextIOBase:\n |\n |  encoding\n |      Encoding of the text stream.\n |\n |      Subclasses should override.\n |\n |  errors\n |      The error setting of the decoder or encoder.\n |\n |      Subclasses should override.\n |\n |  newlines\n |      Line endings translated so far.\n |\n |      Only line endings translated during reading are considered.\n |\n |      Subclasses should override.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _io._IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _io._IOBase:\n |\n |  __dict__\n |\n |  closed",
        "syntax": "Syntax: TextIOBase()",
        "other-params": ""
    },
    "io.TextIOWrapper": {
        "function": "TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)",
        "alias": "TextIOWrapper",
        "help": "Help on class TextIOWrapper in module _io:\n\nclass TextIOWrapper(_TextIOBase)\n |  TextIOWrapper(\n |      buffer,\n |      encoding=None,\n |      errors=None,\n |      newline=None,\n |      line_buffering=False,\n |      write_through=False\n |  )\n |\n |  Character and line based layer over a BufferedIOBase object, buffer.\n |\n |  encoding gives the name of the encoding that the stream will be\n |  decoded or encoded with. It defaults to locale.getencoding().\n |\n |  errors determines the strictness of encoding and decoding (see\n |  help(codecs.Codec) or the documentation for codecs.register) and\n |  defaults to \"strict\".\n |\n |  newline controls how line endings are handled. It can be None, '',\n |  '\\n', '\\r', and '\\r\\n'.  It works as follows:\n |\n |  * On input, if newline is None, universal newlines mode is\n |    enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n |    these are translated into '\\n' before being returned to the\n |    caller. If it is '', universal newline mode is enabled, but line\n |    endings are returned to the caller untranslated. If it has any of\n |    the other legal values, input lines are only terminated by the given\n |    string, and the line ending is returned to the caller untranslated.\n |\n |  * On output, if newline is None, any '\\n' characters written are\n |    translated to the system default line separator, os.linesep. If\n |    newline is '' or '\\n', no translation takes place. If newline is any\n |    of the other legal values, any '\\n' characters written are translated\n |    to the given string.\n |\n |  If line_buffering is True, a call to flush is implied when a call to\n |  write contains a newline character.\n |\n |  Method resolution order:\n |      TextIOWrapper\n |      _TextIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __reduce_ex__(self, object, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  close(self, /)\n |      Flush and close the IO object.\n |\n |      This method has no effect if the file is already closed.\n |\n |  detach(self, /)\n |      Separate the underlying buffer from the TextIOBase and return it.\n |\n |      After the underlying buffer has been detached, the TextIO is in an unusable state.\n |\n |  fileno(self, /)\n |      Return underlying file descriptor if one exists.\n |\n |      Raise OSError if the IO object does not use a file descriptor.\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  isatty(self, /)\n |      Return whether this is an 'interactive' stream.\n |\n |      Return False if it can't be determined.\n |\n |  read(self, size=-1, /)\n |      Read at most size characters from stream.\n |\n |      Read from underlying buffer until we have size characters or we hit EOF.\n |      If size is negative or omitted, read until EOF.\n |\n |  readable(self, /)\n |      Return whether object was opened for reading.\n |\n |      If False, read() will raise OSError.\n |\n |  readline(self, size=-1, /)\n |      Read until newline or EOF.\n |\n |      Return an empty string if EOF is hit immediately.\n |      If size is specified, at most size characters will be read.\n |\n |  reconfigure(\n |      self,\n |      /,\n |      *,\n |      encoding=None,\n |      errors=None,\n |      newline=None,\n |      line_buffering=None,\n |      write_through=None\n |  )\n |      Reconfigure the text stream with new parameters.\n |\n |      This also does an implicit stream flush.\n |\n |  seek(self, cookie, whence=0, /)\n |      Set the stream position, and return the new stream position.\n |\n |        cookie\n |          Zero or an opaque number returned by tell().\n |        whence\n |          The relative position to seek from.\n |\n |      Four operations are supported, given by the following argument\n |      combinations:\n |\n |      - seek(0, SEEK_SET): Rewind to the start of the stream.\n |      - seek(cookie, SEEK_SET): Restore a previous position;\n |        'cookie' must be a number returned by tell().\n |      - seek(0, SEEK_END): Fast-forward to the end of the stream.\n |      - seek(0, SEEK_CUR): Leave the current stream position unchanged.\n |\n |      Any other argument combinations are invalid,\n |      and may raise exceptions.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return the stream position as an opaque number.\n |\n |      The return value of tell() can be given as input to seek(), to restore a\n |      previous stream position.\n |\n |  truncate(self, pos=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writable(self, /)\n |      Return whether object was opened for writing.\n |\n |      If False, write() will raise OSError.\n |\n |  write(self, text, /)\n |      Write string s to stream.\n |\n |      Return the number of characters written\n |      (which is always equal to the length of the string).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  buffer\n |\n |  closed\n |\n |  encoding\n |      Encoding of the text stream.\n |\n |      Subclasses should override.\n |\n |  errors\n |      The error setting of the decoder or encoder.\n |\n |      Subclasses should override.\n |\n |  line_buffering\n |\n |  name\n |\n |  newlines\n |      Line endings translated so far.\n |\n |      Only line endings translated during reading are considered.\n |\n |      Subclasses should override.\n |\n |  write_through\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)",
        "other-params": ""
    },
    "io.UnsupportedOperation": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'io.UnsupportedOperation'>",
        "alias": "UnsupportedOperation",
        "help": "Help on class UnsupportedOperation in module io:\n\nclass UnsupportedOperation(builtins.OSError, builtins.ValueError)\n |  Method resolution order:\n |      UnsupportedOperation\n |      builtins.OSError\n |      builtins.ValueError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.OSError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.OSError:\n |\n |  __new__(*args, **kwargs) class method of builtins.OSError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.OSError:\n |\n |  characters_written\n |\n |  errno\n |      POSIX exception code\n |\n |  filename\n |      exception filename\n |\n |  filename2\n |      second exception filename\n |\n |  strerror\n |      exception strerror\n |\n |  winerror\n |      Win32 exception code\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'io.UnsupportedOperation'>",
        "other-params": ""
    },
    "io._WindowsConsoleIO": {
        "function": "_WindowsConsoleIO(file, mode='r', closefd=True, opener=None)",
        "alias": "_WindowsConsoleIO",
        "help": "Help on class _WindowsConsoleIO in module _io:\n\nclass _WindowsConsoleIO(_RawIOBase)\n |  _WindowsConsoleIO(file, mode='r', closefd=True, opener=None)\n |\n |  Open a console buffer by file descriptor.\n |\n |  The mode can be 'rb' (default), or 'wb' for reading or writing bytes. All\n |  other mode characters will be ignored. Mode 'b' will be assumed if it is\n |  omitted. The *opener* parameter is always ignored.\n |\n |  Method resolution order:\n |      _WindowsConsoleIO\n |      _RawIOBase\n |      _IOBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  close(self, /)\n |      Close the console object.\n |\n |      A closed console object cannot be used for further I/O operations.\n |      close() may be called more than once without error.\n |\n |  fileno(self, /)\n |      Return the underlying file descriptor (an integer).\n |\n |  isatty(self, /)\n |      Always True.\n |\n |  read(self, size=-1, /)\n |      Read at most size bytes, returned as bytes.\n |\n |      Only makes one system call when size is a positive integer,\n |      so less data may be returned than requested.\n |      Return an empty bytes object at EOF.\n |\n |  readable(self, /)\n |      True if console is an input buffer.\n |\n |  readall(self, /)\n |      Read all data from the console, returned as bytes.\n |\n |      Return an empty bytes object at EOF.\n |\n |  readinto(self, buffer, /)\n |      Same as RawIOBase.readinto().\n |\n |  writable(self, /)\n |      True if console is an output buffer.\n |\n |  write(self, b, /)\n |      Write buffer b to file, return number of bytes written.\n |\n |      Only makes one system call, so not all of the data may be written.\n |      The number of bytes actually written is returned.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  closed\n |      True if the file is closed\n |\n |  closefd\n |      True if the file descriptor will be closed by close().\n |\n |  mode\n |      String giving the file mode\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _IOBase:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __enter__(self, /)\n |\n |  __exit__(...)\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  flush(self, /)\n |      Flush write buffers, if applicable.\n |\n |      This is not implemented for read-only and non-blocking streams.\n |\n |  readline(self, size=-1, /)\n |      Read and return a line from the stream.\n |\n |      If size is specified, at most size bytes will be read.\n |\n |      The line terminator is always b'\\n' for binary files; for text\n |      files, the newlines argument to open can be used to select the line\n |      terminator(s) recognized.\n |\n |  readlines(self, hint=-1, /)\n |      Return a list of lines from the stream.\n |\n |      hint can be specified to control the number of lines read: no more\n |      lines will be read if the total size (in bytes/characters) of all\n |      lines so far exceeds hint.\n |\n |  seek(self, offset, whence=0, /)\n |      Change the stream position to the given byte offset.\n |\n |        offset\n |          The stream position, relative to 'whence'.\n |        whence\n |          The relative position to seek from.\n |\n |      The offset is interpreted relative to the position indicated by whence.\n |      Values for whence are:\n |\n |      * os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n |      * os.SEEK_CUR or 1 -- current stream position; offset may be negative\n |      * os.SEEK_END or 2 -- end of stream; offset is usually negative\n |\n |      Return the new absolute position.\n |\n |  seekable(self, /)\n |      Return whether object supports random access.\n |\n |      If False, seek(), tell() and truncate() will raise OSError.\n |      This method may need to do a test seek().\n |\n |  tell(self, /)\n |      Return current stream position.\n |\n |  truncate(self, size=None, /)\n |      Truncate file to size bytes.\n |\n |      File pointer is left unchanged. Size defaults to the current IO position\n |      as reported by tell(). Return the new size.\n |\n |  writelines(self, lines, /)\n |      Write a list of lines to stream.\n |\n |      Line separators are not added, so it is usual for each of the\n |      lines provided to have a line separator at the end.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _IOBase:\n |\n |  __dict__",
        "syntax": "Syntax: _WindowsConsoleIO(file, mode='r', closefd=True, opener=None)",
        "other-params": ""
    },
    "io.open": {
        "function": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
        "alias": "open",
        "help": "Help on built-in function open in module _io:\n\nopen(\n    file,\n    mode='r',\n    buffering=-1,\n    encoding=None,\n    errors=None,\n    newline=None,\n    closefd=True,\n    opener=None\n)\n    Open file and return a stream.  Raise OSError upon failure.\n\n    file is either a text or byte string giving the name (and the path\n    if the file isn't in the current working directory) of the file to\n    be opened or an integer file descriptor of the file to be\n    wrapped. (If a file descriptor is given, it is closed when the\n    returned I/O object is closed, unless closefd is set to False.)\n\n    mode is an optional string that specifies the mode in which the file\n    is opened. It defaults to 'r' which means open for reading in text\n    mode.  Other common values are 'w' for writing (truncating the file if\n    it already exists), 'x' for creating and writing to a new file, and\n    'a' for appending (which on some Unix systems, means that all writes\n    append to the end of the file regardless of the current seek position).\n    In text mode, if encoding is not specified the encoding used is platform\n    dependent: locale.getencoding() is called to get the current locale encoding.\n    (For reading and writing raw bytes use binary mode and leave encoding\n    unspecified.) The available modes are:\n\n    ========= ===============================================================\n    Character Meaning\n    --------- ---------------------------------------------------------------\n    'r'       open for reading (default)\n    'w'       open for writing, truncating the file first\n    'x'       create a new file and open it for writing\n    'a'       open for writing, appending to the end of the file if it exists\n    'b'       binary mode\n    't'       text mode (default)\n    '+'       open a disk file for updating (reading and writing)\n    ========= ===============================================================\n\n    The default mode is 'rt' (open for reading text). For binary random\n    access, the mode 'w+b' opens and truncates the file to 0 bytes, while\n    'r+b' opens the file without truncation. The 'x' mode implies 'w' and\n    raises an `FileExistsError` if the file already exists.\n\n    Python distinguishes between files opened in binary and text modes,\n    even when the underlying operating system doesn't. Files opened in\n    binary mode (appending 'b' to the mode argument) return contents as\n    bytes objects without any decoding. In text mode (the default, or when\n    't' is appended to the mode argument), the contents of the file are\n    returned as strings, the bytes having been first decoded using a\n    platform-dependent encoding or using the specified encoding if given.\n\n    buffering is an optional integer used to set the buffering policy.\n    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select\n    line buffering (only usable in text mode), and an integer > 1 to indicate\n    the size of a fixed-size chunk buffer.  When no buffering argument is\n    given, the default buffering policy works as follows:\n\n    * Binary files are buffered in fixed-size chunks; the size of the buffer\n      is chosen using a heuristic trying to determine the underlying device's\n      \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n      On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n    * \"Interactive\" text files (files for which isatty() returns True)\n      use line buffering.  Other text files use the policy described above\n      for binary files.\n\n    encoding is the name of the encoding used to decode or encode the\n    file. This should only be used in text mode. The default encoding is\n    platform dependent, but any encoding supported by Python can be\n    passed.  See the codecs module for the list of supported encodings.\n\n    errors is an optional string that specifies how encoding errors are to\n    be handled---this argument should not be used in binary mode. Pass\n    'strict' to raise a ValueError exception if there is an encoding error\n    (the default of None has the same effect), or pass 'ignore' to ignore\n    errors. (Note that ignoring encoding errors can lead to data loss.)\n    See the documentation for codecs.register or run 'help(codecs.Codec)'\n    for a list of the permitted encoding error strings.\n\n    newline controls how universal newlines works (it only applies to text\n    mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\n    follows:\n\n    * On input, if newline is None, universal newlines mode is\n      enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n      these are translated into '\\n' before being returned to the\n      caller. If it is '', universal newline mode is enabled, but line\n      endings are returned to the caller untranslated. If it has any of\n      the other legal values, input lines are only terminated by the given\n      string, and the line ending is returned to the caller untranslated.\n\n    * On output, if newline is None, any '\\n' characters written are\n      translated to the system default line separator, os.linesep. If\n      newline is '' or '\\n', no translation takes place. If newline is any\n      of the other legal values, any '\\n' characters written are translated\n      to the given string.\n\n    If closefd is False, the underlying file descriptor will be kept open\n    when the file is closed. This does not work when a file name is given\n    and must be True in that case.\n\n    A custom opener can be used by passing a callable as *opener*. The\n    underlying file descriptor for the file object is then obtained by\n    calling *opener* with (*file*, *flags*). *opener* must return an open\n    file descriptor (passing os.open as *opener* results in functionality\n    similar to passing None).\n\n    open() returns a file object whose type depends on the mode, and\n    through which the standard file operations such as reading and writing\n    are performed. When open() is used to open a file in a text mode ('w',\n    'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\n    a file in a binary mode, the returned class varies: in read binary\n    mode, it returns a BufferedReader; in write binary and append binary\n    modes, it returns a BufferedWriter, and in read/write mode, it returns\n    a BufferedRandom.\n\n    It is also possible to use a string or bytearray as a file for both\n    reading and writing. For strings StringIO can be used like a file\n    opened in a text mode, and for bytes a BytesIO can be used like a file\n    opened in a binary mode.",
        "syntax": "Syntax: open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
        "other-params": ""
    },
    "io.open_code": {
        "function": "open_code(path)",
        "alias": "open_code",
        "help": "Help on built-in function open_code in module _io:\n\nopen_code(path)\n    Opens the provided file with the intent to import the contents.\n\n    This may perform extra validation beyond open(), but is otherwise interchangeable\n    with calling open(path, 'rb').",
        "syntax": "Syntax: open_code(path)",
        "other-params": ""
    },
    "io.text_encoding": {
        "function": "text_encoding(encoding, stacklevel=2, /)",
        "alias": "text_encoding",
        "help": "Help on built-in function text_encoding in module _io:\n\ntext_encoding(encoding, stacklevel=2, /)\n    A helper function to choose the text encoding.\n\n    When encoding is not None, this function returns it.\n    Otherwise, this function returns the default text encoding\n    (i.e. \"locale\" or \"utf-8\" depends on UTF-8 mode).\n\n    This function emits an EncodingWarning if encoding is None and\n    sys.flags.warn_default_encoding is true.\n\n    This can be used in APIs with an encoding=None parameter.\n    However, please consider using encoding=\"utf-8\" for new APIs.",
        "syntax": "Syntax: text_encoding(encoding, stacklevel=2, /)",
        "other-params": ""
    },
    "stat.S_IFMT": {
        "function": "S_IFMT(object, /)",
        "alias": "S_IFMT",
        "help": "Help on built-in function S_IFMT in module _stat:\n\nS_IFMT(object, /)\n    Return the portion of the file's mode that describes the file type.",
        "syntax": "Syntax: S_IFMT(object, /)",
        "other-params": ""
    },
    "stat.S_IMODE": {
        "function": "S_IMODE(object, /)",
        "alias": "S_IMODE",
        "help": "Help on built-in function S_IMODE in module _stat:\n\nS_IMODE(object, /)\n    Return the portion of the file's mode that can be set by os.chmod().",
        "syntax": "Syntax: S_IMODE(object, /)",
        "other-params": ""
    },
    "stat.S_ISBLK": {
        "function": "S_ISBLK(object, /)",
        "alias": "S_ISBLK",
        "help": "Help on built-in function S_ISBLK in module _stat:\n\nS_ISBLK(object, /)\n    S_ISBLK(mode) -> bool\n\n    Return True if mode is from a block special device file.",
        "syntax": "Syntax: S_ISBLK(object, /)",
        "other-params": ""
    },
    "stat.S_ISCHR": {
        "function": "S_ISCHR(object, /)",
        "alias": "S_ISCHR",
        "help": "Help on built-in function S_ISCHR in module _stat:\n\nS_ISCHR(object, /)\n    S_ISCHR(mode) -> bool\n\n    Return True if mode is from a character special device file.",
        "syntax": "Syntax: S_ISCHR(object, /)",
        "other-params": ""
    },
    "stat.S_ISDIR": {
        "function": "S_ISDIR(object, /)",
        "alias": "S_ISDIR",
        "help": "Help on built-in function S_ISDIR in module _stat:\n\nS_ISDIR(object, /)\n    S_ISDIR(mode) -> bool\n\n    Return True if mode is from a directory.",
        "syntax": "Syntax: S_ISDIR(object, /)",
        "other-params": ""
    },
    "stat.S_ISDOOR": {
        "function": "S_ISDOOR(object, /)",
        "alias": "S_ISDOOR",
        "help": "Help on built-in function S_ISDOOR in module _stat:\n\nS_ISDOOR(object, /)\n    S_ISDOOR(mode) -> bool\n\n    Return True if mode is from a door.",
        "syntax": "Syntax: S_ISDOOR(object, /)",
        "other-params": ""
    },
    "stat.S_ISFIFO": {
        "function": "S_ISFIFO(object, /)",
        "alias": "S_ISFIFO",
        "help": "Help on built-in function S_ISFIFO in module _stat:\n\nS_ISFIFO(object, /)\n    S_ISFIFO(mode) -> bool\n\n    Return True if mode is from a FIFO (named pipe).",
        "syntax": "Syntax: S_ISFIFO(object, /)",
        "other-params": ""
    },
    "stat.S_ISLNK": {
        "function": "S_ISLNK(object, /)",
        "alias": "S_ISLNK",
        "help": "Help on built-in function S_ISLNK in module _stat:\n\nS_ISLNK(object, /)\n    S_ISLNK(mode) -> bool\n\n    Return True if mode is from a symbolic link.",
        "syntax": "Syntax: S_ISLNK(object, /)",
        "other-params": ""
    },
    "stat.S_ISPORT": {
        "function": "S_ISPORT(object, /)",
        "alias": "S_ISPORT",
        "help": "Help on built-in function S_ISPORT in module _stat:\n\nS_ISPORT(object, /)\n    S_ISPORT(mode) -> bool\n\n    Return True if mode is from an event port.",
        "syntax": "Syntax: S_ISPORT(object, /)",
        "other-params": ""
    },
    "stat.S_ISREG": {
        "function": "S_ISREG(object, /)",
        "alias": "S_ISREG",
        "help": "Help on built-in function S_ISREG in module _stat:\n\nS_ISREG(object, /)\n    S_ISREG(mode) -> bool\n\n    Return True if mode is from a regular file.",
        "syntax": "Syntax: S_ISREG(object, /)",
        "other-params": ""
    },
    "stat.S_ISSOCK": {
        "function": "S_ISSOCK(object, /)",
        "alias": "S_ISSOCK",
        "help": "Help on built-in function S_ISSOCK in module _stat:\n\nS_ISSOCK(object, /)\n    S_ISSOCK(mode) -> bool\n\n    Return True if mode is from a socket.",
        "syntax": "Syntax: S_ISSOCK(object, /)",
        "other-params": ""
    },
    "stat.S_ISWHT": {
        "function": "S_ISWHT(object, /)",
        "alias": "S_ISWHT",
        "help": "Help on built-in function S_ISWHT in module _stat:\n\nS_ISWHT(object, /)\n    S_ISWHT(mode) -> bool\n\n    Return True if mode is from a whiteout.",
        "syntax": "Syntax: S_ISWHT(object, /)",
        "other-params": ""
    },
    "stat.filemode": {
        "function": "filemode(object, /)",
        "alias": "filemode",
        "help": "Help on built-in function filemode in module _stat:\n\nfilemode(object, /)\n    Convert a file's mode to a string of the form '-rwxrwxrwx'",
        "syntax": "Syntax: filemode(object, /)",
        "other-params": ""
    },
    "_collections_abc.ABCMeta": {
        "function": "ABCMeta(name, bases, namespace, /, **kwargs)",
        "alias": "ABCMeta",
        "help": "Help on class ABCMeta in module abc:\n\nclass ABCMeta(builtins.type)\n |  ABCMeta(name, bases, namespace, /, **kwargs)\n |\n |  Metaclass for defining Abstract Base Classes (ABCs).\n |\n |  Use this metaclass to create an ABC.  An ABC can be subclassed\n |  directly, and then acts as a mix-in class.  You can also register\n |  unrelated concrete classes (even built-in classes) and unrelated\n |  ABCs as 'virtual subclasses' -- these and their descendants will\n |  be considered subclasses of the registering ABC by the built-in\n |  issubclass() function, but the registering ABC won't show up in\n |  their MRO (Method Resolution Order) nor will method\n |  implementations defined by the registering ABC be callable (not\n |  even via super()).\n |\n |  Method resolution order:\n |      ABCMeta\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __instancecheck__(cls, instance)\n |      Override for isinstance(instance, cls).\n |\n |  __subclasscheck__(cls, subclass)\n |      Override for issubclass(subclass, cls).\n |\n |  register(cls, subclass)\n |      Register a virtual subclass of an ABC.\n |\n |      Returns the subclass, to allow usage as a class decorator.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(mcls, name, bases, namespace, /, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __dir__(self, /)\n |      Specialized __dir__ implementation for types.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.type:\n |\n |  __prepare__(name, bases, /, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'type'>\n |      type(object) -> the object's type\n |      type(name, bases, dict, **kwds) -> a new type\n |\n |\n |  __bases__ = (<class 'type'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155896320\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: ABCMeta(name, bases, namespace, /, **kwargs)",
        "other-params": ""
    },
    "_collections_abc.AsyncGenerator": {
        "function": "AsyncGenerator()",
        "alias": "AsyncGenerator",
        "help": "Help on class AsyncGenerator in module collections.abc:\n\nclass AsyncGenerator(AsyncIterator)\n |  Method resolution order:\n |      AsyncGenerator\n |      AsyncIterator\n |      AsyncIterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __anext__(self)\n |      Return the next item from the asynchronous generator.\n |      When exhausted, raise StopAsyncIteration.\n |\n |  async aclose(self)\n |      Raise GeneratorExit inside coroutine.\n |\n |  async asend(self, value)\n |      Send a value into the asynchronous generator.\n |      Return next yielded value or raise StopAsyncIteration.\n |\n |  async athrow(self, typ, val=None, tb=None)\n |      Raise an exception in the asynchronous generator.\n |      Return next yielded value or raise StopAsyncIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'asend', 'athrow'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from AsyncIterator:\n |\n |  __aiter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AsyncIterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: AsyncGenerator()",
        "other-params": ""
    },
    "_collections_abc.AsyncIterable": {
        "function": "AsyncIterable()",
        "alias": "AsyncIterable",
        "help": "Help on class AsyncIterable in module collections.abc:\n\nclass AsyncIterable(builtins.object)\n |  Methods defined here:\n |\n |  __aiter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__aiter__'})",
        "syntax": "Syntax: AsyncIterable()",
        "other-params": ""
    },
    "_collections_abc.AsyncIterator": {
        "function": "AsyncIterator()",
        "alias": "AsyncIterator",
        "help": "Help on class AsyncIterator in module collections.abc:\n\nclass AsyncIterator(AsyncIterable)\n |  Method resolution order:\n |      AsyncIterator\n |      AsyncIterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __aiter__(self)\n |\n |  async __anext__(self)\n |      Return the next item or raise StopAsyncIteration when exhausted.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__anext__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AsyncIterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: AsyncIterator()",
        "other-params": ""
    },
    "_collections_abc.Awaitable": {
        "function": "Awaitable()",
        "alias": "Awaitable",
        "help": "Help on class Awaitable in module collections.abc:\n\nclass Awaitable(builtins.object)\n |  Methods defined here:\n |\n |  __await__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__await__'})",
        "syntax": "Syntax: Awaitable()",
        "other-params": ""
    },
    "_collections_abc.Buffer": {
        "function": "Buffer()",
        "alias": "Buffer",
        "help": "Help on class Buffer in module collections.abc:\n\nclass Buffer(builtins.object)\n |  Methods defined here:\n |\n |  __buffer__(self, flags: int, /) -> memoryview\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__buffer__'})",
        "syntax": "Syntax: Buffer()",
        "other-params": ""
    },
    "_collections_abc.ByteString": {
        "function": "ByteString()",
        "alias": "ByteString",
        "help": "Help on class ByteString in module collections.abc:\n\nclass ByteString(Sequence)\n |  This unifies bytes and bytearray.\n |\n |  XXX Should add all their methods.\n |\n |  Method resolution order:\n |      ByteString\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__len__'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sequence:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: ByteString()",
        "other-params": ""
    },
    "_collections_abc.Callable": {
        "function": "Callable()",
        "alias": "Callable",
        "help": "Help on class Callable in module collections.abc:\n\nclass Callable(builtins.object)\n |  Methods defined here:\n |\n |  __call__(self, *args, **kwds)\n |      Call self as a function.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = _CallableGenericAlias(args)\n |      Represent `Callable[argtypes, resulttype]`.\n |\n |      This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n |      followed by ``resulttype``.\n |\n |      Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n |      ``(int, str, float)``.\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__call__'})",
        "syntax": "Syntax: Callable()",
        "other-params": ""
    },
    "_collections_abc.Collection": {
        "function": "Collection()",
        "alias": "Collection",
        "help": "Help on class Collection in module collections.abc:\n\nclass Collection(Sized, Iterable, Container)\n |  Method resolution order:\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: Collection()",
        "other-params": ""
    },
    "_collections_abc.Container": {
        "function": "Container()",
        "alias": "Container",
        "help": "Help on class Container in module collections.abc:\n\nclass Container(builtins.object)\n |  Methods defined here:\n |\n |  __contains__(self, x)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__'})",
        "syntax": "Syntax: Container()",
        "other-params": ""
    },
    "_collections_abc.Coroutine": {
        "function": "Coroutine()",
        "alias": "Coroutine",
        "help": "Help on class Coroutine in module collections.abc:\n\nclass Coroutine(Awaitable)\n |  Method resolution order:\n |      Coroutine\n |      Awaitable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  close(self)\n |      Raise GeneratorExit inside coroutine.\n |\n |  send(self, value)\n |      Send a value into the coroutine.\n |      Return next yielded value or raise StopIteration.\n |\n |  throw(self, typ, val=None, tb=None)\n |      Raise an exception in the coroutine.\n |      Return next yielded value or raise StopIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__await__', 'send', 'throw'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Awaitable:\n |\n |  __await__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Awaitable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Coroutine()",
        "other-params": ""
    },
    "_collections_abc.EllipsisType": {
        "function": "EllipsisType()",
        "alias": "EllipsisType",
        "help": "Help on class ellipsis in module builtins:\n\nclass ellipsis(object)\n |  The type of the Ellipsis singleton.\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: EllipsisType()",
        "other-params": ""
    },
    "_collections_abc.FunctionType": {
        "function": "FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "alias": "FunctionType",
        "help": "Help on class function in module builtins:\n\nclass function(object)\n |  function(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)\n |\n |  Create a function object.\n |\n |  code\n |    a code object\n |  globals\n |    the globals dictionary\n |  name\n |    a string that overrides the name from the code object\n |  argdefs\n |    a tuple that specifies the default argument values\n |  closure\n |    a tuple that supplies the bindings for free variables\n |  kwdefaults\n |    a dictionary that specifies the default keyword argument values\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __closure__\n |\n |  __code__\n |\n |  __defaults__\n |\n |  __dict__\n |\n |  __globals__\n |\n |  __kwdefaults__\n |\n |  __type_params__",
        "syntax": "Syntax: FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "other-params": ""
    },
    "_collections_abc.Generator": {
        "function": "Generator()",
        "alias": "Generator",
        "help": "Help on class Generator in module collections.abc:\n\nclass Generator(Iterator)\n |  Method resolution order:\n |      Generator\n |      Iterator\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __next__(self)\n |      Return the next item from the generator.\n |      When exhausted, raise StopIteration.\n |\n |  close(self)\n |      Raise GeneratorExit inside generator.\n |\n |  send(self, value)\n |      Send a value into the generator.\n |      Return next yielded value or raise StopIteration.\n |\n |  throw(self, typ, val=None, tb=None)\n |      Raise an exception in the generator.\n |      Return next yielded value or raise StopIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'send', 'throw'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterator:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Generator()",
        "other-params": ""
    },
    "_collections_abc.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "_collections_abc.Hashable": {
        "function": "Hashable()",
        "alias": "Hashable",
        "help": "Help on class Hashable in module collections.abc:\n\nclass Hashable(builtins.object)\n |  Methods defined here:\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__hash__'})",
        "syntax": "Syntax: Hashable()",
        "other-params": ""
    },
    "_collections_abc.ItemsView": {
        "function": "ItemsView(mapping)",
        "alias": "ItemsView",
        "help": "Help on class ItemsView in module collections.abc:\n\nclass ItemsView(MappingView, Set)\n |  ItemsView(mapping)\n |\n |  Method resolution order:\n |      ItemsView\n |      MappingView\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, item)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: ItemsView(mapping)",
        "other-params": ""
    },
    "_collections_abc.Iterable": {
        "function": "Iterable()",
        "alias": "Iterable",
        "help": "Help on class Iterable in module collections.abc:\n\nclass Iterable(builtins.object)\n |  Methods defined here:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__iter__'})",
        "syntax": "Syntax: Iterable()",
        "other-params": ""
    },
    "_collections_abc.Iterator": {
        "function": "Iterator()",
        "alias": "Iterator",
        "help": "Help on class Iterator in module collections.abc:\n\nclass Iterator(Iterable)\n |  Method resolution order:\n |      Iterator\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next item from the iterator. When exhausted, raise StopIteration\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__next__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Iterator()",
        "other-params": ""
    },
    "_collections_abc.KeysView": {
        "function": "KeysView(mapping)",
        "alias": "KeysView",
        "help": "Help on class KeysView in module collections.abc:\n\nclass KeysView(MappingView, Set)\n |  KeysView(mapping)\n |\n |  Method resolution order:\n |      KeysView\n |      MappingView\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: KeysView(mapping)",
        "other-params": ""
    },
    "_collections_abc.Mapping": {
        "function": "Mapping()",
        "alias": "Mapping",
        "help": "Help on class Mapping in module collections.abc:\n\nclass Mapping(Collection)\n |  A Mapping is a generic container for associating key/value\n |  pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __iter__, and __len__.\n |\n |  Method resolution order:\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__iter__', '__len__'}...\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Mapping()",
        "other-params": ""
    },
    "_collections_abc.MappingView": {
        "function": "MappingView(mapping)",
        "alias": "MappingView",
        "help": "Help on class MappingView in module collections.abc:\n\nclass MappingView(Sized)\n |  MappingView(mapping)\n |\n |  Method resolution order:\n |      MappingView\n |      Sized\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Sized:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: MappingView(mapping)",
        "other-params": ""
    },
    "_collections_abc.MutableMapping": {
        "function": "MutableMapping()",
        "alias": "MutableMapping",
        "help": "Help on class MutableMapping in module collections.abc:\n\nclass MutableMapping(Mapping)\n |  A MutableMapping is a generic container for associating\n |  key/value pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __setitem__, __delitem__,\n |  __iter__, and __len__.\n |\n |  Method resolution order:\n |      MutableMapping\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, key)\n |\n |  __setitem__(self, key, value)\n |\n |  clear(self)\n |      D.clear() -> None.  Remove all items from D.\n |\n |  pop(self, key, default=<object object at 0x000001950D090200>)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised.\n |\n |  popitem(self)\n |      D.popitem() -> (k, v), remove and return some (key, value) pair\n |      as a 2-tuple; but raise KeyError if D is empty.\n |\n |  setdefault(self, key, default=None)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__delitem__', '__getitem__', '__iter...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Mapping:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: MutableMapping()",
        "other-params": ""
    },
    "_collections_abc.MutableSequence": {
        "function": "MutableSequence()",
        "alias": "MutableSequence",
        "help": "Help on class MutableSequence in module collections.abc:\n\nclass MutableSequence(Sequence)\n |  All the operations on a read-write sequence.\n |\n |  Concrete subclasses must provide __new__ or __init__,\n |  __getitem__, __setitem__, __delitem__, __len__, and insert().\n |\n |  Method resolution order:\n |      MutableSequence\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, index)\n |\n |  __iadd__(self, values)\n |\n |  __setitem__(self, index, value)\n |\n |  append(self, value)\n |      S.append(value) -- append value to the end of the sequence\n |\n |  clear(self)\n |      S.clear() -> None -- remove all items from S\n |\n |  extend(self, values)\n |      S.extend(iterable) -- extend sequence by appending elements from the iterable\n |\n |  insert(self, index, value)\n |      S.insert(index, value) -- insert value before index\n |\n |  pop(self, index=-1)\n |      S.pop([index]) -> item -- remove and return item at index (default last).\n |      Raise IndexError if list is empty or index is out of range.\n |\n |  remove(self, value)\n |      S.remove(value) -- remove first occurrence of value.\n |      Raise ValueError if the value is not present.\n |\n |  reverse(self)\n |      S.reverse() -- reverse *IN PLACE*\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__delitem__', '__getitem__', '__len_...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sequence:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: MutableSequence()",
        "other-params": ""
    },
    "_collections_abc.MutableSet": {
        "function": "MutableSet()",
        "alias": "MutableSet",
        "help": "Help on class MutableSet in module collections.abc:\n\nclass MutableSet(Set)\n |  A mutable set is a finite, iterable container.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __contains__, __iter__, __len__,\n |  add(), and discard().\n |\n |  To override the comparisons (presumably for speed, as the\n |  semantics are fixed), all you have to do is redefine __le__ and\n |  then the other operations will automatically follow suit.\n |\n |  Method resolution order:\n |      MutableSet\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __iand__(self, it)\n |\n |  __ior__(self, it)\n |\n |  __isub__(self, it)\n |\n |  __ixor__(self, it)\n |\n |  add(self, value)\n |      Add an element.\n |\n |  clear(self)\n |      This is slow (creates N new iterators!) but effective.\n |\n |  discard(self, value)\n |      Remove an element.  Do not raise an exception if absent.\n |\n |  pop(self)\n |      Return the popped value.  Raise KeyError if empty.\n |\n |  remove(self, value)\n |      Remove an element. If not a member, raise a KeyError.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: MutableSet()",
        "other-params": ""
    },
    "_collections_abc.Reversible": {
        "function": "Reversible()",
        "alias": "Reversible",
        "help": "Help on class Reversible in module collections.abc:\n\nclass Reversible(Iterable)\n |  Method resolution order:\n |      Reversible\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__iter__', '__reversed__'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Reversible()",
        "other-params": ""
    },
    "_collections_abc.Sequence": {
        "function": "Sequence()",
        "alias": "Sequence",
        "help": "Help on class Sequence in module collections.abc:\n\nclass Sequence(Reversible, Collection)\n |  All the operations on a read-only sequence.\n |\n |  Concrete subclasses must override __new__ or __init__,\n |  __getitem__, and __len__.\n |\n |  Method resolution order:\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__len__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Sequence()",
        "other-params": ""
    },
    "_collections_abc.Set": {
        "function": "Set()",
        "alias": "Set",
        "help": "Help on class Set in module collections.abc:\n\nclass Set(Collection)\n |  A set is a finite, iterable container.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __contains__, __iter__ and __len__.\n |\n |  To override the comparisons (presumably for speed, as the\n |  semantics are fixed), redefine __le__ and __ge__,\n |  then the other operations will automatically follow suit.\n |\n |  Method resolution order:\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: Set()",
        "other-params": ""
    },
    "_collections_abc.Sized": {
        "function": "Sized()",
        "alias": "Sized",
        "help": "Help on class Sized in module collections.abc:\n\nclass Sized(builtins.object)\n |  Methods defined here:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__len__'})",
        "syntax": "Syntax: Sized()",
        "other-params": ""
    },
    "_collections_abc.ValuesView": {
        "function": "ValuesView(mapping)",
        "alias": "ValuesView",
        "help": "Help on class ValuesView in module collections.abc:\n\nclass ValuesView(MappingView, Collection)\n |  ValuesView(mapping)\n |\n |  Method resolution order:\n |      ValuesView\n |      MappingView\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, value)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: ValuesView(mapping)",
        "other-params": ""
    },
    "_collections_abc._CallableGenericAlias": {
        "function": "_CallableGenericAlias(origin, args)",
        "alias": "_CallableGenericAlias",
        "help": "Help on class _CallableGenericAlias in module collections.abc:\n\nclass _CallableGenericAlias(types.GenericAlias)\n |  _CallableGenericAlias(origin, args)\n |\n |  Represent `Callable[argtypes, resulttype]`.\n |\n |  This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n |  followed by ``resulttype``.\n |\n |  Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n |  ``(int, str, float)``.\n |\n |  Method resolution order:\n |      _CallableGenericAlias\n |      types.GenericAlias\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getitem__(self, item)\n |      Return self[key].\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, origin, args)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from types.GenericAlias:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from types.GenericAlias:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: _CallableGenericAlias(origin, args)",
        "other-params": ""
    },
    "_collections_abc._DeprecateByteStringMeta": {
        "function": "_DeprecateByteStringMeta(name, bases, namespace, **kwargs)",
        "alias": "_DeprecateByteStringMeta",
        "help": "Help on class _DeprecateByteStringMeta in module collections.abc:\n\nclass _DeprecateByteStringMeta(abc.ABCMeta)\n |  _DeprecateByteStringMeta(name, bases, namespace, **kwargs)\n |\n |  Method resolution order:\n |      _DeprecateByteStringMeta\n |      abc.ABCMeta\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __instancecheck__(cls, instance)\n |      Override for isinstance(instance, cls).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, name, bases, namespace, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from abc.ABCMeta:\n |\n |  __subclasscheck__(cls, subclass)\n |      Override for issubclass(subclass, cls).\n |\n |  register(cls, subclass)\n |      Register a virtual subclass of an ABC.\n |\n |      Returns the subclass, to allow usage as a class decorator.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __dir__(self, /)\n |      Specialized __dir__ implementation for types.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.type:\n |\n |  __prepare__(name, bases, /, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'abc.ABCMeta'>\n |      Metaclass for defining Abstract Base Classes (ABCs).\n |\n |      Use this metaclass to create an ABC.  An ABC can be subclassed\n |      directly, and then acts as a mix-in class.  You can also register\n |      unrelated concrete classes (even built-in classes) and unrelated\n |      ABCs as 'virtual subclasses' -- these and their descendants will\n |      be considered subclasses of the registering ABC by the built-in\n |      issubclass() function, but the registering ABC won't show up in\n |      their MRO (Method Resolution Order) nor will method\n |      implementations defined by the registering ABC be callable (not\n |      even via super()).\n |\n |\n |  __bases__ = (<class 'abc.ABCMeta'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155896320\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'collections.abc._DeprecateByteStringMeta'>, <class ...\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: _DeprecateByteStringMeta(name, bases, namespace, **kwargs)",
        "other-params": ""
    },
    "_collections_abc._check_methods": {
        "function": "_check_methods(C, *methods)",
        "alias": "_check_methods",
        "help": "Help on function _check_methods in module collections.abc:\n\n_check_methods(C, *methods)",
        "syntax": "Syntax: _check_methods(C, *methods)",
        "other-params": ""
    },
    "_collections_abc._is_param_expr": {
        "function": "_is_param_expr(obj)",
        "alias": "_is_param_expr",
        "help": "Help on function _is_param_expr in module collections.abc:\n\n_is_param_expr(obj)\n    Checks if obj matches either a list of types, ``...``, ``ParamSpec`` or\n    ``_ConcatenateGenericAlias`` from typing.py",
        "syntax": "Syntax: _is_param_expr(obj)",
        "other-params": ""
    },
    "_collections_abc._type_repr": {
        "function": "_type_repr(obj)",
        "alias": "_type_repr",
        "help": "Help on function _type_repr in module collections.abc:\n\n_type_repr(obj)\n    Return the repr() of an object, special-casing types (internal helper).\n\n    Copied from :mod:`typing` since collections.abc\n    shouldn't depend on that module.\n    (Keep this roughly in sync with the typing version.)",
        "syntax": "Syntax: _type_repr(obj)",
        "other-params": ""
    },
    "_collections_abc.abstractmethod": {
        "function": "abstractmethod(funcobj)",
        "alias": "abstractmethod",
        "help": "Help on function abstractmethod in module abc:\n\nabstractmethod(funcobj)\n    A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...",
        "syntax": "Syntax: abstractmethod(funcobj)",
        "other-params": ""
    },
    "_collections_abc.async_generator": {
        "function": "async_generator()",
        "alias": "async_generator",
        "help": "Help on class async_generator in module builtins:\n\nclass async_generator(object)\n |  Methods defined here:\n |\n |  __aiter__(self, /)\n |      Return an awaitable, that resolves in asynchronous iterator.\n |\n |  __anext__(self, /)\n |      Return a value or raise StopAsyncIteration.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  aclose(self, /)\n |      aclose() -> raise GeneratorExit inside generator.\n |\n |  asend(self, object, /)\n |      asend(v) -> send 'v' in generator.\n |\n |  athrow(...)\n |      athrow(value)\n |      athrow(type[,value[,tb]])\n |\n |      raise exception in generator.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  ag_await\n |      object being awaited on, or None\n |\n |  ag_code\n |\n |  ag_frame\n |\n |  ag_running\n |\n |  ag_suspended",
        "syntax": "Syntax: async_generator()",
        "other-params": ""
    },
    "_collections_abc.bytearray_iterator": {
        "function": "bytearray_iterator()",
        "alias": "bytearray_iterator",
        "help": "Help on class bytearray_iterator in module builtins:\n\nclass bytearray_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: bytearray_iterator()",
        "other-params": ""
    },
    "_collections_abc.bytes_iterator": {
        "function": "bytes_iterator()",
        "alias": "bytes_iterator",
        "help": "Help on class bytes_iterator in module builtins:\n\nclass bytes_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: bytes_iterator()",
        "other-params": ""
    },
    "_collections_abc.coroutine": {
        "function": "coroutine()",
        "alias": "coroutine",
        "help": "Help on class coroutine in module builtins:\n\nclass coroutine(object)\n |  Methods defined here:\n |\n |  __await__(self, /)\n |      Return an iterator to be used in await expression.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside coroutine.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into coroutine,\n |      return next iterated value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,traceback]])\n |\n |      Raise exception in coroutine, return next iterated value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  cr_await\n |      object being awaited on, or None\n |\n |  cr_code\n |\n |  cr_frame\n |\n |  cr_origin\n |\n |  cr_running\n |\n |  cr_suspended",
        "syntax": "Syntax: coroutine()",
        "other-params": ""
    },
    "_collections_abc.dict_itemiterator": {
        "function": "dict_itemiterator()",
        "alias": "dict_itemiterator",
        "help": "Help on class dict_itemiterator in module builtins:\n\nclass dict_itemiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_itemiterator()",
        "other-params": ""
    },
    "_collections_abc.dict_items": {
        "function": "dict_items()",
        "alias": "dict_items",
        "help": "Help on class dict_items in module builtins:\n\nclass dict_items(object)\n |  Built-in subclasses:\n |      odict_items\n |\n |  Methods defined here:\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict items.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  isdisjoint(self, object, /)\n |      Return True if the view and the given iterable have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: dict_items()",
        "other-params": ""
    },
    "_collections_abc.dict_keyiterator": {
        "function": "dict_keyiterator()",
        "alias": "dict_keyiterator",
        "help": "Help on class dict_keyiterator in module builtins:\n\nclass dict_keyiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_keyiterator()",
        "other-params": ""
    },
    "_collections_abc.dict_keys": {
        "function": "dict_keys()",
        "alias": "dict_keys",
        "help": "Help on class dict_keys in module builtins:\n\nclass dict_keys(object)\n |  Built-in subclasses:\n |      odict_keys\n |\n |  Methods defined here:\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  isdisjoint(self, object, /)\n |      Return True if the view and the given iterable have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: dict_keys()",
        "other-params": ""
    },
    "_collections_abc.dict_valueiterator": {
        "function": "dict_valueiterator()",
        "alias": "dict_valueiterator",
        "help": "Help on class dict_valueiterator in module builtins:\n\nclass dict_valueiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_valueiterator()",
        "other-params": ""
    },
    "_collections_abc.dict_values": {
        "function": "dict_values()",
        "alias": "dict_values",
        "help": "Help on class dict_values in module builtins:\n\nclass dict_values(object)\n |  Built-in subclasses:\n |      odict_values\n |\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict values.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to",
        "syntax": "Syntax: dict_values()",
        "other-params": ""
    },
    "_collections_abc.framelocalsproxy": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'FrameLocalsProxy'>",
        "alias": "framelocalsproxy",
        "help": "Help on class FrameLocalsProxy in module builtins:\n\nclass FrameLocalsProxy(object)\n |  Methods defined here:\n |\n |  __contains__(self, object, /)\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, object, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  copy(self, /)\n |\n |  get(...)\n |\n |  items(self, /)\n |\n |  keys(self, /)\n |\n |  pop(...)\n |\n |  setdefault(...)\n |\n |  update(self, object, /)\n |\n |  values(self, /)\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'FrameLocalsProxy'>",
        "other-params": ""
    },
    "_collections_abc.generator": {
        "function": "generator()",
        "alias": "generator",
        "help": "Help on class generator in module builtins:\n\nclass generator(object)\n |  Methods defined here:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside generator.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into generator,\n |      return next yielded value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,tb]])\n |\n |      Raise exception in generator, return next yielded value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  gi_code\n |\n |  gi_frame\n |\n |  gi_running\n |\n |  gi_suspended\n |\n |  gi_yieldfrom\n |      object being iterated by yield from, or None",
        "syntax": "Syntax: generator()",
        "other-params": ""
    },
    "_collections_abc.list_iterator": {
        "function": "list_iterator()",
        "alias": "list_iterator",
        "help": "Help on class list_iterator in module builtins:\n\nclass list_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: list_iterator()",
        "other-params": ""
    },
    "_collections_abc.list_reverseiterator": {
        "function": "list_reverseiterator()",
        "alias": "list_reverseiterator",
        "help": "Help on class list_reverseiterator in module builtins:\n\nclass list_reverseiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: list_reverseiterator()",
        "other-params": ""
    },
    "_collections_abc.longrange_iterator": {
        "function": "longrange_iterator()",
        "alias": "longrange_iterator",
        "help": "Help on class longrange_iterator in module builtins:\n\nclass longrange_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: longrange_iterator()",
        "other-params": ""
    },
    "_collections_abc.mappingproxy": {
        "function": "mappingproxy(mapping)",
        "alias": "mappingproxy",
        "help": "Help on class mappingproxy in module builtins:\n\nclass mappingproxy(object)\n |  mappingproxy(mapping)\n |\n |  Read-only proxy of a mapping.\n |\n |  Methods defined here:\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      D.__reversed__() -> reverse iterator\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  copy(self, /)\n |      D.copy() -> a shallow copy of D\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the mapping, else default.\n |\n |  items(self, /)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self, /)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self, /)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: mappingproxy(mapping)",
        "other-params": ""
    },
    "_collections_abc.range_iterator": {
        "function": "range_iterator()",
        "alias": "range_iterator",
        "help": "Help on class range_iterator in module builtins:\n\nclass range_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: range_iterator()",
        "other-params": ""
    },
    "_collections_abc.set_iterator": {
        "function": "set_iterator()",
        "alias": "set_iterator",
        "help": "Help on class set_iterator in module builtins:\n\nclass set_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: set_iterator()",
        "other-params": ""
    },
    "_collections_abc.str_iterator": {
        "function": "str_iterator()",
        "alias": "str_iterator",
        "help": "Help on class str_ascii_iterator in module builtins:\n\nclass str_ascii_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: str_iterator()",
        "other-params": ""
    },
    "_collections_abc.tuple_iterator": {
        "function": "tuple_iterator()",
        "alias": "tuple_iterator",
        "help": "Help on class tuple_iterator in module builtins:\n\nclass tuple_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: tuple_iterator()",
        "other-params": ""
    },
    "_collections_abc.zip_iterator": {
        "function": "zip_iterator(*iterables, strict=False)",
        "alias": "zip_iterator",
        "help": "Help on class zip in module builtins:\n\nclass zip(object)\n |  zip(*iterables, strict=False)\n |\n |  The zip object yields n-length tuples, where n is the number of iterables\n |  passed as positional arguments to zip().  The i-th element in every tuple\n |  comes from the i-th iterable argument to zip().  This continues until the\n |  shortest argument is exhausted.\n |\n |  If strict is true and one of the arguments is exhausted before the others,\n |  raise a ValueError.\n |\n |     >>> list(zip('abcdefg', range(3), range(4)))\n |     [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: zip_iterator(*iterables, strict=False)",
        "other-params": ""
    },
    "genericpath._check_arg_types": {
        "function": "_check_arg_types(funcname, *args)",
        "alias": "_check_arg_types",
        "help": "Help on function _check_arg_types in module genericpath:\n\n_check_arg_types(funcname, *args)",
        "syntax": "Syntax: _check_arg_types(funcname, *args)",
        "other-params": ""
    },
    "genericpath._splitext": {
        "function": "_splitext(p, sep, altsep, extsep)",
        "alias": "_splitext",
        "help": "Help on function _splitext in module genericpath:\n\n_splitext(p, sep, altsep, extsep)\n    Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.",
        "syntax": "Syntax: _splitext(p, sep, altsep, extsep)",
        "other-params": ""
    },
    "genericpath.commonprefix": {
        "function": "commonprefix(m)",
        "alias": "commonprefix",
        "help": "Help on function commonprefix in module genericpath:\n\ncommonprefix(m)\n    Given a list of pathnames, returns the longest common leading component",
        "syntax": "Syntax: commonprefix(m)",
        "other-params": ""
    },
    "genericpath.exists": {
        "function": "exists(path)",
        "alias": "exists",
        "help": "Help on function exists in module genericpath:\n\nexists(path)\n    Test whether a path exists.  Returns False for broken symbolic links",
        "syntax": "Syntax: exists(path)",
        "other-params": ""
    },
    "genericpath.getatime": {
        "function": "getatime(filename)",
        "alias": "getatime",
        "help": "Help on function getatime in module genericpath:\n\ngetatime(filename)\n    Return the last access time of a file, reported by os.stat().",
        "syntax": "Syntax: getatime(filename)",
        "other-params": ""
    },
    "genericpath.getctime": {
        "function": "getctime(filename)",
        "alias": "getctime",
        "help": "Help on function getctime in module genericpath:\n\ngetctime(filename)\n    Return the metadata change time of a file, reported by os.stat().",
        "syntax": "Syntax: getctime(filename)",
        "other-params": ""
    },
    "genericpath.getmtime": {
        "function": "getmtime(filename)",
        "alias": "getmtime",
        "help": "Help on function getmtime in module genericpath:\n\ngetmtime(filename)\n    Return the last modification time of a file, reported by os.stat().",
        "syntax": "Syntax: getmtime(filename)",
        "other-params": ""
    },
    "genericpath.getsize": {
        "function": "getsize(filename)",
        "alias": "getsize",
        "help": "Help on function getsize in module genericpath:\n\ngetsize(filename)\n    Return the size of a file, reported by os.stat().",
        "syntax": "Syntax: getsize(filename)",
        "other-params": ""
    },
    "genericpath.isdevdrive": {
        "function": "isdevdrive(path)",
        "alias": "isdevdrive",
        "help": "Help on function isdevdrive in module genericpath:\n\nisdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.\n    Dev Drives are not supported on the current platform",
        "syntax": "Syntax: isdevdrive(path)",
        "other-params": ""
    },
    "genericpath.isdir": {
        "function": "isdir(s)",
        "alias": "isdir",
        "help": "Help on function isdir in module genericpath:\n\nisdir(s)\n    Return true if the pathname refers to an existing directory.",
        "syntax": "Syntax: isdir(s)",
        "other-params": ""
    },
    "genericpath.isfile": {
        "function": "isfile(path)",
        "alias": "isfile",
        "help": "Help on function isfile in module genericpath:\n\nisfile(path)\n    Test whether a path is a regular file",
        "syntax": "Syntax: isfile(path)",
        "other-params": ""
    },
    "genericpath.isjunction": {
        "function": "isjunction(path)",
        "alias": "isjunction",
        "help": "Help on function isjunction in module genericpath:\n\nisjunction(path)\n    Test whether a path is a junction\n    Junctions are not supported on the current platform",
        "syntax": "Syntax: isjunction(path)",
        "other-params": ""
    },
    "genericpath.islink": {
        "function": "islink(path)",
        "alias": "islink",
        "help": "Help on function islink in module genericpath:\n\nislink(path)\n    Test whether a path is a symbolic link",
        "syntax": "Syntax: islink(path)",
        "other-params": ""
    },
    "genericpath.lexists": {
        "function": "lexists(path)",
        "alias": "lexists",
        "help": "Help on function lexists in module genericpath:\n\nlexists(path)\n    Test whether a path exists.  Returns True for broken symbolic links",
        "syntax": "Syntax: lexists(path)",
        "other-params": ""
    },
    "genericpath.samefile": {
        "function": "samefile(f1, f2)",
        "alias": "samefile",
        "help": "Help on function samefile in module genericpath:\n\nsamefile(f1, f2)\n    Test whether two pathnames reference the same actual file or directory\n\n    This is determined by the device number and i-node number and\n    raises an exception if an os.stat() call on either pathname fails.",
        "syntax": "Syntax: samefile(f1, f2)",
        "other-params": ""
    },
    "genericpath.sameopenfile": {
        "function": "sameopenfile(fp1, fp2)",
        "alias": "sameopenfile",
        "help": "Help on function sameopenfile in module genericpath:\n\nsameopenfile(fp1, fp2)\n    Test whether two open file objects reference the same file",
        "syntax": "Syntax: sameopenfile(fp1, fp2)",
        "other-params": ""
    },
    "genericpath.samestat": {
        "function": "samestat(s1, s2)",
        "alias": "samestat",
        "help": "Help on function samestat in module genericpath:\n\nsamestat(s1, s2)\n    Test whether two stat buffers reference the same file",
        "syntax": "Syntax: samestat(s1, s2)",
        "other-params": ""
    },
    "ntpath._LCMapStringEx": {
        "function": "_LCMapStringEx(locale, flags, src)",
        "alias": "_LCMapStringEx",
        "help": "Help on built-in function LCMapStringEx in module _winapi:\n\nLCMapStringEx(locale, flags, src)",
        "syntax": "Syntax: _LCMapStringEx(locale, flags, src)",
        "other-params": ""
    },
    "ntpath._findfirstfile": {
        "function": "_findfirstfile(path, /)",
        "alias": "_findfirstfile",
        "help": "Help on built-in function _findfirstfile in module nt:\n\n_findfirstfile(path, /)\n    A function to get the real file name without accessing the file in Windows.",
        "syntax": "Syntax: _findfirstfile(path, /)",
        "other-params": ""
    },
    "ntpath._get_bothseps": {
        "function": "_get_bothseps(path)",
        "alias": "_get_bothseps",
        "help": "Help on function _get_bothseps in module ntpath:\n\n_get_bothseps(path)",
        "syntax": "Syntax: _get_bothseps(path)",
        "other-params": ""
    },
    "ntpath._getfinalpathname": {
        "function": "_getfinalpathname(path, /)",
        "alias": "_getfinalpathname",
        "help": "Help on built-in function _getfinalpathname in module nt:\n\n_getfinalpathname(path, /)\n    A helper function for samepath on windows.",
        "syntax": "Syntax: _getfinalpathname(path, /)",
        "other-params": ""
    },
    "ntpath._getfinalpathname_nonstrict": {
        "function": "_getfinalpathname_nonstrict(path)",
        "alias": "_getfinalpathname_nonstrict",
        "help": "Help on function _getfinalpathname_nonstrict in module ntpath:\n\n_getfinalpathname_nonstrict(path)",
        "syntax": "Syntax: _getfinalpathname_nonstrict(path)",
        "other-params": ""
    },
    "ntpath._getfullpathname": {
        "function": "_getfullpathname(path, /)",
        "alias": "_getfullpathname",
        "help": "Help on built-in function _getfullpathname in module nt:\n\n_getfullpathname(path, /)",
        "syntax": "Syntax: _getfullpathname(path, /)",
        "other-params": ""
    },
    "ntpath._getvolumepathname": {
        "function": "_getvolumepathname(path)",
        "alias": "_getvolumepathname",
        "help": "Help on built-in function _getvolumepathname in module nt:\n\n_getvolumepathname(path)\n    A helper function for ismount on Win32.",
        "syntax": "Syntax: _getvolumepathname(path)",
        "other-params": ""
    },
    "ntpath._isreservedname": {
        "function": "_isreservedname(name)",
        "alias": "_isreservedname",
        "help": "Help on function _isreservedname in module ntpath:\n\n_isreservedname(name)\n    Return true if the filename is reserved by the system.",
        "syntax": "Syntax: _isreservedname(name)",
        "other-params": ""
    },
    "ntpath._nt_readlink": {
        "function": "_nt_readlink(path, *, dir_fd=None)",
        "alias": "_nt_readlink",
        "help": "Help on built-in function readlink in module nt:\n\nreadlink(path, *, dir_fd=None)\n    Return a string representing the path to which the symbolic link points.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that directory.\n\n    dir_fd may not be implemented on your platform.  If it is unavailable,\n    using it will raise a NotImplementedError.",
        "syntax": "Syntax: _nt_readlink(path, *, dir_fd=None)",
        "other-params": ""
    },
    "ntpath._path_isdevdrive": {
        "function": "_path_isdevdrive(path)",
        "alias": "_path_isdevdrive",
        "help": "Help on built-in function _path_isdevdrive in module nt:\n\n_path_isdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.",
        "syntax": "Syntax: _path_isdevdrive(path)",
        "other-params": ""
    },
    "ntpath._readlink_deep": {
        "function": "_readlink_deep(path)",
        "alias": "_readlink_deep",
        "help": "Help on function _readlink_deep in module ntpath:\n\n_readlink_deep(path)",
        "syntax": "Syntax: _readlink_deep(path)",
        "other-params": ""
    },
    "ntpath.abspath": {
        "function": "abspath(path)",
        "alias": "abspath",
        "help": "Help on function abspath in module ntpath:\n\nabspath(path)\n    Return the absolute version of a path.",
        "syntax": "Syntax: abspath(path)",
        "other-params": ""
    },
    "ntpath.basename": {
        "function": "basename(p)",
        "alias": "basename",
        "help": "Help on function basename in module ntpath:\n\nbasename(p)\n    Returns the final component of a pathname",
        "syntax": "Syntax: basename(p)",
        "other-params": ""
    },
    "ntpath.commonpath": {
        "function": "commonpath(paths)",
        "alias": "commonpath",
        "help": "Help on function commonpath in module ntpath:\n\ncommonpath(paths)\n    Given an iterable of path names, returns the longest common sub-path.",
        "syntax": "Syntax: commonpath(paths)",
        "other-params": ""
    },
    "ntpath.commonprefix": {
        "function": "commonprefix(m)",
        "alias": "commonprefix",
        "help": "Help on function commonprefix in module genericpath:\n\ncommonprefix(m)\n    Given a list of pathnames, returns the longest common leading component",
        "syntax": "Syntax: commonprefix(m)",
        "other-params": ""
    },
    "ntpath.dirname": {
        "function": "dirname(p)",
        "alias": "dirname",
        "help": "Help on function dirname in module ntpath:\n\ndirname(p)\n    Returns the directory component of a pathname",
        "syntax": "Syntax: dirname(p)",
        "other-params": ""
    },
    "ntpath.exists": {
        "function": "exists(path)",
        "alias": "exists",
        "help": "Help on built-in function _path_exists in module nt:\n\n_path_exists(path)\n    Test whether a path exists.  Returns False for broken symbolic links.",
        "syntax": "Syntax: exists(path)",
        "other-params": ""
    },
    "ntpath.expanduser": {
        "function": "expanduser(path)",
        "alias": "expanduser",
        "help": "Help on function expanduser in module ntpath:\n\nexpanduser(path)\n    Expand ~ and ~user constructs.\n\n    If user or $HOME is unknown, do nothing.",
        "syntax": "Syntax: expanduser(path)",
        "other-params": ""
    },
    "ntpath.expandvars": {
        "function": "expandvars(path)",
        "alias": "expandvars",
        "help": "Help on function expandvars in module ntpath:\n\nexpandvars(path)\n    Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.",
        "syntax": "Syntax: expandvars(path)",
        "other-params": ""
    },
    "ntpath.getatime": {
        "function": "getatime(filename)",
        "alias": "getatime",
        "help": "Help on function getatime in module genericpath:\n\ngetatime(filename)\n    Return the last access time of a file, reported by os.stat().",
        "syntax": "Syntax: getatime(filename)",
        "other-params": ""
    },
    "ntpath.getctime": {
        "function": "getctime(filename)",
        "alias": "getctime",
        "help": "Help on function getctime in module genericpath:\n\ngetctime(filename)\n    Return the metadata change time of a file, reported by os.stat().",
        "syntax": "Syntax: getctime(filename)",
        "other-params": ""
    },
    "ntpath.getmtime": {
        "function": "getmtime(filename)",
        "alias": "getmtime",
        "help": "Help on function getmtime in module genericpath:\n\ngetmtime(filename)\n    Return the last modification time of a file, reported by os.stat().",
        "syntax": "Syntax: getmtime(filename)",
        "other-params": ""
    },
    "ntpath.getsize": {
        "function": "getsize(filename)",
        "alias": "getsize",
        "help": "Help on function getsize in module genericpath:\n\ngetsize(filename)\n    Return the size of a file, reported by os.stat().",
        "syntax": "Syntax: getsize(filename)",
        "other-params": ""
    },
    "ntpath.isabs": {
        "function": "isabs(s)",
        "alias": "isabs",
        "help": "Help on function isabs in module ntpath:\n\nisabs(s)\n    Test whether a path is absolute",
        "syntax": "Syntax: isabs(s)",
        "other-params": ""
    },
    "ntpath.isdevdrive": {
        "function": "isdevdrive(path)",
        "alias": "isdevdrive",
        "help": "Help on function isdevdrive in module ntpath:\n\nisdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.",
        "syntax": "Syntax: isdevdrive(path)",
        "other-params": ""
    },
    "ntpath.isdir": {
        "function": "isdir(s)",
        "alias": "isdir",
        "help": "Help on built-in function _path_isdir in module nt:\n\n_path_isdir(s)\n    Return true if the pathname refers to an existing directory.",
        "syntax": "Syntax: isdir(s)",
        "other-params": ""
    },
    "ntpath.isfile": {
        "function": "isfile(path)",
        "alias": "isfile",
        "help": "Help on built-in function _path_isfile in module nt:\n\n_path_isfile(path)\n    Test whether a path is a regular file",
        "syntax": "Syntax: isfile(path)",
        "other-params": ""
    },
    "ntpath.isjunction": {
        "function": "isjunction(path)",
        "alias": "isjunction",
        "help": "Help on built-in function _path_isjunction in module nt:\n\n_path_isjunction(path)\n    Test whether a path is a junction",
        "syntax": "Syntax: isjunction(path)",
        "other-params": ""
    },
    "ntpath.islink": {
        "function": "islink(path)",
        "alias": "islink",
        "help": "Help on built-in function _path_islink in module nt:\n\n_path_islink(path)\n    Test whether a path is a symbolic link",
        "syntax": "Syntax: islink(path)",
        "other-params": ""
    },
    "ntpath.ismount": {
        "function": "ismount(path)",
        "alias": "ismount",
        "help": "Help on function ismount in module ntpath:\n\nismount(path)\n    Test whether a path is a mount point (a drive root, the root of a\n    share, or a mounted volume)",
        "syntax": "Syntax: ismount(path)",
        "other-params": ""
    },
    "ntpath.isreserved": {
        "function": "isreserved(path)",
        "alias": "isreserved",
        "help": "Help on function isreserved in module ntpath:\n\nisreserved(path)\n    Return true if the pathname is reserved by the system.",
        "syntax": "Syntax: isreserved(path)",
        "other-params": ""
    },
    "ntpath.join": {
        "function": "join(path, *paths)",
        "alias": "join",
        "help": "Help on function join in module ntpath:\n\njoin(path, *paths)",
        "syntax": "Syntax: join(path, *paths)",
        "other-params": ""
    },
    "ntpath.lexists": {
        "function": "lexists(path)",
        "alias": "lexists",
        "help": "Help on built-in function _path_lexists in module nt:\n\n_path_lexists(path)\n    Test whether a path exists.  Returns True for broken symbolic links.",
        "syntax": "Syntax: lexists(path)",
        "other-params": ""
    },
    "ntpath.normcase": {
        "function": "normcase(s)",
        "alias": "normcase",
        "help": "Help on function normcase in module ntpath:\n\nnormcase(s)\n    Normalize case of pathname.\n\n    Makes all characters lowercase and all slashes into backslashes.",
        "syntax": "Syntax: normcase(s)",
        "other-params": ""
    },
    "ntpath.normpath": {
        "function": "normpath(path)",
        "alias": "normpath",
        "help": "Help on built-in function _path_normpath in module nt:\n\n_path_normpath(path)\n    Normalize path, eliminating double slashes, etc.",
        "syntax": "Syntax: normpath(path)",
        "other-params": ""
    },
    "ntpath.realpath": {
        "function": "realpath(path, *, strict=False)",
        "alias": "realpath",
        "help": "Help on function realpath in module ntpath:\n\nrealpath(path, *, strict=False)",
        "syntax": "Syntax: realpath(path, *, strict=False)",
        "other-params": ""
    },
    "ntpath.relpath": {
        "function": "relpath(path, start=None)",
        "alias": "relpath",
        "help": "Help on function relpath in module ntpath:\n\nrelpath(path, start=None)\n    Return a relative version of a path",
        "syntax": "Syntax: relpath(path, start=None)",
        "other-params": ""
    },
    "ntpath.samefile": {
        "function": "samefile(f1, f2)",
        "alias": "samefile",
        "help": "Help on function samefile in module genericpath:\n\nsamefile(f1, f2)\n    Test whether two pathnames reference the same actual file or directory\n\n    This is determined by the device number and i-node number and\n    raises an exception if an os.stat() call on either pathname fails.",
        "syntax": "Syntax: samefile(f1, f2)",
        "other-params": ""
    },
    "ntpath.sameopenfile": {
        "function": "sameopenfile(fp1, fp2)",
        "alias": "sameopenfile",
        "help": "Help on function sameopenfile in module genericpath:\n\nsameopenfile(fp1, fp2)\n    Test whether two open file objects reference the same file",
        "syntax": "Syntax: sameopenfile(fp1, fp2)",
        "other-params": ""
    },
    "ntpath.samestat": {
        "function": "samestat(s1, s2)",
        "alias": "samestat",
        "help": "Help on function samestat in module genericpath:\n\nsamestat(s1, s2)\n    Test whether two stat buffers reference the same file",
        "syntax": "Syntax: samestat(s1, s2)",
        "other-params": ""
    },
    "ntpath.split": {
        "function": "split(p)",
        "alias": "split",
        "help": "Help on function split in module ntpath:\n\nsplit(p)\n    Split a pathname.\n\n    Return tuple (head, tail) where tail is everything after the final slash.\n    Either part may be empty.",
        "syntax": "Syntax: split(p)",
        "other-params": ""
    },
    "ntpath.splitdrive": {
        "function": "splitdrive(p)",
        "alias": "splitdrive",
        "help": "Help on function splitdrive in module ntpath:\n\nsplitdrive(p)\n    Split a pathname into drive/UNC sharepoint and relative path specifiers.\n    Returns a 2-tuple (drive_or_unc, path); either part may be empty.\n\n    If you assign\n        result = splitdrive(p)\n    It is always true that:\n        result[0] + result[1] == p\n\n    If the path contained a drive letter, drive_or_unc will contain everything\n    up to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\n    If the path contained a UNC path, the drive_or_unc will contain the host name\n    and share up to but not including the fourth directory separator character.\n    e.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\n    Paths cannot contain both a drive letter and a UNC path.",
        "syntax": "Syntax: splitdrive(p)",
        "other-params": ""
    },
    "ntpath.splitext": {
        "function": "splitext(p)",
        "alias": "splitext",
        "help": "Help on function splitext in module ntpath:\n\nsplitext(p)\n    Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.",
        "syntax": "Syntax: splitext(p)",
        "other-params": ""
    },
    "ntpath.splitroot": {
        "function": "splitroot(p)",
        "alias": "splitroot",
        "help": "Help on built-in function _path_splitroot_ex in module nt:\n\n_path_splitroot_ex(p)\n    Split a pathname into drive, root and tail.\n\n    The tail contains anything after the root.",
        "syntax": "Syntax: splitroot(p)",
        "other-params": ""
    },
    "os.path._LCMapStringEx": {
        "function": "_LCMapStringEx(locale, flags, src)",
        "alias": "_LCMapStringEx",
        "help": "Help on built-in function LCMapStringEx in module _winapi:\n\nLCMapStringEx(locale, flags, src)",
        "syntax": "Syntax: _LCMapStringEx(locale, flags, src)",
        "other-params": ""
    },
    "os.path._findfirstfile": {
        "function": "_findfirstfile(path, /)",
        "alias": "_findfirstfile",
        "help": "Help on built-in function _findfirstfile in module nt:\n\n_findfirstfile(path, /)\n    A function to get the real file name without accessing the file in Windows.",
        "syntax": "Syntax: _findfirstfile(path, /)",
        "other-params": ""
    },
    "os.path._get_bothseps": {
        "function": "_get_bothseps(path)",
        "alias": "_get_bothseps",
        "help": "Help on function _get_bothseps in module ntpath:\n\n_get_bothseps(path)",
        "syntax": "Syntax: _get_bothseps(path)",
        "other-params": ""
    },
    "os.path._getfinalpathname": {
        "function": "_getfinalpathname(path, /)",
        "alias": "_getfinalpathname",
        "help": "Help on built-in function _getfinalpathname in module nt:\n\n_getfinalpathname(path, /)\n    A helper function for samepath on windows.",
        "syntax": "Syntax: _getfinalpathname(path, /)",
        "other-params": ""
    },
    "os.path._getfinalpathname_nonstrict": {
        "function": "_getfinalpathname_nonstrict(path)",
        "alias": "_getfinalpathname_nonstrict",
        "help": "Help on function _getfinalpathname_nonstrict in module ntpath:\n\n_getfinalpathname_nonstrict(path)",
        "syntax": "Syntax: _getfinalpathname_nonstrict(path)",
        "other-params": ""
    },
    "os.path._getfullpathname": {
        "function": "_getfullpathname(path, /)",
        "alias": "_getfullpathname",
        "help": "Help on built-in function _getfullpathname in module nt:\n\n_getfullpathname(path, /)",
        "syntax": "Syntax: _getfullpathname(path, /)",
        "other-params": ""
    },
    "os.path._getvolumepathname": {
        "function": "_getvolumepathname(path)",
        "alias": "_getvolumepathname",
        "help": "Help on built-in function _getvolumepathname in module nt:\n\n_getvolumepathname(path)\n    A helper function for ismount on Win32.",
        "syntax": "Syntax: _getvolumepathname(path)",
        "other-params": ""
    },
    "os.path._isreservedname": {
        "function": "_isreservedname(name)",
        "alias": "_isreservedname",
        "help": "Help on function _isreservedname in module ntpath:\n\n_isreservedname(name)\n    Return true if the filename is reserved by the system.",
        "syntax": "Syntax: _isreservedname(name)",
        "other-params": ""
    },
    "os.path._nt_readlink": {
        "function": "_nt_readlink(path, *, dir_fd=None)",
        "alias": "_nt_readlink",
        "help": "Help on built-in function readlink in module nt:\n\nreadlink(path, *, dir_fd=None)\n    Return a string representing the path to which the symbolic link points.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that directory.\n\n    dir_fd may not be implemented on your platform.  If it is unavailable,\n    using it will raise a NotImplementedError.",
        "syntax": "Syntax: _nt_readlink(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.path._path_isdevdrive": {
        "function": "_path_isdevdrive(path)",
        "alias": "_path_isdevdrive",
        "help": "Help on built-in function _path_isdevdrive in module nt:\n\n_path_isdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.",
        "syntax": "Syntax: _path_isdevdrive(path)",
        "other-params": ""
    },
    "os.path._readlink_deep": {
        "function": "_readlink_deep(path)",
        "alias": "_readlink_deep",
        "help": "Help on function _readlink_deep in module ntpath:\n\n_readlink_deep(path)",
        "syntax": "Syntax: _readlink_deep(path)",
        "other-params": ""
    },
    "os.path.abspath": {
        "function": "abspath(path)",
        "alias": "abspath",
        "help": "Help on function abspath in module ntpath:\n\nabspath(path)\n    Return the absolute version of a path.",
        "syntax": "Syntax: abspath(path)",
        "other-params": ""
    },
    "os.path.basename": {
        "function": "basename(p)",
        "alias": "basename",
        "help": "Help on function basename in module ntpath:\n\nbasename(p)\n    Returns the final component of a pathname",
        "syntax": "Syntax: basename(p)",
        "other-params": ""
    },
    "os.path.commonpath": {
        "function": "commonpath(paths)",
        "alias": "commonpath",
        "help": "Help on function commonpath in module ntpath:\n\ncommonpath(paths)\n    Given an iterable of path names, returns the longest common sub-path.",
        "syntax": "Syntax: commonpath(paths)",
        "other-params": ""
    },
    "os.path.commonprefix": {
        "function": "commonprefix(m)",
        "alias": "commonprefix",
        "help": "Help on function commonprefix in module genericpath:\n\ncommonprefix(m)\n    Given a list of pathnames, returns the longest common leading component",
        "syntax": "Syntax: commonprefix(m)",
        "other-params": ""
    },
    "os.path.dirname": {
        "function": "dirname(p)",
        "alias": "dirname",
        "help": "Help on function dirname in module ntpath:\n\ndirname(p)\n    Returns the directory component of a pathname",
        "syntax": "Syntax: dirname(p)",
        "other-params": ""
    },
    "os.path.exists": {
        "function": "exists(path)",
        "alias": "exists",
        "help": "Help on built-in function _path_exists in module nt:\n\n_path_exists(path)\n    Test whether a path exists.  Returns False for broken symbolic links.",
        "syntax": "Syntax: exists(path)",
        "other-params": ""
    },
    "os.path.expanduser": {
        "function": "expanduser(path)",
        "alias": "expanduser",
        "help": "Help on function expanduser in module ntpath:\n\nexpanduser(path)\n    Expand ~ and ~user constructs.\n\n    If user or $HOME is unknown, do nothing.",
        "syntax": "Syntax: expanduser(path)",
        "other-params": ""
    },
    "os.path.expandvars": {
        "function": "expandvars(path)",
        "alias": "expandvars",
        "help": "Help on function expandvars in module ntpath:\n\nexpandvars(path)\n    Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.",
        "syntax": "Syntax: expandvars(path)",
        "other-params": ""
    },
    "os.path.getatime": {
        "function": "getatime(filename)",
        "alias": "getatime",
        "help": "Help on function getatime in module genericpath:\n\ngetatime(filename)\n    Return the last access time of a file, reported by os.stat().",
        "syntax": "Syntax: getatime(filename)",
        "other-params": ""
    },
    "os.path.getctime": {
        "function": "getctime(filename)",
        "alias": "getctime",
        "help": "Help on function getctime in module genericpath:\n\ngetctime(filename)\n    Return the metadata change time of a file, reported by os.stat().",
        "syntax": "Syntax: getctime(filename)",
        "other-params": ""
    },
    "os.path.getmtime": {
        "function": "getmtime(filename)",
        "alias": "getmtime",
        "help": "Help on function getmtime in module genericpath:\n\ngetmtime(filename)\n    Return the last modification time of a file, reported by os.stat().",
        "syntax": "Syntax: getmtime(filename)",
        "other-params": ""
    },
    "os.path.getsize": {
        "function": "getsize(filename)",
        "alias": "getsize",
        "help": "Help on function getsize in module genericpath:\n\ngetsize(filename)\n    Return the size of a file, reported by os.stat().",
        "syntax": "Syntax: getsize(filename)",
        "other-params": ""
    },
    "os.path.isabs": {
        "function": "isabs(s)",
        "alias": "isabs",
        "help": "Help on function isabs in module ntpath:\n\nisabs(s)\n    Test whether a path is absolute",
        "syntax": "Syntax: isabs(s)",
        "other-params": ""
    },
    "os.path.isdevdrive": {
        "function": "isdevdrive(path)",
        "alias": "isdevdrive",
        "help": "Help on function isdevdrive in module ntpath:\n\nisdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.",
        "syntax": "Syntax: isdevdrive(path)",
        "other-params": ""
    },
    "os.path.isdir": {
        "function": "isdir(s)",
        "alias": "isdir",
        "help": "Help on built-in function _path_isdir in module nt:\n\n_path_isdir(s)\n    Return true if the pathname refers to an existing directory.",
        "syntax": "Syntax: isdir(s)",
        "other-params": ""
    },
    "os.path.isfile": {
        "function": "isfile(path)",
        "alias": "isfile",
        "help": "Help on built-in function _path_isfile in module nt:\n\n_path_isfile(path)\n    Test whether a path is a regular file",
        "syntax": "Syntax: isfile(path)",
        "other-params": ""
    },
    "os.path.isjunction": {
        "function": "isjunction(path)",
        "alias": "isjunction",
        "help": "Help on built-in function _path_isjunction in module nt:\n\n_path_isjunction(path)\n    Test whether a path is a junction",
        "syntax": "Syntax: isjunction(path)",
        "other-params": ""
    },
    "os.path.islink": {
        "function": "islink(path)",
        "alias": "islink",
        "help": "Help on built-in function _path_islink in module nt:\n\n_path_islink(path)\n    Test whether a path is a symbolic link",
        "syntax": "Syntax: islink(path)",
        "other-params": ""
    },
    "os.path.ismount": {
        "function": "ismount(path)",
        "alias": "ismount",
        "help": "Help on function ismount in module ntpath:\n\nismount(path)\n    Test whether a path is a mount point (a drive root, the root of a\n    share, or a mounted volume)",
        "syntax": "Syntax: ismount(path)",
        "other-params": ""
    },
    "os.path.isreserved": {
        "function": "isreserved(path)",
        "alias": "isreserved",
        "help": "Help on function isreserved in module ntpath:\n\nisreserved(path)\n    Return true if the pathname is reserved by the system.",
        "syntax": "Syntax: isreserved(path)",
        "other-params": ""
    },
    "os.path.join": {
        "function": "join(path, *paths)",
        "alias": "join",
        "help": "Help on function join in module ntpath:\n\njoin(path, *paths)",
        "syntax": "Syntax: join(path, *paths)",
        "other-params": ""
    },
    "os.path.lexists": {
        "function": "lexists(path)",
        "alias": "lexists",
        "help": "Help on built-in function _path_lexists in module nt:\n\n_path_lexists(path)\n    Test whether a path exists.  Returns True for broken symbolic links.",
        "syntax": "Syntax: lexists(path)",
        "other-params": ""
    },
    "os.path.normcase": {
        "function": "normcase(s)",
        "alias": "normcase",
        "help": "Help on function normcase in module ntpath:\n\nnormcase(s)\n    Normalize case of pathname.\n\n    Makes all characters lowercase and all slashes into backslashes.",
        "syntax": "Syntax: normcase(s)",
        "other-params": ""
    },
    "os.path.normpath": {
        "function": "normpath(path)",
        "alias": "normpath",
        "help": "Help on built-in function _path_normpath in module nt:\n\n_path_normpath(path)\n    Normalize path, eliminating double slashes, etc.",
        "syntax": "Syntax: normpath(path)",
        "other-params": ""
    },
    "os.path.realpath": {
        "function": "realpath(path, *, strict=False)",
        "alias": "realpath",
        "help": "Help on function realpath in module ntpath:\n\nrealpath(path, *, strict=False)",
        "syntax": "Syntax: realpath(path, *, strict=False)",
        "other-params": ""
    },
    "os.path.relpath": {
        "function": "relpath(path, start=None)",
        "alias": "relpath",
        "help": "Help on function relpath in module ntpath:\n\nrelpath(path, start=None)\n    Return a relative version of a path",
        "syntax": "Syntax: relpath(path, start=None)",
        "other-params": ""
    },
    "os.path.samefile": {
        "function": "samefile(f1, f2)",
        "alias": "samefile",
        "help": "Help on function samefile in module genericpath:\n\nsamefile(f1, f2)\n    Test whether two pathnames reference the same actual file or directory\n\n    This is determined by the device number and i-node number and\n    raises an exception if an os.stat() call on either pathname fails.",
        "syntax": "Syntax: samefile(f1, f2)",
        "other-params": ""
    },
    "os.path.sameopenfile": {
        "function": "sameopenfile(fp1, fp2)",
        "alias": "sameopenfile",
        "help": "Help on function sameopenfile in module genericpath:\n\nsameopenfile(fp1, fp2)\n    Test whether two open file objects reference the same file",
        "syntax": "Syntax: sameopenfile(fp1, fp2)",
        "other-params": ""
    },
    "os.path.samestat": {
        "function": "samestat(s1, s2)",
        "alias": "samestat",
        "help": "Help on function samestat in module genericpath:\n\nsamestat(s1, s2)\n    Test whether two stat buffers reference the same file",
        "syntax": "Syntax: samestat(s1, s2)",
        "other-params": ""
    },
    "os.path.split": {
        "function": "split(p)",
        "alias": "split",
        "help": "Help on function split in module ntpath:\n\nsplit(p)\n    Split a pathname.\n\n    Return tuple (head, tail) where tail is everything after the final slash.\n    Either part may be empty.",
        "syntax": "Syntax: split(p)",
        "other-params": ""
    },
    "os.path.splitdrive": {
        "function": "splitdrive(p)",
        "alias": "splitdrive",
        "help": "Help on function splitdrive in module ntpath:\n\nsplitdrive(p)\n    Split a pathname into drive/UNC sharepoint and relative path specifiers.\n    Returns a 2-tuple (drive_or_unc, path); either part may be empty.\n\n    If you assign\n        result = splitdrive(p)\n    It is always true that:\n        result[0] + result[1] == p\n\n    If the path contained a drive letter, drive_or_unc will contain everything\n    up to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\n    If the path contained a UNC path, the drive_or_unc will contain the host name\n    and share up to but not including the fourth directory separator character.\n    e.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\n    Paths cannot contain both a drive letter and a UNC path.",
        "syntax": "Syntax: splitdrive(p)",
        "other-params": ""
    },
    "os.path.splitext": {
        "function": "splitext(p)",
        "alias": "splitext",
        "help": "Help on function splitext in module ntpath:\n\nsplitext(p)\n    Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.",
        "syntax": "Syntax: splitext(p)",
        "other-params": ""
    },
    "os.path.splitroot": {
        "function": "splitroot(p)",
        "alias": "splitroot",
        "help": "Help on built-in function _path_splitroot_ex in module nt:\n\n_path_splitroot_ex(p)\n    Split a pathname into drive, root and tail.\n\n    The tail contains anything after the root.",
        "syntax": "Syntax: splitroot(p)",
        "other-params": ""
    },
    "os.DirEntry": {
        "function": "DirEntry()",
        "alias": "DirEntry",
        "help": "Help on class DirEntry in module nt:\n\nclass DirEntry(builtins.object)\n |  Methods defined here:\n |\n |  __fspath__(self, /)\n |      Returns the path for the entry.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  inode(self, /)\n |      Return inode of the entry; cached per entry.\n |\n |  is_dir(self, /, *, follow_symlinks=True)\n |      Return True if the entry is a directory; cached per entry.\n |\n |  is_file(self, /, *, follow_symlinks=True)\n |      Return True if the entry is a file; cached per entry.\n |\n |  is_junction(self, /)\n |      Return True if the entry is a junction; cached per entry.\n |\n |  is_symlink(self, /)\n |      Return True if the entry is a symbolic link; cached per entry.\n |\n |  stat(self, /, *, follow_symlinks=True)\n |      Return stat_result object for the entry; cached per entry.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  name\n |      the entry's base filename, relative to scandir() \"path\" argument\n |\n |  path\n |      the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)",
        "syntax": "Syntax: DirEntry()",
        "other-params": ""
    },
    "os.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "os.Mapping": {
        "function": "Mapping()",
        "alias": "Mapping",
        "help": "Help on class Mapping in module collections.abc:\n\nclass Mapping(Collection)\n |  A Mapping is a generic container for associating key/value\n |  pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __iter__, and __len__.\n |\n |  Method resolution order:\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__iter__', '__len__'}...\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Mapping()",
        "other-params": ""
    },
    "os.MutableMapping": {
        "function": "MutableMapping()",
        "alias": "MutableMapping",
        "help": "Help on class MutableMapping in module collections.abc:\n\nclass MutableMapping(Mapping)\n |  A MutableMapping is a generic container for associating\n |  key/value pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __setitem__, __delitem__,\n |  __iter__, and __len__.\n |\n |  Method resolution order:\n |      MutableMapping\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, key)\n |\n |  __setitem__(self, key, value)\n |\n |  clear(self)\n |      D.clear() -> None.  Remove all items from D.\n |\n |  pop(self, key, default=<object object at 0x000001950D090200>)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised.\n |\n |  popitem(self)\n |      D.popitem() -> (k, v), remove and return some (key, value) pair\n |      as a 2-tuple; but raise KeyError if D is empty.\n |\n |  setdefault(self, key, default=None)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__delitem__', '__getitem__', '__iter...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Mapping:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: MutableMapping()",
        "other-params": ""
    },
    "os.PathLike": {
        "function": "PathLike()",
        "alias": "PathLike",
        "help": "Help on class PathLike in module os:\n\nclass PathLike(abc.ABC)\n |  Abstract base class for implementing the file system path protocol.\n |\n |  Method resolution order:\n |      PathLike\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __fspath__(self)\n |      Return the file system path representation of the object.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(subclass)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__fspath__'})",
        "syntax": "Syntax: PathLike()",
        "other-params": ""
    },
    "os._AddedDllDirectory": {
        "function": "_AddedDllDirectory(path, cookie, remove_dll_directory)",
        "alias": "_AddedDllDirectory",
        "help": "Help on class _AddedDllDirectory in module os:\n\nclass _AddedDllDirectory(builtins.object)\n |  _AddedDllDirectory(path, cookie, remove_dll_directory)\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *args)\n |\n |  __init__(self, path, cookie, remove_dll_directory)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  close(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _AddedDllDirectory(path, cookie, remove_dll_directory)",
        "other-params": ""
    },
    "os._Environ": {
        "function": "_Environ(data, encodekey, decodekey, encodevalue, decodevalue)",
        "alias": "_Environ",
        "help": "Help on class _Environ in module os:\n\nclass _Environ(collections.abc.MutableMapping)\n |  _Environ(data, encodekey, decodekey, encodevalue, decodevalue)\n |\n |  Method resolution order:\n |      _Environ\n |      collections.abc.MutableMapping\n |      collections.abc.Mapping\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, key)\n |\n |  __getitem__(self, key)\n |\n |  __init__(self, data, encodekey, decodekey, encodevalue, decodevalue)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __ior__(self, other)\n |\n |  __iter__(self)\n |\n |  __len__(self)\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __ror__(self, other)\n |      Return value|self.\n |\n |  __setitem__(self, key, value)\n |\n |  copy(self)\n |\n |  setdefault(self, key, value)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MutableMapping:\n |\n |  clear(self)\n |      D.clear() -> None.  Remove all items from D.\n |\n |  pop(self, key, default=<object object at 0x000001950D090200>)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised.\n |\n |  popitem(self)\n |      D.popitem() -> (k, v), remove and return some (key, value) pair\n |      as a 2-tuple; but raise KeyError if D is empty.\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Mapping:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from collections.abc.Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: _Environ(data, encodekey, decodekey, encodevalue, decodevalue)",
        "other-params": ""
    },
    "os._check_methods": {
        "function": "_check_methods(C, *methods)",
        "alias": "_check_methods",
        "help": "Help on function _check_methods in module collections.abc:\n\n_check_methods(C, *methods)",
        "syntax": "Syntax: _check_methods(C, *methods)",
        "other-params": ""
    },
    "os._execvpe": {
        "function": "_execvpe(file, args, env=None)",
        "alias": "_execvpe",
        "help": "Help on function _execvpe in module os:\n\n_execvpe(file, args, env=None)",
        "syntax": "Syntax: _execvpe(file, args, env=None)",
        "other-params": ""
    },
    "os._exists": {
        "function": "_exists(name)",
        "alias": "_exists",
        "help": "Help on function _exists in module os:\n\n_exists(name)",
        "syntax": "Syntax: _exists(name)",
        "other-params": ""
    },
    "os._exit": {
        "function": "_exit(status)",
        "alias": "_exit",
        "help": "Help on built-in function _exit in module nt:\n\n_exit(status)\n    Exit to the system with specified status, without normal exit processing.",
        "syntax": "Syntax: _exit(status)",
        "other-params": ""
    },
    "os._fspath": {
        "function": "_fspath(path)",
        "alias": "_fspath",
        "help": "Help on function _fspath in module os:\n\n_fspath(path)\n    Return the path representation of a path-like object.\n\n    If str or bytes is passed in, it is returned unchanged. Otherwise the\n    os.PathLike interface is used to get the path representation. If the\n    path representation is not str or bytes, TypeError is raised. If the\n    provided path is not str, bytes, or os.PathLike, TypeError is raised.",
        "syntax": "Syntax: _fspath(path)",
        "other-params": ""
    },
    "os._get_exports_list": {
        "function": "_get_exports_list(module)",
        "alias": "_get_exports_list",
        "help": "Help on function _get_exports_list in module os:\n\n_get_exports_list(module)",
        "syntax": "Syntax: _get_exports_list(module)",
        "other-params": ""
    },
    "os._wrap_close": {
        "function": "_wrap_close(stream, proc)",
        "alias": "_wrap_close",
        "help": "Help on class _wrap_close in module os:\n\nclass _wrap_close(builtins.object)\n |  _wrap_close(stream, proc)\n |\n |  # Helper for popen() -- a proxy for a file whose close waits for the process\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *args)\n |\n |  __getattr__(self, name)\n |\n |  __init__(self, stream, proc)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self)\n |\n |  close(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _wrap_close(stream, proc)",
        "other-params": ""
    },
    "os.abort": {
        "function": "abort()",
        "alias": "abort",
        "help": "Help on built-in function abort in module nt:\n\nabort()\n    Abort the interpreter immediately.\n\n    This function 'dumps core' or otherwise fails in the hardest way possible\n    on the hosting operating system.  This function never returns.",
        "syntax": "Syntax: abort()",
        "other-params": ""
    },
    "os.access": {
        "function": "access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)",
        "alias": "access",
        "help": "Help on built-in function access in module nt:\n\naccess(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)\n    Use the real uid/gid to test for access to a path.\n\n      path\n        Path to be tested; can be string, bytes, or a path-like object.\n      mode\n        Operating-system mode bitfield.  Can be F_OK to test existence,\n        or the inclusive-OR of R_OK, W_OK, and X_OK.\n      dir_fd\n        If not None, it should be a file descriptor open to a directory,\n        and path should be relative; path will then be relative to that\n        directory.\n      effective_ids\n        If True, access will use the effective uid/gid instead of\n        the real uid/gid.\n      follow_symlinks\n        If False, and the last element of the path is a symbolic link,\n        access will examine the symbolic link itself instead of the file\n        the link points to.\n\n    dir_fd, effective_ids, and follow_symlinks may not be implemented\n      on your platform.  If they are unavailable, using them will raise a\n      NotImplementedError.\n\n    Note that most operations will use the effective uid/gid, therefore this\n      routine can be used in a suid/sgid environment to test if the invoking user\n      has the specified access to the path.",
        "syntax": "Syntax: access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)",
        "other-params": ""
    },
    "os.add_dll_directory": {
        "function": "add_dll_directory(path)",
        "alias": "add_dll_directory",
        "help": "Help on function add_dll_directory in module os:\n\nadd_dll_directory(path)\n    Add a path to the DLL search path.\n\n    This search path is used when resolving dependencies for imported\n    extension modules (the module itself is resolved through sys.path),\n    and also by ctypes.\n\n    Remove the directory by calling close() on the returned object or\n    using it in a with statement.",
        "syntax": "Syntax: add_dll_directory(path)",
        "other-params": ""
    },
    "os.chdir": {
        "function": "chdir(path)",
        "alias": "chdir",
        "help": "Help on built-in function chdir in module nt:\n\nchdir(path)\n    Change the current working directory to the specified path.\n\n    path may always be specified as a string.\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.",
        "syntax": "Syntax: chdir(path)",
        "other-params": ""
    },
    "os.chmod": {
        "function": "Error retrieving signature: <built-in function chmod> builtin has invalid signature",
        "alias": "chmod",
        "help": "Help on built-in function chmod in module nt:\n\nchmod(path, mode, *, dir_fd=None,\n      follow_symlinks=(os.name != 'nt'))\n    Change the access permissions of a file.\n\n      path\n        Path to be modified.  May always be specified as a str, bytes, or a path-like object.\n        On some platforms, path may also be specified as an open file descriptor.\n        If this functionality is unavailable, using it raises an exception.\n      mode\n        Operating-system mode bitfield.\n        Be careful when using number literals for *mode*. The conventional UNIX notation for\n        numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n        Python.\n      dir_fd\n        If not None, it should be a file descriptor open to a directory,\n        and path should be relative; path will then be relative to that\n        directory.\n      follow_symlinks\n        If False, and the last element of the path is a symbolic link,\n        chmod will modify the symbolic link itself instead of the file\n        the link points to.\n\n    It is an error to use dir_fd or follow_symlinks when specifying path as\n      an open file descriptor.\n    dir_fd and follow_symlinks may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.",
        "syntax": "Syntax: Error retrieving signature: <built-in function chmod> builtin has invalid signature",
        "other-params": ""
    },
    "os.close": {
        "function": "close(fd)",
        "alias": "close",
        "help": "Help on built-in function close in module nt:\n\nclose(fd)\n    Close a file descriptor.",
        "syntax": "Syntax: close(fd)",
        "other-params": ""
    },
    "os.closerange": {
        "function": "closerange(fd_low, fd_high, /)",
        "alias": "closerange",
        "help": "Help on built-in function closerange in module nt:\n\ncloserange(fd_low, fd_high, /)\n    Closes all file descriptors in [fd_low, fd_high), ignoring errors.",
        "syntax": "Syntax: closerange(fd_low, fd_high, /)",
        "other-params": ""
    },
    "os.cpu_count": {
        "function": "cpu_count()",
        "alias": "cpu_count",
        "help": "Help on built-in function cpu_count in module nt:\n\ncpu_count()\n    Return the number of logical CPUs in the system.\n\n    Return None if indeterminable.",
        "syntax": "Syntax: cpu_count()",
        "other-params": ""
    },
    "os.device_encoding": {
        "function": "device_encoding(fd)",
        "alias": "device_encoding",
        "help": "Help on built-in function device_encoding in module nt:\n\ndevice_encoding(fd)\n    Return a string describing the encoding of a terminal's file descriptor.\n\n    The file descriptor must be attached to a terminal.\n    If the device is not a terminal, return None.",
        "syntax": "Syntax: device_encoding(fd)",
        "other-params": ""
    },
    "os.dup": {
        "function": "dup(fd, /)",
        "alias": "dup",
        "help": "Help on built-in function dup in module nt:\n\ndup(fd, /)\n    Return a duplicate of a file descriptor.",
        "syntax": "Syntax: dup(fd, /)",
        "other-params": ""
    },
    "os.dup2": {
        "function": "dup2(fd, fd2, inheritable=True)",
        "alias": "dup2",
        "help": "Help on built-in function dup2 in module nt:\n\ndup2(fd, fd2, inheritable=True)\n    Duplicate file descriptor.",
        "syntax": "Syntax: dup2(fd, fd2, inheritable=True)",
        "other-params": ""
    },
    "os.error": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'OSError'>",
        "alias": "error",
        "help": "Help on class OSError in module builtins:\n\nclass OSError(Exception)\n |  Base class for I/O related errors.\n |\n |  Method resolution order:\n |      OSError\n |      Exception\n |      BaseException\n |      object\n |\n |  Built-in subclasses:\n |      BlockingIOError\n |      ChildProcessError\n |      ConnectionError\n |      FileExistsError\n |      ... and 7 other subclasses\n |\n |  Methods defined here:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  characters_written\n |\n |  errno\n |      POSIX exception code\n |\n |  filename\n |      exception filename\n |\n |  filename2\n |      second exception filename\n |\n |  strerror\n |      exception strerror\n |\n |  winerror\n |      Win32 exception code\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'OSError'>",
        "other-params": ""
    },
    "os.execl": {
        "function": "execl(file, *args)",
        "alias": "execl",
        "help": "Help on function execl in module os:\n\nexecl(file, *args)\n    execl(file, *args)\n\n    Execute the executable file with argument list args, replacing the\n    current process.",
        "syntax": "Syntax: execl(file, *args)",
        "other-params": ""
    },
    "os.execle": {
        "function": "execle(file, *args)",
        "alias": "execle",
        "help": "Help on function execle in module os:\n\nexecle(file, *args)\n    execle(file, *args, env)\n\n    Execute the executable file with argument list args and\n    environment env, replacing the current process.",
        "syntax": "Syntax: execle(file, *args)",
        "other-params": ""
    },
    "os.execlp": {
        "function": "execlp(file, *args)",
        "alias": "execlp",
        "help": "Help on function execlp in module os:\n\nexeclp(file, *args)\n    execlp(file, *args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process.",
        "syntax": "Syntax: execlp(file, *args)",
        "other-params": ""
    },
    "os.execlpe": {
        "function": "execlpe(file, *args)",
        "alias": "execlpe",
        "help": "Help on function execlpe in module os:\n\nexeclpe(file, *args)\n    execlpe(file, *args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the current\n    process.",
        "syntax": "Syntax: execlpe(file, *args)",
        "other-params": ""
    },
    "os.execv": {
        "function": "execv(path, argv, /)",
        "alias": "execv",
        "help": "Help on built-in function execv in module nt:\n\nexecv(path, argv, /)\n    Execute an executable path with arguments, replacing current process.\n\n    path\n      Path of executable file.\n    argv\n      Tuple or list of strings.",
        "syntax": "Syntax: execv(path, argv, /)",
        "other-params": ""
    },
    "os.execve": {
        "function": "execve(path, argv, env)",
        "alias": "execve",
        "help": "Help on built-in function execve in module nt:\n\nexecve(path, argv, env)\n    Execute an executable path with arguments, replacing current process.\n\n    path\n      Path of executable file.\n    argv\n      Tuple or list of strings.\n    env\n      Dictionary of strings mapping to strings.",
        "syntax": "Syntax: execve(path, argv, env)",
        "other-params": ""
    },
    "os.execvp": {
        "function": "execvp(file, args)",
        "alias": "execvp",
        "help": "Help on function execvp in module os:\n\nexecvp(file, args)\n    execvp(file, args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process.\n    args may be a list or tuple of strings.",
        "syntax": "Syntax: execvp(file, args)",
        "other-params": ""
    },
    "os.execvpe": {
        "function": "execvpe(file, args, env)",
        "alias": "execvpe",
        "help": "Help on function execvpe in module os:\n\nexecvpe(file, args, env)\n    execvpe(file, args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the\n    current process.\n    args may be a list or tuple of strings.",
        "syntax": "Syntax: execvpe(file, args, env)",
        "other-params": ""
    },
    "os.fchmod": {
        "function": "fchmod(fd, mode)",
        "alias": "fchmod",
        "help": "Help on built-in function fchmod in module nt:\n\nfchmod(fd, mode)\n    Change the access permissions of the file given by file descriptor fd.\n\n      fd\n        The file descriptor of the file to be modified.\n      mode\n        Operating-system mode bitfield.\n        Be careful when using number literals for *mode*. The conventional UNIX notation for\n        numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n        Python.\n\n    Equivalent to os.chmod(fd, mode).",
        "syntax": "Syntax: fchmod(fd, mode)",
        "other-params": ""
    },
    "os.fdopen": {
        "function": "fdopen(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
        "alias": "fdopen",
        "help": "Help on function fdopen in module os:\n\nfdopen(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
        "syntax": "Syntax: fdopen(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
        "other-params": ""
    },
    "os.fsdecode": {
        "function": "fsdecode(filename)",
        "alias": "fsdecode",
        "help": "Help on function fsdecode in module os:\n\nfsdecode(filename)\n    Decode filename (an os.PathLike, bytes, or str) from the filesystem\n    encoding with 'surrogateescape' error handler, return str unchanged. On\n    Windows, use 'strict' error handler if the file system encoding is\n    'mbcs' (which is the default encoding).",
        "syntax": "Syntax: fsdecode(filename)",
        "other-params": ""
    },
    "os.fsencode": {
        "function": "fsencode(filename)",
        "alias": "fsencode",
        "help": "Help on function fsencode in module os:\n\nfsencode(filename)\n    Encode filename (an os.PathLike, bytes, or str) to the filesystem\n    encoding with 'surrogateescape' error handler, return bytes unchanged.\n    On Windows, use 'strict' error handler if the file system encoding is\n    'mbcs' (which is the default encoding).",
        "syntax": "Syntax: fsencode(filename)",
        "other-params": ""
    },
    "os.fspath": {
        "function": "fspath(path)",
        "alias": "fspath",
        "help": "Help on built-in function fspath in module nt:\n\nfspath(path)\n    Return the file system path representation of the object.\n\n    If the object is str or bytes, then allow it to pass through as-is. If the\n    object defines __fspath__(), then return the result of that method. All other\n    types raise a TypeError.",
        "syntax": "Syntax: fspath(path)",
        "other-params": ""
    },
    "os.fstat": {
        "function": "fstat(fd)",
        "alias": "fstat",
        "help": "Help on built-in function fstat in module nt:\n\nfstat(fd)\n    Perform a stat system call on the given file descriptor.\n\n    Like stat(), but for an open file descriptor.\n    Equivalent to os.stat(fd).",
        "syntax": "Syntax: fstat(fd)",
        "other-params": ""
    },
    "os.fsync": {
        "function": "fsync(fd)",
        "alias": "fsync",
        "help": "Help on built-in function fsync in module nt:\n\nfsync(fd)\n    Force write of fd to disk.",
        "syntax": "Syntax: fsync(fd)",
        "other-params": ""
    },
    "os.ftruncate": {
        "function": "ftruncate(fd, length, /)",
        "alias": "ftruncate",
        "help": "Help on built-in function ftruncate in module nt:\n\nftruncate(fd, length, /)\n    Truncate a file, specified by file descriptor, to a specific length.",
        "syntax": "Syntax: ftruncate(fd, length, /)",
        "other-params": ""
    },
    "os.get_blocking": {
        "function": "get_blocking(fd, /)",
        "alias": "get_blocking",
        "help": "Help on built-in function get_blocking in module nt:\n\nget_blocking(fd, /)\n    Get the blocking mode of the file descriptor.\n\n    Return False if the O_NONBLOCK flag is set, True if the flag is cleared.",
        "syntax": "Syntax: get_blocking(fd, /)",
        "other-params": ""
    },
    "os.get_exec_path": {
        "function": "get_exec_path(env=None)",
        "alias": "get_exec_path",
        "help": "Help on function get_exec_path in module os:\n\nget_exec_path(env=None)\n    Returns the sequence of directories that will be searched for the\n    named executable (similar to a shell) when launching a process.\n\n    *env* must be an environment variable dict or None.  If *env* is None,\n    os.environ will be used.",
        "syntax": "Syntax: get_exec_path(env=None)",
        "other-params": ""
    },
    "os.get_handle_inheritable": {
        "function": "get_handle_inheritable(handle, /)",
        "alias": "get_handle_inheritable",
        "help": "Help on built-in function get_handle_inheritable in module nt:\n\nget_handle_inheritable(handle, /)\n    Get the close-on-exe flag of the specified file descriptor.",
        "syntax": "Syntax: get_handle_inheritable(handle, /)",
        "other-params": ""
    },
    "os.get_inheritable": {
        "function": "get_inheritable(fd, /)",
        "alias": "get_inheritable",
        "help": "Help on built-in function get_inheritable in module nt:\n\nget_inheritable(fd, /)\n    Get the close-on-exe flag of the specified file descriptor.",
        "syntax": "Syntax: get_inheritable(fd, /)",
        "other-params": ""
    },
    "os.get_terminal_size": {
        "function": "Error retrieving signature: <built-in function get_terminal_size> builtin has invalid signature",
        "alias": "get_terminal_size",
        "help": "Help on built-in function get_terminal_size in module nt:\n\nget_terminal_size(fd=<unrepresentable>, /)\n    Return the size of the terminal window as (columns, lines).\n\n    The optional argument fd (default standard output) specifies\n    which file descriptor should be queried.\n\n    If the file descriptor is not connected to a terminal, an OSError\n    is thrown.\n\n    This function will only be defined if an implementation is\n    available for this system.\n\n    shutil.get_terminal_size is the high-level function which should\n    normally be used, os.get_terminal_size is the low-level implementation.",
        "syntax": "Syntax: Error retrieving signature: <built-in function get_terminal_size> builtin has invalid signature",
        "other-params": ""
    },
    "os.getcwd": {
        "function": "getcwd()",
        "alias": "getcwd",
        "help": "Help on built-in function getcwd in module nt:\n\ngetcwd()\n    Return a unicode string representing the current working directory.",
        "syntax": "Syntax: getcwd()",
        "other-params": ""
    },
    "os.getcwdb": {
        "function": "getcwdb()",
        "alias": "getcwdb",
        "help": "Help on built-in function getcwdb in module nt:\n\ngetcwdb()\n    Return a bytes string representing the current working directory.",
        "syntax": "Syntax: getcwdb()",
        "other-params": ""
    },
    "os.getenv": {
        "function": "getenv(key, default=None)",
        "alias": "getenv",
        "help": "Help on function getenv in module os:\n\ngetenv(key, default=None)\n    Get an environment variable, return None if it doesn't exist.\n    The optional second argument can specify an alternate default.\n    key, default and the result are str.",
        "syntax": "Syntax: getenv(key, default=None)",
        "other-params": ""
    },
    "os.getlogin": {
        "function": "getlogin()",
        "alias": "getlogin",
        "help": "Help on built-in function getlogin in module nt:\n\ngetlogin()\n    Return the actual login name.",
        "syntax": "Syntax: getlogin()",
        "other-params": ""
    },
    "os.getpid": {
        "function": "getpid()",
        "alias": "getpid",
        "help": "Help on built-in function getpid in module nt:\n\ngetpid()\n    Return the current process id.",
        "syntax": "Syntax: getpid()",
        "other-params": ""
    },
    "os.getppid": {
        "function": "getppid()",
        "alias": "getppid",
        "help": "Help on built-in function getppid in module nt:\n\ngetppid()\n    Return the parent's process id.\n\n    If the parent process has already exited, Windows machines will still\n    return its id; others systems will return the id of the 'init' process (1).",
        "syntax": "Syntax: getppid()",
        "other-params": ""
    },
    "os.isatty": {
        "function": "isatty(fd, /)",
        "alias": "isatty",
        "help": "Help on built-in function isatty in module nt:\n\nisatty(fd, /)\n    Return True if the fd is connected to a terminal.\n\n    Return True if the file descriptor is an open file descriptor\n    connected to the slave end of a terminal.",
        "syntax": "Syntax: isatty(fd, /)",
        "other-params": ""
    },
    "os.kill": {
        "function": "kill(pid, signal, /)",
        "alias": "kill",
        "help": "Help on built-in function kill in module nt:\n\nkill(pid, signal, /)\n    Kill a process with a signal.",
        "syntax": "Syntax: kill(pid, signal, /)",
        "other-params": ""
    },
    "os.lchmod": {
        "function": "lchmod(path, mode)",
        "alias": "lchmod",
        "help": "Help on built-in function lchmod in module nt:\n\nlchmod(path, mode)\n    Change the access permissions of a file, without following symbolic links.\n\n    If path is a symlink, this affects the link itself rather than the target.\n    Equivalent to chmod(path, mode, follow_symlinks=False).\"",
        "syntax": "Syntax: lchmod(path, mode)",
        "other-params": ""
    },
    "os.link": {
        "function": "link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)",
        "alias": "link",
        "help": "Help on built-in function link in module nt:\n\nlink(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)\n    Create a hard link to a file.\n\n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    If follow_symlinks is False, and the last element of src is a symbolic\n      link, link will create a link to the symbolic link itself instead of the\n      file the link points to.\n    src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n      platform.  If they are unavailable, using them will raise a\n      NotImplementedError.",
        "syntax": "Syntax: link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)",
        "other-params": ""
    },
    "os.listdir": {
        "function": "listdir(path=None)",
        "alias": "listdir",
        "help": "Help on built-in function listdir in module nt:\n\nlistdir(path=None)\n    Return a list containing the names of the files in the directory.\n\n    path can be specified as either str, bytes, or a path-like object.  If path is bytes,\n      the filenames returned will also be bytes; in all other circumstances\n      the filenames returned will be str.\n    If path is None, uses the path='.'.\n    On some platforms, path may also be specified as an open file descriptor;\\\n      the file descriptor must refer to a directory.\n      If this functionality is unavailable, using it raises NotImplementedError.\n\n    The list is in arbitrary order.  It does not include the special\n    entries '.' and '..' even if they are present in the directory.",
        "syntax": "Syntax: listdir(path=None)",
        "other-params": ""
    },
    "os.listdrives": {
        "function": "listdrives()",
        "alias": "listdrives",
        "help": "Help on built-in function listdrives in module nt:\n\nlistdrives()\n    Return a list containing the names of drives in the system.\n\n    A drive name typically looks like 'C:\\\\'.",
        "syntax": "Syntax: listdrives()",
        "other-params": ""
    },
    "os.listmounts": {
        "function": "listmounts(volume)",
        "alias": "listmounts",
        "help": "Help on built-in function listmounts in module nt:\n\nlistmounts(volume)\n    Return a list containing mount points for a particular volume.\n\n    'volume' should be a GUID path as returned from os.listvolumes.",
        "syntax": "Syntax: listmounts(volume)",
        "other-params": ""
    },
    "os.listvolumes": {
        "function": "listvolumes()",
        "alias": "listvolumes",
        "help": "Help on built-in function listvolumes in module nt:\n\nlistvolumes()\n    Return a list containing the volumes in the system.\n\n    Volumes are typically represented as a GUID path.",
        "syntax": "Syntax: listvolumes()",
        "other-params": ""
    },
    "os.lseek": {
        "function": "lseek(fd, position, whence, /)",
        "alias": "lseek",
        "help": "Help on built-in function lseek in module nt:\n\nlseek(fd, position, whence, /)\n    Set the position of a file descriptor.  Return the new position.\n\n      fd\n        An open file descriptor, as returned by os.open().\n      position\n        Position, interpreted relative to 'whence'.\n      whence\n        The relative position to seek from. Valid values are:\n        - SEEK_SET: seek from the start of the file.\n        - SEEK_CUR: seek from the current file position.\n        - SEEK_END: seek from the end of the file.\n\n    The return value is the number of bytes relative to the beginning of the file.",
        "syntax": "Syntax: lseek(fd, position, whence, /)",
        "other-params": ""
    },
    "os.lstat": {
        "function": "lstat(path, *, dir_fd=None)",
        "alias": "lstat",
        "help": "Help on built-in function lstat in module nt:\n\nlstat(path, *, dir_fd=None)\n    Perform a stat system call on the given path, without following symbolic links.\n\n    Like stat(), but do not follow symbolic links.\n    Equivalent to stat(path, follow_symlinks=False).",
        "syntax": "Syntax: lstat(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.makedirs": {
        "function": "makedirs(name, mode=511, exist_ok=False)",
        "alias": "makedirs",
        "help": "Help on function makedirs in module os:\n\nmakedirs(name, mode=511, exist_ok=False)\n    makedirs(name [, mode=0o777][, exist_ok=False])\n\n    Super-mkdir; create a leaf directory and all intermediate ones.  Works like\n    mkdir, except that any intermediate path segment (not just the rightmost)\n    will be created if it does not exist. If the target directory already\n    exists, raise an OSError if exist_ok is False. Otherwise no exception is\n    raised.  This is recursive.",
        "syntax": "Syntax: makedirs(name, mode=511, exist_ok=False)",
        "other-params": ""
    },
    "os.mkdir": {
        "function": "mkdir(path, mode=511, *, dir_fd=None)",
        "alias": "mkdir",
        "help": "Help on built-in function mkdir in module nt:\n\nmkdir(path, mode=511, *, dir_fd=None)\n    Create a directory.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\n\n    The mode argument is ignored on Windows. Where it is used, the current umask\n    value is first masked out.",
        "syntax": "Syntax: mkdir(path, mode=511, *, dir_fd=None)",
        "other-params": ""
    },
    "os.open": {
        "function": "open(path, flags, mode=511, *, dir_fd=None)",
        "alias": "open",
        "help": "Help on built-in function open in module nt:\n\nopen(path, flags, mode=511, *, dir_fd=None)\n    Open a file for low level IO.  Returns a file descriptor (integer).\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.",
        "syntax": "Syntax: open(path, flags, mode=511, *, dir_fd=None)",
        "other-params": ""
    },
    "os.pipe": {
        "function": "pipe()",
        "alias": "pipe",
        "help": "Help on built-in function pipe in module nt:\n\npipe()\n    Create a pipe.\n\n    Returns a tuple of two file descriptors:\n      (read_fd, write_fd)",
        "syntax": "Syntax: pipe()",
        "other-params": ""
    },
    "os.popen": {
        "function": "popen(cmd, mode='r', buffering=-1)",
        "alias": "popen",
        "help": "Help on function popen in module os:\n\npopen(cmd, mode='r', buffering=-1)",
        "syntax": "Syntax: popen(cmd, mode='r', buffering=-1)",
        "other-params": ""
    },
    "os.process_cpu_count": {
        "function": "process_cpu_count()",
        "alias": "process_cpu_count",
        "help": "Help on built-in function cpu_count in module nt:\n\ncpu_count()\n    Return the number of logical CPUs in the system.\n\n    Return None if indeterminable.",
        "syntax": "Syntax: process_cpu_count()",
        "other-params": ""
    },
    "os.putenv": {
        "function": "putenv(name, value, /)",
        "alias": "putenv",
        "help": "Help on built-in function putenv in module nt:\n\nputenv(name, value, /)\n    Change or add an environment variable.",
        "syntax": "Syntax: putenv(name, value, /)",
        "other-params": ""
    },
    "os.read": {
        "function": "read(fd, length, /)",
        "alias": "read",
        "help": "Help on built-in function read in module nt:\n\nread(fd, length, /)\n    Read from a file descriptor.  Returns a bytes object.",
        "syntax": "Syntax: read(fd, length, /)",
        "other-params": ""
    },
    "os.readlink": {
        "function": "readlink(path, *, dir_fd=None)",
        "alias": "readlink",
        "help": "Help on built-in function readlink in module nt:\n\nreadlink(path, *, dir_fd=None)\n    Return a string representing the path to which the symbolic link points.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that directory.\n\n    dir_fd may not be implemented on your platform.  If it is unavailable,\n    using it will raise a NotImplementedError.",
        "syntax": "Syntax: readlink(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.remove": {
        "function": "remove(path, *, dir_fd=None)",
        "alias": "remove",
        "help": "Help on built-in function remove in module nt:\n\nremove(path, *, dir_fd=None)\n    Remove a file (same as unlink()).\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.",
        "syntax": "Syntax: remove(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.removedirs": {
        "function": "removedirs(name)",
        "alias": "removedirs",
        "help": "Help on function removedirs in module os:\n\nremovedirs(name)\n    removedirs(name)\n\n    Super-rmdir; remove a leaf directory and all empty intermediate\n    ones.  Works like rmdir except that, if the leaf directory is\n    successfully removed, directories corresponding to rightmost path\n    segments will be pruned away until either the whole path is\n    consumed or an error occurs.  Errors during this latter phase are\n    ignored -- they generally mean that a directory was not empty.",
        "syntax": "Syntax: removedirs(name)",
        "other-params": ""
    },
    "os.rename": {
        "function": "rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)",
        "alias": "rename",
        "help": "Help on built-in function rename in module nt:\n\nrename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)\n    Rename a file or directory.\n\n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.",
        "syntax": "Syntax: rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)",
        "other-params": ""
    },
    "os.renames": {
        "function": "renames(old, new)",
        "alias": "renames",
        "help": "Help on function renames in module os:\n\nrenames(old, new)\n    renames(old, new)\n\n    Super-rename; create directories as necessary and delete any left\n    empty.  Works like rename, except creation of any intermediate\n    directories needed to make the new pathname good is attempted\n    first.  After the rename, directories corresponding to rightmost\n    path segments of the old name will be pruned until either the\n    whole path is consumed or a nonempty directory is found.\n\n    Note: this function can fail with the new directory structure made\n    if you lack permissions needed to unlink the leaf directory or\n    file.",
        "syntax": "Syntax: renames(old, new)",
        "other-params": ""
    },
    "os.replace": {
        "function": "replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)",
        "alias": "replace",
        "help": "Help on built-in function replace in module nt:\n\nreplace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)\n    Rename a file or directory, overwriting the destination.\n\n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.",
        "syntax": "Syntax: replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)",
        "other-params": ""
    },
    "os.rmdir": {
        "function": "rmdir(path, *, dir_fd=None)",
        "alias": "rmdir",
        "help": "Help on built-in function rmdir in module nt:\n\nrmdir(path, *, dir_fd=None)\n    Remove a directory.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.",
        "syntax": "Syntax: rmdir(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.scandir": {
        "function": "scandir(path=None)",
        "alias": "scandir",
        "help": "Help on built-in function scandir in module nt:\n\nscandir(path=None)\n    Return an iterator of DirEntry objects for given path.\n\n    path can be specified as either str, bytes, or a path-like object.  If path\n    is bytes, the names of yielded DirEntry objects will also be bytes; in\n    all other circumstances they will be str.\n\n    If path is None, uses the path='.'.",
        "syntax": "Syntax: scandir(path=None)",
        "other-params": ""
    },
    "os.set_blocking": {
        "function": "set_blocking(fd, blocking, /)",
        "alias": "set_blocking",
        "help": "Help on built-in function set_blocking in module nt:\n\nset_blocking(fd, blocking, /)\n    Set the blocking mode of the specified file descriptor.\n\n    Set the O_NONBLOCK flag if blocking is False,\n    clear the O_NONBLOCK flag otherwise.",
        "syntax": "Syntax: set_blocking(fd, blocking, /)",
        "other-params": ""
    },
    "os.set_handle_inheritable": {
        "function": "set_handle_inheritable(handle, inheritable, /)",
        "alias": "set_handle_inheritable",
        "help": "Help on built-in function set_handle_inheritable in module nt:\n\nset_handle_inheritable(handle, inheritable, /)\n    Set the inheritable flag of the specified handle.",
        "syntax": "Syntax: set_handle_inheritable(handle, inheritable, /)",
        "other-params": ""
    },
    "os.set_inheritable": {
        "function": "set_inheritable(fd, inheritable, /)",
        "alias": "set_inheritable",
        "help": "Help on built-in function set_inheritable in module nt:\n\nset_inheritable(fd, inheritable, /)\n    Set the inheritable flag of the specified file descriptor.",
        "syntax": "Syntax: set_inheritable(fd, inheritable, /)",
        "other-params": ""
    },
    "os.spawnl": {
        "function": "spawnl(mode, file, *args)",
        "alias": "spawnl",
        "help": "Help on function spawnl in module os:\n\nspawnl(mode, file, *args)\n    spawnl(mode, file, *args) -> integer\n\n    Execute file with arguments from args in a subprocess.\n    If mode == P_NOWAIT return the pid of the process.\n    If mode == P_WAIT return the process's exit code if it exits normally;\n    otherwise return -SIG, where SIG is the signal that killed it.",
        "syntax": "Syntax: spawnl(mode, file, *args)",
        "other-params": ""
    },
    "os.spawnle": {
        "function": "spawnle(mode, file, *args)",
        "alias": "spawnle",
        "help": "Help on function spawnle in module os:\n\nspawnle(mode, file, *args)\n    spawnle(mode, file, *args, env) -> integer\n\n    Execute file with arguments from args in a subprocess with the\n    supplied environment.\n    If mode == P_NOWAIT return the pid of the process.\n    If mode == P_WAIT return the process's exit code if it exits normally;\n    otherwise return -SIG, where SIG is the signal that killed it.",
        "syntax": "Syntax: spawnle(mode, file, *args)",
        "other-params": ""
    },
    "os.spawnv": {
        "function": "spawnv(mode, path, argv, /)",
        "alias": "spawnv",
        "help": "Help on built-in function spawnv in module nt:\n\nspawnv(mode, path, argv, /)\n    Execute the program specified by path in a new process.\n\n    mode\n      Mode of process creation.\n    path\n      Path of executable file.\n    argv\n      Tuple or list of strings.",
        "syntax": "Syntax: spawnv(mode, path, argv, /)",
        "other-params": ""
    },
    "os.spawnve": {
        "function": "spawnve(mode, path, argv, env, /)",
        "alias": "spawnve",
        "help": "Help on built-in function spawnve in module nt:\n\nspawnve(mode, path, argv, env, /)\n    Execute the program specified by path in a new process.\n\n    mode\n      Mode of process creation.\n    path\n      Path of executable file.\n    argv\n      Tuple or list of strings.\n    env\n      Dictionary of strings mapping to strings.",
        "syntax": "Syntax: spawnve(mode, path, argv, env, /)",
        "other-params": ""
    },
    "os.startfile": {
        "function": "Error retrieving signature: <built-in function startfile> builtin has invalid signature",
        "alias": "startfile",
        "help": "Help on built-in function startfile in module nt:\n\nstartfile(filepath, operation=<unrepresentable>,\n          arguments=<unrepresentable>, cwd=None, show_cmd=1)\n    Start a file with its associated application.\n\n    When \"operation\" is not specified or \"open\", this acts like\n    double-clicking the file in Explorer, or giving the file name as an\n    argument to the DOS \"start\" command: the file is opened with whatever\n    application (if any) its extension is associated.\n    When another \"operation\" is given, it specifies what should be done with\n    the file.  A typical operation is \"print\".\n\n    \"arguments\" is passed to the application, but should be omitted if the\n    file is a document.\n\n    \"cwd\" is the working directory for the operation. If \"filepath\" is\n    relative, it will be resolved against this directory. This argument\n    should usually be an absolute path.\n\n    \"show_cmd\" can be used to override the recommended visibility option.\n    See the Windows ShellExecute documentation for values.\n\n    startfile returns as soon as the associated application is launched.\n    There is no option to wait for the application to close, and no way\n    to retrieve the application's exit status.\n\n    The filepath is relative to the current directory.  If you want to use\n    an absolute path, make sure the first character is not a slash (\"/\");\n    the underlying Win32 ShellExecute function doesn't work if it is.",
        "syntax": "Syntax: Error retrieving signature: <built-in function startfile> builtin has invalid signature",
        "other-params": ""
    },
    "os.stat": {
        "function": "stat(path, *, dir_fd=None, follow_symlinks=True)",
        "alias": "stat",
        "help": "Help on built-in function stat in module nt:\n\nstat(path, *, dir_fd=None, follow_symlinks=True)\n    Perform a stat system call on the given path.\n\n      path\n        Path to be examined; can be string, bytes, a path-like object or\n        open-file-descriptor int.\n      dir_fd\n        If not None, it should be a file descriptor open to a directory,\n        and path should be a relative string; path will then be relative to\n        that directory.\n      follow_symlinks\n        If False, and the last element of the path is a symbolic link,\n        stat will examine the symbolic link itself instead of the file\n        the link points to.\n\n    dir_fd and follow_symlinks may not be implemented\n      on your platform.  If they are unavailable, using them will raise a\n      NotImplementedError.\n\n    It's an error to use dir_fd or follow_symlinks when specifying path as\n      an open file descriptor.",
        "syntax": "Syntax: stat(path, *, dir_fd=None, follow_symlinks=True)",
        "other-params": ""
    },
    "os.stat_result": {
        "function": "stat_result(iterable=(), /)",
        "alias": "stat_result",
        "help": "Help on class stat_result in module os:\n\nclass stat_result(builtins.tuple)\n |  stat_result(iterable=(), /)\n |\n |  stat_result: Result from stat, fstat, or lstat.\n |\n |  This object may be accessed either as a tuple of\n |    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\n |  or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n |\n |  Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\n |  or st_flags, they are available as attributes only.\n |\n |  See os.stat for more information.\n |\n |  Method resolution order:\n |      stat_result\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the structure with new values for the specified fields.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  st_atime\n |      time of last access\n |\n |  st_atime_ns\n |      time of last access in nanoseconds\n |\n |  st_birthtime\n |      time of creation\n |\n |  st_birthtime_ns\n |      time of creation in nanoseconds\n |\n |  st_ctime\n |      time of last change\n |\n |  st_ctime_ns\n |      time of last change in nanoseconds\n |\n |  st_dev\n |      device\n |\n |  st_file_attributes\n |      Windows file attribute bits\n |\n |  st_gid\n |      group ID of owner\n |\n |  st_ino\n |      inode\n |\n |  st_mode\n |      protection bits\n |\n |  st_mtime\n |      time of last modification\n |\n |  st_mtime_ns\n |      time of last modification in nanoseconds\n |\n |  st_nlink\n |      number of hard links\n |\n |  st_reparse_tag\n |      Windows reparse tag\n |\n |  st_size\n |      total size, in bytes\n |\n |  st_uid\n |      user ID of owner\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('st_mode', 'st_ino', 'st_dev', 'st_nlink', 'st_uid',...\n |\n |  n_fields = 20\n |\n |  n_sequence_fields = 10\n |\n |  n_unnamed_fields = 3\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: stat_result(iterable=(), /)",
        "other-params": ""
    },
    "os.statvfs_result": {
        "function": "statvfs_result(iterable=(), /)",
        "alias": "statvfs_result",
        "help": "Help on class statvfs_result in module os:\n\nclass statvfs_result(builtins.tuple)\n |  statvfs_result(iterable=(), /)\n |\n |  statvfs_result: Result from statvfs or fstatvfs.\n |\n |  This object may be accessed either as a tuple of\n |    (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\n |  or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n |\n |  See os.statvfs for more information.\n |\n |  Method resolution order:\n |      statvfs_result\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the structure with new values for the specified fields.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  f_bavail\n |\n |  f_bfree\n |\n |  f_blocks\n |\n |  f_bsize\n |\n |  f_favail\n |\n |  f_ffree\n |\n |  f_files\n |\n |  f_flag\n |\n |  f_frsize\n |\n |  f_fsid\n |\n |  f_namemax\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('f_bsize', 'f_frsize', 'f_blocks', 'f_bfree', 'f_bav...\n |\n |  n_fields = 11\n |\n |  n_sequence_fields = 10\n |\n |  n_unnamed_fields = 0\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: statvfs_result(iterable=(), /)",
        "other-params": ""
    },
    "os.strerror": {
        "function": "strerror(code, /)",
        "alias": "strerror",
        "help": "Help on built-in function strerror in module nt:\n\nstrerror(code, /)\n    Translate an error code to a message string.",
        "syntax": "Syntax: strerror(code, /)",
        "other-params": ""
    },
    "os.symlink": {
        "function": "symlink(src, dst, target_is_directory=False, *, dir_fd=None)",
        "alias": "symlink",
        "help": "Help on built-in function symlink in module nt:\n\nsymlink(src, dst, target_is_directory=False, *, dir_fd=None)\n    Create a symbolic link pointing to src named dst.\n\n    target_is_directory is required on Windows if the target is to be\n      interpreted as a directory.  (On Windows, symlink requires\n      Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n      target_is_directory is ignored on non-Windows platforms.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.",
        "syntax": "Syntax: symlink(src, dst, target_is_directory=False, *, dir_fd=None)",
        "other-params": ""
    },
    "os.system": {
        "function": "system(command)",
        "alias": "system",
        "help": "Help on built-in function system in module nt:\n\nsystem(command)\n    Execute the command in a subshell.",
        "syntax": "Syntax: system(command)",
        "other-params": ""
    },
    "os.terminal_size": {
        "function": "terminal_size(iterable=(), /)",
        "alias": "terminal_size",
        "help": "Help on class terminal_size in module os:\n\nclass terminal_size(builtins.tuple)\n |  terminal_size(iterable=(), /)\n |\n |  A tuple of (columns, lines) for holding terminal window size\n |\n |  Method resolution order:\n |      terminal_size\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the structure with new values for the specified fields.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  columns\n |      width of the terminal window in characters\n |\n |  lines\n |      height of the terminal window in characters\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('columns', 'lines')\n |\n |  n_fields = 2\n |\n |  n_sequence_fields = 2\n |\n |  n_unnamed_fields = 0\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: terminal_size(iterable=(), /)",
        "other-params": ""
    },
    "os.times": {
        "function": "times()",
        "alias": "times",
        "help": "Help on built-in function times in module nt:\n\ntimes()\n    Return a collection containing process timing information.\n\n    The object returned behaves like a named tuple with these fields:\n      (utime, stime, cutime, cstime, elapsed_time)\n    All fields are floating-point numbers.",
        "syntax": "Syntax: times()",
        "other-params": ""
    },
    "os.times_result": {
        "function": "times_result(iterable=(), /)",
        "alias": "times_result",
        "help": "Help on class times_result in module nt:\n\nclass times_result(builtins.tuple)\n |  times_result(iterable=(), /)\n |\n |  times_result: Result from os.times().\n |\n |  This object may be accessed either as a tuple of\n |    (user, system, children_user, children_system, elapsed),\n |  or via the attributes user, system, children_user, children_system,\n |  and elapsed.\n |\n |  See os.times for more information.\n |\n |  Method resolution order:\n |      times_result\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the structure with new values for the specified fields.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  children_system\n |      system time of children\n |\n |  children_user\n |      user time of children\n |\n |  elapsed\n |      elapsed time since an arbitrary point in the past\n |\n |  system\n |      system time\n |\n |  user\n |      user time\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('user', 'system', 'children_user', 'children_system'...\n |\n |  n_fields = 5\n |\n |  n_sequence_fields = 5\n |\n |  n_unnamed_fields = 0\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: times_result(iterable=(), /)",
        "other-params": ""
    },
    "os.truncate": {
        "function": "truncate(path, length)",
        "alias": "truncate",
        "help": "Help on built-in function truncate in module nt:\n\ntruncate(path, length)\n    Truncate a file, specified by path, to a specific length.\n\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.",
        "syntax": "Syntax: truncate(path, length)",
        "other-params": ""
    },
    "os.umask": {
        "function": "umask(mask, /)",
        "alias": "umask",
        "help": "Help on built-in function umask in module nt:\n\numask(mask, /)\n    Set the current numeric umask and return the previous umask.",
        "syntax": "Syntax: umask(mask, /)",
        "other-params": ""
    },
    "os.uname_result": {
        "function": "uname_result(iterable=(), /)",
        "alias": "uname_result",
        "help": "Help on class uname_result in module nt:\n\nclass uname_result(builtins.tuple)\n |  uname_result(iterable=(), /)\n |\n |  uname_result: Result from os.uname().\n |\n |  This object may be accessed either as a tuple of\n |    (sysname, nodename, release, version, machine),\n |  or via the attributes sysname, nodename, release, version, and machine.\n |\n |  See os.uname for more information.\n |\n |  Method resolution order:\n |      uname_result\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the structure with new values for the specified fields.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  machine\n |      hardware identifier\n |\n |  nodename\n |      name of machine on network (implementation-defined)\n |\n |  release\n |      operating system release\n |\n |  sysname\n |      operating system name\n |\n |  version\n |      operating system version\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('sysname', 'nodename', 'release', 'version', 'machin...\n |\n |  n_fields = 5\n |\n |  n_sequence_fields = 5\n |\n |  n_unnamed_fields = 0\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: uname_result(iterable=(), /)",
        "other-params": ""
    },
    "os.unlink": {
        "function": "unlink(path, *, dir_fd=None)",
        "alias": "unlink",
        "help": "Help on built-in function unlink in module nt:\n\nunlink(path, *, dir_fd=None)\n    Remove a file (same as remove()).\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.",
        "syntax": "Syntax: unlink(path, *, dir_fd=None)",
        "other-params": ""
    },
    "os.unsetenv": {
        "function": "unsetenv(name, /)",
        "alias": "unsetenv",
        "help": "Help on built-in function unsetenv in module nt:\n\nunsetenv(name, /)\n    Delete an environment variable.",
        "syntax": "Syntax: unsetenv(name, /)",
        "other-params": ""
    },
    "os.urandom": {
        "function": "urandom(size, /)",
        "alias": "urandom",
        "help": "Help on built-in function urandom in module nt:\n\nurandom(size, /)\n    Return a bytes object containing random bytes suitable for cryptographic use.",
        "syntax": "Syntax: urandom(size, /)",
        "other-params": ""
    },
    "os.utime": {
        "function": "Error retrieving signature: <built-in function utime> builtin has invalid signature",
        "alias": "utime",
        "help": "Help on built-in function utime in module nt:\n\nutime(path, times=None, *, ns=<unrepresentable>,\n      dir_fd=None, follow_symlinks=True)\n    Set the access and modified time of path.\n\n    path may always be specified as a string.\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.\n\n    If times is not None, it must be a tuple (atime, mtime);\n        atime and mtime should be expressed as float seconds since the epoch.\n    If ns is specified, it must be a tuple (atime_ns, mtime_ns);\n        atime_ns and mtime_ns should be expressed as integer nanoseconds\n        since the epoch.\n    If times is None and ns is unspecified, utime uses the current time.\n    Specifying tuples for both times and ns is an error.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    If follow_symlinks is False, and the last element of the path is a symbolic\n      link, utime will modify the symbolic link itself instead of the file the\n      link points to.\n    It is an error to use dir_fd or follow_symlinks when specifying path\n      as an open file descriptor.\n    dir_fd and follow_symlinks may not be available on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.",
        "syntax": "Syntax: Error retrieving signature: <built-in function utime> builtin has invalid signature",
        "other-params": ""
    },
    "os.waitpid": {
        "function": "waitpid(pid, options, /)",
        "alias": "waitpid",
        "help": "Help on built-in function waitpid in module nt:\n\nwaitpid(pid, options, /)\n    Wait for completion of a given process.\n\n    Returns a tuple of information regarding the process:\n        (pid, status << 8)\n\n    The options argument is ignored on Windows.",
        "syntax": "Syntax: waitpid(pid, options, /)",
        "other-params": ""
    },
    "os.waitstatus_to_exitcode": {
        "function": "waitstatus_to_exitcode(status)",
        "alias": "waitstatus_to_exitcode",
        "help": "Help on built-in function waitstatus_to_exitcode in module nt:\n\nwaitstatus_to_exitcode(status)\n    Convert a wait status to an exit code.\n\n    On Unix:\n\n    * If WIFEXITED(status) is true, return WEXITSTATUS(status).\n    * If WIFSIGNALED(status) is true, return -WTERMSIG(status).\n    * Otherwise, raise a ValueError.\n\n    On Windows, return status shifted right by 8 bits.\n\n    On Unix, if the process is being traced or if waitpid() was called with\n    WUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\n    This function must not be called if WIFSTOPPED(status) is true.",
        "syntax": "Syntax: waitstatus_to_exitcode(status)",
        "other-params": ""
    },
    "os.walk": {
        "function": "walk(top, topdown=True, onerror=None, followlinks=False)",
        "alias": "walk",
        "help": "Help on function walk in module os:\n\nwalk(top, topdown=True, onerror=None, followlinks=False)\n    Directory tree generator.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), yields a 3-tuple\n\n        dirpath, dirnames, filenames\n\n    dirpath is a string, the path to the directory.  dirnames is a list of\n    the names of the subdirectories in dirpath (including symlinks to directories,\n    and excluding '.' and '..').\n    filenames is a list of the names of the non-directory files in dirpath.\n    Note that the names in the lists are just names, with no path components.\n    To get a full path (which begins with top) to a file or directory in\n    dirpath, do os.path.join(dirpath, name).\n\n    If optional arg 'topdown' is true or not specified, the triple for a\n    directory is generated before the triples for any of its subdirectories\n    (directories are generated top down).  If topdown is false, the triple\n    for a directory is generated after the triples for all of its\n    subdirectories (directories are generated bottom up).\n\n    When topdown is true, the caller can modify the dirnames list in-place\n    (e.g., via del or slice assignment), and walk will only recurse into the\n    subdirectories whose names remain in dirnames; this can be used to prune the\n    search, or to impose a specific order of visiting.  Modifying dirnames when\n    topdown is false has no effect on the behavior of os.walk(), since the\n    directories in dirnames have already been generated by the time dirnames\n    itself is generated. No matter the value of topdown, the list of\n    subdirectories is retrieved before the tuples for the directory and its\n    subdirectories are generated.\n\n    By default errors from the os.scandir() call are ignored.  If\n    optional arg 'onerror' is specified, it should be a function; it\n    will be called with one argument, an OSError instance.  It can\n    report the error to continue with the walk, or raise the exception\n    to abort the walk.  Note that the filename is available as the\n    filename attribute of the exception object.\n\n    By default, os.walk does not follow symbolic links to subdirectories on\n    systems that support them.  In order to get this functionality, set the\n    optional argument 'followlinks' to true.\n\n    Caution:  if you pass a relative pathname for top, don't change the\n    current working directory between resumptions of walk.  walk never\n    changes the current directory, and assumes that the client doesn't\n    either.\n\n    Example:\n\n    import os\n    from os.path import join, getsize\n    for root, dirs, files in os.walk('python/Lib/email'):\n        print(root, \"consumes \")\n        print(sum(getsize(join(root, name)) for name in files), end=\" \")\n        print(\"bytes in\", len(files), \"non-directory files\")\n        if 'CVS' in dirs:\n            dirs.remove('CVS')  # don't visit CVS directories",
        "syntax": "Syntax: walk(top, topdown=True, onerror=None, followlinks=False)",
        "other-params": ""
    },
    "os.write": {
        "function": "write(fd, data, /)",
        "alias": "write",
        "help": "Help on built-in function write in module nt:\n\nwrite(fd, data, /)\n    Write a bytes object to a file descriptor.",
        "syntax": "Syntax: write(fd, data, /)",
        "other-params": ""
    },
    "_sitebuiltins.Quitter": {
        "function": "Quitter(name, eof)",
        "alias": "Quitter",
        "help": "Help on class Quitter in module _sitebuiltins:\n\nclass Quitter(builtins.object)\n |  Quitter(name, eof)\n |\n |  Methods defined here:\n |\n |  __call__(self, code=None)\n |      Call self as a function.\n |\n |  __init__(self, name, eof)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Quitter(name, eof)",
        "other-params": ""
    },
    "_sitebuiltins._Helper": {
        "function": "_Helper()",
        "alias": "_Helper",
        "help": "Help on class _Helper in module _sitebuiltins:\n\nclass _Helper(builtins.object)\n |  Define the builtin 'help'.\n |\n |  This is a wrapper around pydoc.help that provides a helpful message\n |  when 'help' is typed at the Python interactive prompt.\n |\n |  Calling help() at the Python prompt starts an interactive help session.\n |  Calling help(thing) prints help for the python object 'thing'.\n |\n |  Methods defined here:\n |\n |  __call__(self, *args, **kwds)\n |      Call self as a function.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _Helper()",
        "other-params": ""
    },
    "_sitebuiltins._Printer": {
        "function": "_Printer(name, data, files=(), dirs=())",
        "alias": "_Printer",
        "help": "Help on class _Printer in module _sitebuiltins:\n\nclass _Printer(builtins.object)\n |  _Printer(name, data, files=(), dirs=())\n |\n |  interactive prompt objects for printing the license text, a list of\n |  contributors and the copyright notice.\n |\n |  Methods defined here:\n |\n |  __call__(self)\n |      Call self as a function.\n |\n |  __init__(self, name, data, files=(), dirs=())\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  MAXLINES = 23",
        "syntax": "Syntax: _Printer(name, data, files=(), dirs=())",
        "other-params": ""
    },
    "encodings.utf_8_sig.IncrementalDecoder": {
        "function": "IncrementalDecoder(errors='strict')",
        "alias": "IncrementalDecoder",
        "help": "Help on class IncrementalDecoder in module encodings.utf_8_sig:\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder)\n |  IncrementalDecoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalDecoder\n |      codecs.BufferedIncrementalDecoder\n |      codecs.IncrementalDecoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Create an IncrementalDecoder instance.\n |\n |      The IncrementalDecoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  getstate(self)\n |      Return the current state of the decoder.\n |\n |      This must be a (buffered_input, additional_state_info) tuple.\n |      buffered_input must be a bytes object containing bytes that\n |      were passed to decode() that have not yet been converted.\n |      additional_state_info must be a non-negative integer\n |      representing the state of the decoder WITHOUT yet having\n |      processed the contents of buffered_input.  In the initial state\n |      and after reset(), getstate() must return (b\"\", 0).\n |\n |  reset(self)\n |      Reset the decoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the decoder.\n |\n |      state must have been returned by getstate().  The effect of\n |      setstate((b\"\", 0)) must be equivalent to reset().\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.BufferedIncrementalDecoder:\n |\n |  decode(self, input, final=False)\n |      Decode input and returns the resulting object.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalDecoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalDecoder(errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.IncrementalEncoder": {
        "function": "IncrementalEncoder(errors='strict')",
        "alias": "IncrementalEncoder",
        "help": "Help on class IncrementalEncoder in module encodings.utf_8_sig:\n\nclass IncrementalEncoder(codecs.IncrementalEncoder)\n |  IncrementalEncoder(errors='strict')\n |\n |  Method resolution order:\n |      IncrementalEncoder\n |      codecs.IncrementalEncoder\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, errors='strict')\n |      Creates an IncrementalEncoder instance.\n |\n |      The IncrementalEncoder may use different error handling schemes by\n |      providing the errors keyword argument. See the module docstring\n |      for a list of possible values.\n |\n |  encode(self, input, final=False)\n |      Encodes input and returns the resulting object.\n |\n |  getstate(self)\n |      Return the current state of the encoder.\n |\n |  reset(self)\n |      Resets the encoder to the initial state.\n |\n |  setstate(self, state)\n |      Set the current state of the encoder. state must have been\n |      returned by getstate().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.IncrementalEncoder:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: IncrementalEncoder(errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.StreamReader": {
        "function": "StreamReader(stream, errors='strict')",
        "alias": "StreamReader",
        "help": "Help on class StreamReader in module encodings.utf_8_sig:\n\nclass StreamReader(codecs.StreamReader)\n |  StreamReader(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamReader\n |      codecs.StreamReader\n |      codecs.Codec\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Note that no stream repositioning should take place.\n |      This method is primarily intended to be able to recover\n |      from decoding errors.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamReader:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamReader instance.\n |\n |      stream must be a file-like object open for reading.\n |\n |      The StreamReader may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'backslashreplace' - Replace with backslashed escape sequences;\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next decoded line from the input stream.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  read(self, size=-1, chars=-1, firstline=False)\n |      Decodes data from the stream self.stream and returns the\n |      resulting object.\n |\n |      chars indicates the number of decoded code points or bytes to\n |      return. read() will never return more data than requested,\n |      but it might return less, if there is not enough available.\n |\n |      size indicates the approximate maximum number of decoded\n |      bytes or code points to read for decoding. The decoder\n |      can modify this setting as appropriate. The default value\n |      -1 indicates to read and decode as much as possible.  size\n |      is intended to prevent having to decode huge files in one\n |      step.\n |\n |      If firstline is true, and a UnicodeDecodeError happens\n |      after the first line terminator in the input only the first line\n |      will be returned, the rest of the input will be kept until the\n |      next call to read().\n |\n |      The method should use a greedy read strategy, meaning that\n |      it should read as much data as is allowed within the\n |      definition of the encoding and the given size, e.g.  if\n |      optional encoding endings or state markers are available\n |      on the stream, these should be read too.\n |\n |  readline(self, size=None, keepends=True)\n |      Read one line from the input stream and return the\n |      decoded data.\n |\n |      size, if given, is passed as size argument to the\n |      read() method.\n |\n |  readlines(self, sizehint=None, keepends=True)\n |      Read all lines available on the input stream\n |      and return them as a list.\n |\n |      Line breaks are implemented using the codec's decoder\n |      method and are included in the list entries.\n |\n |      sizehint, if given, is ignored since there is no efficient\n |      way to finding the true end-of-line.\n |\n |  seek(self, offset, whence=0)\n |      Set the input stream's current position.\n |\n |      Resets the codec buffers used for keeping state.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from codecs.StreamReader:\n |\n |  charbuffertype = <class 'str'>\n |      str(object='') -> str\n |      str(bytes_or_buffer[, encoding[, errors]]) -> str\n |\n |      Create a new string object from the given object. If encoding or\n |      errors is specified, then the object must expose a data buffer\n |      that will be decoded using the given encoding and error handler.\n |      Otherwise, returns the result of object.__str__() (if defined)\n |      or repr(object).\n |      encoding defaults to 'utf-8'.\n |      errors defaults to 'strict'.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.Codec:\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamReader(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.StreamWriter": {
        "function": "StreamWriter(stream, errors='strict')",
        "alias": "StreamWriter",
        "help": "Help on class StreamWriter in module encodings.utf_8_sig:\n\nclass StreamWriter(codecs.StreamWriter)\n |  StreamWriter(stream, errors='strict')\n |\n |  Method resolution order:\n |      StreamWriter\n |      codecs.StreamWriter\n |      codecs.Codec\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  encode(self, input, errors='strict')\n |      Encodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamWriter for codecs which have to keep state in order to\n |      make encoding efficient.\n |\n |      The encoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  reset(self)\n |      Resets the codec buffers used for keeping internal state.\n |\n |      Calling this method should ensure that the data on the\n |      output is put into a clean state, that allows appending\n |      of new fresh data without having to rescan the whole\n |      stream to recover state.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.StreamWriter:\n |\n |  __enter__(self)\n |\n |  __exit__(self, type, value, tb)\n |\n |  __getattr__(self, name, getattr=<built-in function getattr>)\n |      Inherit all other methods from the underlying stream.\n |\n |  __init__(self, stream, errors='strict')\n |      Creates a StreamWriter instance.\n |\n |      stream must be a file-like object open for writing.\n |\n |      The StreamWriter may use different error handling\n |      schemes by providing the errors keyword argument. These\n |      parameters are predefined:\n |\n |       'strict' - raise a ValueError (or a subclass)\n |       'ignore' - ignore the character and continue with the next\n |       'replace'- replace with a suitable replacement character\n |       'xmlcharrefreplace' - Replace with the appropriate XML\n |                             character reference.\n |       'backslashreplace'  - Replace with backslashed escape\n |                             sequences.\n |       'namereplace'       - Replace with \\N{...} escape sequences.\n |\n |      The set of allowed parameter values can be extended via\n |      register_error.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  seek(self, offset, whence=0)\n |\n |  write(self, object)\n |      Writes the object's contents encoded to self.stream.\n |\n |  writelines(self, list)\n |      Writes the concatenated list of strings to the stream\n |      using .write().\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from codecs.Codec:\n |\n |  decode(self, input, errors='strict')\n |      Decodes the object input and returns a tuple (output\n |      object, length consumed).\n |\n |      input must be an object which provides the bf_getreadbuf\n |      buffer slot. Python strings, buffer objects and memory\n |      mapped files are examples of objects providing this slot.\n |\n |      errors defines the error handling to apply. It defaults to\n |      'strict' handling.\n |\n |      The method may not store state in the Codec instance. Use\n |      StreamReader for codecs which have to keep state in order to\n |      make decoding efficient.\n |\n |      The decoder must be able to handle zero length input and\n |      return an empty object of the output object type in this\n |      situation.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from codecs.Codec:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: StreamWriter(stream, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.decode": {
        "function": "decode(input, errors='strict')",
        "alias": "decode",
        "help": "Help on function decode in module encodings.utf_8_sig:\n\ndecode(input, errors='strict')",
        "syntax": "Syntax: decode(input, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.encode": {
        "function": "encode(input, errors='strict')",
        "alias": "encode",
        "help": "Help on function encode in module encodings.utf_8_sig:\n\nencode(input, errors='strict')",
        "syntax": "Syntax: encode(input, errors='strict')",
        "other-params": ""
    },
    "encodings.utf_8_sig.getregentry": {
        "function": "getregentry()",
        "alias": "getregentry",
        "help": "Help on function getregentry in module encodings.utf_8_sig:\n\ngetregentry()",
        "syntax": "Syntax: getregentry()",
        "other-params": ""
    },
    "__future__._Feature": {
        "function": "_Feature(optionalRelease, mandatoryRelease, compiler_flag)",
        "alias": "_Feature",
        "help": "Help on class _Feature in module __future__:\n\nclass _Feature(builtins.object)\n |  _Feature(optionalRelease, mandatoryRelease, compiler_flag)\n |\n |  Methods defined here:\n |\n |  __init__(self, optionalRelease, mandatoryRelease, compiler_flag)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  getMandatoryRelease(self)\n |      Return release in which this feature will become mandatory.\n |\n |      This is a 5-tuple, of the same form as sys.version_info, or, if\n |      the feature was dropped, or the release date is undetermined, is None.\n |\n |  getOptionalRelease(self)\n |      Return first release in which this feature was recognized.\n |\n |      This is a 5-tuple, of the same form as sys.version_info.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _Feature(optionalRelease, mandatoryRelease, compiler_flag)",
        "other-params": ""
    },
    "importlib._bootstrap.BuiltinImporter": {
        "function": "BuiltinImporter()",
        "alias": "BuiltinImporter",
        "help": "Help on class BuiltinImporter in module importlib._bootstrap:\n\nclass BuiltinImporter(builtins.object)\n |  Meta path import for built-in modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return None as built-in modules do not have code objects.\n |\n |  get_source(fullname)\n |      Return None as built-in modules do not have source code.\n |\n |  is_package(fullname)\n |      Return False as built-in modules are never packages.\n |\n |  load_module = _load_module_shim(fullname) from _frozen_importlib\n |      Load the specified module into sys.modules and return it.\n |\n |      This method is deprecated.  Use loader.exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Create a built-in module\n |\n |  exec_module(module)\n |      Exec a built-in module\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: BuiltinImporter()",
        "other-params": ""
    },
    "importlib._bootstrap.FrozenImporter": {
        "function": "FrozenImporter()",
        "alias": "FrozenImporter",
        "help": "Help on class FrozenImporter in module importlib._bootstrap:\n\nclass FrozenImporter(builtins.object)\n |  Meta path import for frozen modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return the code object for the frozen module.\n |\n |  get_source(fullname)\n |      Return None as frozen modules do not have source code.\n |\n |  is_package(fullname)\n |      Return True if the frozen module is a package.\n |\n |  load_module(fullname)\n |      Load a frozen module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Set __file__, if able.\n |\n |  exec_module(module)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FrozenImporter()",
        "other-params": ""
    },
    "importlib._bootstrap.ModuleSpec": {
        "function": "ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "alias": "ModuleSpec",
        "help": "Help on class ModuleSpec in module importlib._bootstrap:\n\nclass ModuleSpec(builtins.object)\n |  ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)\n |\n |  The specification for a module, used for loading.\n |\n |  A module's spec is the source for information about the module.  For\n |  data associated with the module, including source, use the spec's\n |  loader.\n |\n |  `name` is the absolute name of the module.  `loader` is the loader\n |  to use when loading the module.  `parent` is the name of the\n |  package the module is in.  The parent is derived from the name.\n |\n |  `is_package` determines if the module is considered a package or\n |  not.  On modules this is reflected by the `__path__` attribute.\n |\n |  `origin` is the specific location used by the loader from which to\n |  load the module, if that information is available.  When filename is\n |  set, origin will match.\n |\n |  `has_location` indicates that a spec's \"origin\" reflects a location.\n |  When this is True, `__file__` attribute of the module is set.\n |\n |  `cached` is the location of the cached bytecode file, if any.  It\n |  corresponds to the `__cached__` attribute.\n |\n |  `submodule_search_locations` is the sequence of path entries to\n |  search when importing submodules.  If set, is_package should be\n |  True--and False otherwise.\n |\n |  Packages are simply modules that (may) have submodules.  If a spec\n |  has a non-None value in `submodule_search_locations`, the import\n |  system will consider modules loaded from the spec as packages.\n |\n |  Only finders (see importlib.abc.MetaPathFinder and\n |  importlib.abc.PathEntryFinder) should modify ModuleSpec instances.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __init__(self, name, loader, *, origin=None, loader_state=None, is_package=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  parent\n |      The name of the module's parent.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  cached\n |\n |  has_location\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "other-params": ""
    },
    "importlib._bootstrap._BlockingOnManager": {
        "function": "_BlockingOnManager(thread_id, lock)",
        "alias": "_BlockingOnManager",
        "help": "Help on class _BlockingOnManager in module importlib._bootstrap:\n\nclass _BlockingOnManager(builtins.object)\n |  _BlockingOnManager(thread_id, lock)\n |\n |  A context manager responsible to updating ``_blocking_on``.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Mark the running thread as waiting for self.lock. via _blocking_on.\n |\n |  __exit__(self, *args, **kwargs)\n |      Remove self.lock from this thread's _blocking_on list.\n |\n |  __init__(self, thread_id, lock)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _BlockingOnManager(thread_id, lock)",
        "other-params": ""
    },
    "importlib._bootstrap._DeadlockError": {
        "function": "Error retrieving signature: no signature found for builtin type <class '_frozen_importlib._DeadlockError'>",
        "alias": "_DeadlockError",
        "help": "Help on class _DeadlockError in module importlib._bootstrap:\n\nclass _DeadlockError(builtins.RuntimeError)\n |  Method resolution order:\n |      _DeadlockError\n |      builtins.RuntimeError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.RuntimeError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.RuntimeError:\n |\n |  __new__(*args, **kwargs) class method of builtins.RuntimeError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class '_frozen_importlib._DeadlockError'>",
        "other-params": ""
    },
    "importlib._bootstrap._DummyModuleLock": {
        "function": "_DummyModuleLock(name)",
        "alias": "_DummyModuleLock",
        "help": "Help on class _DummyModuleLock in module importlib._bootstrap:\n\nclass _DummyModuleLock(builtins.object)\n |  _DummyModuleLock(name)\n |\n |  A simple _ModuleLock equivalent for Python builds without\n |  multi-threading support.\n |\n |  Methods defined here:\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  acquire(self)\n |\n |  release(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _DummyModuleLock(name)",
        "other-params": ""
    },
    "importlib._bootstrap._ImportLockContext": {
        "function": "_ImportLockContext()",
        "alias": "_ImportLockContext",
        "help": "Help on class _ImportLockContext in module importlib._bootstrap:\n\nclass _ImportLockContext(builtins.object)\n |  Context manager for the import lock.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Acquire the import lock.\n |\n |  __exit__(self, exc_type, exc_value, exc_traceback)\n |      Release the import lock regardless of any raised exceptions.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ImportLockContext()",
        "other-params": ""
    },
    "importlib._bootstrap._List": {
        "function": "_List(iterable=(), /)",
        "alias": "_List",
        "help": "Help on class _List in module importlib._bootstrap:\n\nclass _List(builtins.list)\n |  _List(iterable=(), /)\n |\n |  # For a list that can have a weakref to it.\n |\n |  Method resolution order:\n |      _List\n |      builtins.list\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.list:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, index, /)\n |      Return self[index].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |\n |  __imul__(self, value, /)\n |      Implement self*=value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the list.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the list in memory, in bytes.\n |\n |  append(self, object, /)\n |      Append object to the end of the list.\n |\n |  clear(self, /)\n |      Remove all items from list.\n |\n |  copy(self, /)\n |      Return a shallow copy of the list.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  extend(self, iterable, /)\n |      Extend list by appending elements from the iterable.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  insert(self, index, object, /)\n |      Insert object before index.\n |\n |  pop(self, index=-1, /)\n |      Remove and return item at index (default last).\n |\n |      Raises IndexError if list is empty or index is out of range.\n |\n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |\n |  sort(self, /, *, key=None, reverse=False)\n |      Sort the list in ascending order and return None.\n |\n |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\n |      order of two equal elements is maintained).\n |\n |      If a key function is given, apply it once to each list item and sort them,\n |      ascending or descending, according to their function values.\n |\n |      The reverse flag can be set to sort in descending order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.list:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.list:\n |\n |  __new__(*args, **kwargs) class method of builtins.list\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.list:\n |\n |  __hash__ = None",
        "syntax": "Syntax: _List(iterable=(), /)",
        "other-params": ""
    },
    "importlib._bootstrap._ModuleLock": {
        "function": "_ModuleLock(name)",
        "alias": "_ModuleLock",
        "help": "Help on class _ModuleLock in module importlib._bootstrap:\n\nclass _ModuleLock(builtins.object)\n |  _ModuleLock(name)\n |\n |  A recursive lock implementation which is able to detect deadlocks\n |  (e.g. thread 1 trying to take locks A then B, and thread 2 trying to\n |  take locks B then A).\n |\n |  Methods defined here:\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  acquire(self)\n |      Acquire the module lock.  If a potential deadlock is detected,\n |      a _DeadlockError is raised.\n |      Otherwise, the lock is always acquired and True is returned.\n |\n |  has_deadlock(self)\n |\n |  release(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ModuleLock(name)",
        "other-params": ""
    },
    "importlib._bootstrap._ModuleLockManager": {
        "function": "_ModuleLockManager(name)",
        "alias": "_ModuleLockManager",
        "help": "Help on class _ModuleLockManager in module importlib._bootstrap:\n\nclass _ModuleLockManager(builtins.object)\n |  _ModuleLockManager(name)\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *args, **kwargs)\n |\n |  __init__(self, name)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _ModuleLockManager(name)",
        "other-params": ""
    },
    "importlib._bootstrap._WeakValueDictionary": {
        "function": "_WeakValueDictionary()",
        "alias": "_WeakValueDictionary",
        "help": "Help on class _WeakValueDictionary in module importlib._bootstrap:\n\nclass _WeakValueDictionary(builtins.object)\n |  # Copied from weakref.py with some simplifications and modifications unique to\n |  # bootstrapping importlib. Many methods were simply deleting for simplicity, so if they\n |  # are needed in the future they may work if simply copied back in.\n |\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  clear(self)\n |\n |  get(self, key, default=None)\n |\n |  setdefault(self, key, default=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _WeakValueDictionary()",
        "other-params": ""
    },
    "importlib._bootstrap._builtin_from_name": {
        "function": "_builtin_from_name(name)",
        "alias": "_builtin_from_name",
        "help": "Help on function _builtin_from_name in module importlib._bootstrap:\n\n_builtin_from_name(name)",
        "syntax": "Syntax: _builtin_from_name(name)",
        "other-params": ""
    },
    "importlib._bootstrap._calc___package__": {
        "function": "_calc___package__(globals)",
        "alias": "_calc___package__",
        "help": "Help on function _calc___package__ in module importlib._bootstrap:\n\n_calc___package__(globals)\n    Calculate what __package__ should be.\n\n    __package__ is not guaranteed to be defined or could be set to None\n    to represent that its proper value is unknown.",
        "syntax": "Syntax: _calc___package__(globals)",
        "other-params": ""
    },
    "importlib._bootstrap._call_with_frames_removed": {
        "function": "_call_with_frames_removed(f, *args, **kwds)",
        "alias": "_call_with_frames_removed",
        "help": "Help on function _call_with_frames_removed in module importlib._bootstrap:\n\n_call_with_frames_removed(f, *args, **kwds)\n    remove_importlib_frames in import.c will always remove sequences\n    of importlib frames that end with a call to this function\n\n    Use it instead of a normal call in places where including the importlib\n    frames introduces unwanted noise into the traceback (e.g. when executing\n    module code)",
        "syntax": "Syntax: _call_with_frames_removed(f, *args, **kwds)",
        "other-params": ""
    },
    "importlib._bootstrap._exec": {
        "function": "_exec(spec, module)",
        "alias": "_exec",
        "help": "Help on function _exec in module importlib._bootstrap:\n\n_exec(spec, module)\n    Execute the spec's specified module in an existing module's namespace.",
        "syntax": "Syntax: _exec(spec, module)",
        "other-params": ""
    },
    "importlib._bootstrap._find_and_load": {
        "function": "_find_and_load(name, import_)",
        "alias": "_find_and_load",
        "help": "Help on function _find_and_load in module importlib._bootstrap:\n\n_find_and_load(name, import_)\n    Find and load the module.",
        "syntax": "Syntax: _find_and_load(name, import_)",
        "other-params": ""
    },
    "importlib._bootstrap._find_and_load_unlocked": {
        "function": "_find_and_load_unlocked(name, import_)",
        "alias": "_find_and_load_unlocked",
        "help": "Help on function _find_and_load_unlocked in module importlib._bootstrap:\n\n_find_and_load_unlocked(name, import_)",
        "syntax": "Syntax: _find_and_load_unlocked(name, import_)",
        "other-params": ""
    },
    "importlib._bootstrap._find_spec": {
        "function": "_find_spec(name, path, target=None)",
        "alias": "_find_spec",
        "help": "Help on function _find_spec in module importlib._bootstrap:\n\n_find_spec(name, path, target=None)\n    Find a module's spec.",
        "syntax": "Syntax: _find_spec(name, path, target=None)",
        "other-params": ""
    },
    "importlib._bootstrap._gcd_import": {
        "function": "_gcd_import(name, package=None, level=0)",
        "alias": "_gcd_import",
        "help": "Help on function _gcd_import in module importlib._bootstrap:\n\n_gcd_import(name, package=None, level=0)\n    Import and return the module based on its name, the package the call is\n    being made from, and the level adjustment.\n\n    This function represents the greatest common denominator of functionality\n    between import_module and __import__. This includes setting __package__ if\n    the loader did not.",
        "syntax": "Syntax: _gcd_import(name, package=None, level=0)",
        "other-params": ""
    },
    "importlib._bootstrap._get_module_lock": {
        "function": "_get_module_lock(name)",
        "alias": "_get_module_lock",
        "help": "Help on function _get_module_lock in module importlib._bootstrap:\n\n_get_module_lock(name)\n    Get or create the module lock for a given module name.\n\n    Acquire/release internally the global import lock to protect\n    _module_locks.",
        "syntax": "Syntax: _get_module_lock(name)",
        "other-params": ""
    },
    "importlib._bootstrap._handle_fromlist": {
        "function": "_handle_fromlist(module, fromlist, import_, *, recursive=False)",
        "alias": "_handle_fromlist",
        "help": "Help on function _handle_fromlist in module importlib._bootstrap:\n\n_handle_fromlist(module, fromlist, import_, *, recursive=False)\n    Figure out what __import__ should return.\n\n    The import_ parameter is a callable which takes the name of module to\n    import. It is required to decouple the function from assuming importlib's\n    import implementation is desired.",
        "syntax": "Syntax: _handle_fromlist(module, fromlist, import_, *, recursive=False)",
        "other-params": ""
    },
    "importlib._bootstrap._has_deadlocked": {
        "function": "_has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)",
        "alias": "_has_deadlocked",
        "help": "Help on function _has_deadlocked in module importlib._bootstrap:\n\n_has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)\n    Check if 'target_id' is holding the same lock as another thread(s).\n\n    The search within 'blocking_on' starts with the threads listed in\n    'candidate_ids'.  'seen_ids' contains any threads that are considered\n    already traversed in the search.\n\n    Keyword arguments:\n    target_id     -- The thread id to try to reach.\n    seen_ids      -- A set of threads that have already been visited.\n    candidate_ids -- The thread ids from which to begin.\n    blocking_on   -- A dict representing the thread/blocking-on graph.  This may\n                     be the same object as the global '_blocking_on' but it is\n                     a parameter to reduce the impact that global mutable\n                     state has on the result of this function.",
        "syntax": "Syntax: _has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on)",
        "other-params": ""
    },
    "importlib._bootstrap._init_module_attrs": {
        "function": "_init_module_attrs(spec, module, *, override=False)",
        "alias": "_init_module_attrs",
        "help": "Help on function _init_module_attrs in module importlib._bootstrap:\n\n_init_module_attrs(spec, module, *, override=False)",
        "syntax": "Syntax: _init_module_attrs(spec, module, *, override=False)",
        "other-params": ""
    },
    "importlib._bootstrap._install": {
        "function": "_install(sys_module, _imp_module)",
        "alias": "_install",
        "help": "Help on function _install in module importlib._bootstrap:\n\n_install(sys_module, _imp_module)\n    Install importers for builtin and frozen modules",
        "syntax": "Syntax: _install(sys_module, _imp_module)",
        "other-params": ""
    },
    "importlib._bootstrap._install_external_importers": {
        "function": "_install_external_importers()",
        "alias": "_install_external_importers",
        "help": "Help on function _install_external_importers in module importlib._bootstrap:\n\n_install_external_importers()\n    Install importers that require external filesystem access",
        "syntax": "Syntax: _install_external_importers()",
        "other-params": ""
    },
    "importlib._bootstrap._load": {
        "function": "_load(spec)",
        "alias": "_load",
        "help": "Help on function _load in module importlib._bootstrap:\n\n_load(spec)\n    Return a new module object, loaded by the spec's loader.\n\n    The module is not added to its parent.\n\n    If a module is already in sys.modules, that existing module gets\n    clobbered.",
        "syntax": "Syntax: _load(spec)",
        "other-params": ""
    },
    "importlib._bootstrap._load_backward_compatible": {
        "function": "_load_backward_compatible(spec)",
        "alias": "_load_backward_compatible",
        "help": "Help on function _load_backward_compatible in module importlib._bootstrap:\n\n_load_backward_compatible(spec)",
        "syntax": "Syntax: _load_backward_compatible(spec)",
        "other-params": ""
    },
    "importlib._bootstrap._load_module_shim": {
        "function": "_load_module_shim(self, fullname)",
        "alias": "_load_module_shim",
        "help": "Help on function _load_module_shim in module importlib._bootstrap:\n\n_load_module_shim(self, fullname)\n    Load the specified module into sys.modules and return it.\n\n    This method is deprecated.  Use loader.exec_module() instead.",
        "syntax": "Syntax: _load_module_shim(self, fullname)",
        "other-params": ""
    },
    "importlib._bootstrap._load_unlocked": {
        "function": "_load_unlocked(spec)",
        "alias": "_load_unlocked",
        "help": "Help on function _load_unlocked in module importlib._bootstrap:\n\n_load_unlocked(spec)",
        "syntax": "Syntax: _load_unlocked(spec)",
        "other-params": ""
    },
    "importlib._bootstrap._lock_unlock_module": {
        "function": "_lock_unlock_module(name)",
        "alias": "_lock_unlock_module",
        "help": "Help on function _lock_unlock_module in module importlib._bootstrap:\n\n_lock_unlock_module(name)\n    Acquires then releases the module lock for a given module name.\n\n    This is used to ensure a module is completely initialized, in the\n    event it is being imported by another thread.",
        "syntax": "Syntax: _lock_unlock_module(name)",
        "other-params": ""
    },
    "importlib._bootstrap._module_repr": {
        "function": "_module_repr(module)",
        "alias": "_module_repr",
        "help": "Help on function _module_repr in module importlib._bootstrap:\n\n_module_repr(module)\n    The implementation of ModuleType.__repr__().",
        "syntax": "Syntax: _module_repr(module)",
        "other-params": ""
    },
    "importlib._bootstrap._module_repr_from_spec": {
        "function": "_module_repr_from_spec(spec)",
        "alias": "_module_repr_from_spec",
        "help": "Help on function _module_repr_from_spec in module importlib._bootstrap:\n\n_module_repr_from_spec(spec)\n    Return the repr to use for the module.",
        "syntax": "Syntax: _module_repr_from_spec(spec)",
        "other-params": ""
    },
    "importlib._bootstrap._new_module": {
        "function": "_new_module(name)",
        "alias": "_new_module",
        "help": "Help on function _new_module in module importlib._bootstrap:\n\n_new_module(name)",
        "syntax": "Syntax: _new_module(name)",
        "other-params": ""
    },
    "importlib._bootstrap._object_name": {
        "function": "_object_name(obj)",
        "alias": "_object_name",
        "help": "Help on function _object_name in module importlib._bootstrap:\n\n_object_name(obj)",
        "syntax": "Syntax: _object_name(obj)",
        "other-params": ""
    },
    "importlib._bootstrap._requires_builtin": {
        "function": "_requires_builtin(fxn)",
        "alias": "_requires_builtin",
        "help": "Help on function _requires_builtin in module importlib._bootstrap:\n\n_requires_builtin(fxn)\n    Decorator to verify the named module is built-in.",
        "syntax": "Syntax: _requires_builtin(fxn)",
        "other-params": ""
    },
    "importlib._bootstrap._requires_frozen": {
        "function": "_requires_frozen(fxn)",
        "alias": "_requires_frozen",
        "help": "Help on function _requires_frozen in module importlib._bootstrap:\n\n_requires_frozen(fxn)\n    Decorator to verify the named module is frozen.",
        "syntax": "Syntax: _requires_frozen(fxn)",
        "other-params": ""
    },
    "importlib._bootstrap._resolve_name": {
        "function": "_resolve_name(name, package, level)",
        "alias": "_resolve_name",
        "help": "Help on function _resolve_name in module importlib._bootstrap:\n\n_resolve_name(name, package, level)\n    Resolve a relative module name to an absolute one.",
        "syntax": "Syntax: _resolve_name(name, package, level)",
        "other-params": ""
    },
    "importlib._bootstrap._sanity_check": {
        "function": "_sanity_check(name, package, level)",
        "alias": "_sanity_check",
        "help": "Help on function _sanity_check in module importlib._bootstrap:\n\n_sanity_check(name, package, level)\n    Verify arguments are \"sane\".",
        "syntax": "Syntax: _sanity_check(name, package, level)",
        "other-params": ""
    },
    "importlib._bootstrap._setup": {
        "function": "_setup(sys_module, _imp_module)",
        "alias": "_setup",
        "help": "Help on function _setup in module importlib._bootstrap:\n\n_setup(sys_module, _imp_module)\n    Setup importlib by importing needed built-in modules and injecting them\n    into the global namespace.\n\n    As sys is needed for sys.modules access and _imp is needed to load built-in\n    modules, those two modules must be explicitly passed in.",
        "syntax": "Syntax: _setup(sys_module, _imp_module)",
        "other-params": ""
    },
    "importlib._bootstrap._spec_from_module": {
        "function": "_spec_from_module(module, loader=None, origin=None)",
        "alias": "_spec_from_module",
        "help": "Help on function _spec_from_module in module importlib._bootstrap:\n\n_spec_from_module(module, loader=None, origin=None)",
        "syntax": "Syntax: _spec_from_module(module, loader=None, origin=None)",
        "other-params": ""
    },
    "importlib._bootstrap._verbose_message": {
        "function": "_verbose_message(message, *args, verbosity=1)",
        "alias": "_verbose_message",
        "help": "Help on function _verbose_message in module importlib._bootstrap:\n\n_verbose_message(message, *args, verbosity=1)\n    Print the message to stderr if -v/PYTHONVERBOSE is turned on.",
        "syntax": "Syntax: _verbose_message(message, *args, verbosity=1)",
        "other-params": ""
    },
    "importlib._bootstrap._wrap": {
        "function": "_wrap(new, old)",
        "alias": "_wrap",
        "help": "Help on function _wrap in module importlib._bootstrap:\n\n_wrap(new, old)\n    Simple substitute for functools.update_wrapper.",
        "syntax": "Syntax: _wrap(new, old)",
        "other-params": ""
    },
    "importlib._bootstrap.module_from_spec": {
        "function": "module_from_spec(spec)",
        "alias": "module_from_spec",
        "help": "Help on function module_from_spec in module importlib._bootstrap:\n\nmodule_from_spec(spec)\n    Create a module based on the provided spec.",
        "syntax": "Syntax: module_from_spec(spec)",
        "other-params": ""
    },
    "importlib._bootstrap.spec_from_loader": {
        "function": "spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "alias": "spec_from_loader",
        "help": "Help on function spec_from_loader in module importlib._bootstrap:\n\nspec_from_loader(name, loader, *, origin=None, is_package=None)\n    Return a module spec based on various loader methods.",
        "syntax": "Syntax: spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "other-params": ""
    },
    "importlib._bootstrap_external.AppleFrameworkLoader": {
        "function": "AppleFrameworkLoader(name, path)",
        "alias": "AppleFrameworkLoader",
        "help": "Help on class AppleFrameworkLoader in module importlib._bootstrap_external:\n\nclass AppleFrameworkLoader(ExtensionFileLoader)\n |  AppleFrameworkLoader(name, path)\n |\n |  A loader for modules that have been packaged as frameworks for\n |  compatibility with Apple's iOS App Store policies.\n |\n |  Method resolution order:\n |      AppleFrameworkLoader\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from ExtensionFileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: AppleFrameworkLoader(name, path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.ExtensionFileLoader": {
        "function": "ExtensionFileLoader(name, path)",
        "alias": "ExtensionFileLoader",
        "help": "Help on class ExtensionFileLoader in module importlib._bootstrap_external:\n\nclass ExtensionFileLoader(FileLoader, _LoaderBasics)\n |  ExtensionFileLoader(name, path)\n |\n |  Loader for extension modules.\n |\n |  The constructor is designed to work with FileFinder.\n |\n |  Method resolution order:\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: ExtensionFileLoader(name, path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.FileFinder": {
        "function": "FileFinder(path, *loader_details)",
        "alias": "FileFinder",
        "help": "Help on class FileFinder in module importlib._bootstrap_external:\n\nclass FileFinder(builtins.object)\n |  FileFinder(path, *loader_details)\n |\n |  File-based finder.\n |\n |  Interactions with the file system are cached for performance, being\n |  refreshed when the directory the finder is handling has been modified.\n |\n |  Methods defined here:\n |\n |  __init__(self, path, *loader_details)\n |      Initialize with the path to search on and a variable number of\n |      2-tuples containing the loader and the file suffixes the loader\n |      recognizes.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  find_spec(self, fullname, target=None)\n |      Try to find a spec for the specified module.\n |\n |      Returns the matching spec, or None if not found.\n |\n |  invalidate_caches(self)\n |      Invalidate the directory mtime.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  path_hook(*loader_details)\n |      A class method which returns a closure to use on sys.path_hook\n |      which will return an instance using the specified loaders and the path\n |      called on the closure.\n |\n |      If the path called on the closure is not a directory, ImportError is\n |      raised.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FileFinder(path, *loader_details)",
        "other-params": ""
    },
    "importlib._bootstrap_external.FileLoader": {
        "function": "FileLoader(fullname, path)",
        "alias": "FileLoader",
        "help": "Help on class FileLoader in module importlib._bootstrap_external:\n\nclass FileLoader(builtins.object)\n |  FileLoader(fullname, path)\n |\n |  Base file loader class which implements the loader protocol methods that\n |  require file system usage.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FileLoader(fullname, path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.NamespaceLoader": {
        "function": "NamespaceLoader(name, path, path_finder)",
        "alias": "NamespaceLoader",
        "help": "Help on class NamespaceLoader in module importlib._bootstrap_external:\n\nclass NamespaceLoader(builtins.object)\n |  NamespaceLoader(name, path, path_finder)\n |\n |  # This class is actually exposed publicly in a namespace package's __loader__\n |  # attribute, so it should be available through a non-private name.\n |  # https://github.com/python/cpython/issues/92054\n |\n |  Methods defined here:\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |\n |  get_code(self, fullname)\n |\n |  get_resource_reader(self, module)\n |\n |  get_source(self, fullname)\n |\n |  is_package(self, fullname)\n |\n |  load_module(self, fullname)\n |      Load a namespace module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: NamespaceLoader(name, path, path_finder)",
        "other-params": ""
    },
    "importlib._bootstrap_external.PathFinder": {
        "function": "PathFinder()",
        "alias": "PathFinder",
        "help": "Help on class PathFinder in module importlib._bootstrap_external:\n\nclass PathFinder(builtins.object)\n |  Meta path finder for sys.path and package __path__ attributes.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |      Try to find a spec for 'fullname' on sys.path or 'path'.\n |\n |      The search is based on sys.path_hooks and sys.path_importer_cache.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  find_distributions(*args, **kwargs)\n |      Find distributions.\n |\n |      Return an iterable of all Distribution instances capable of\n |      loading the metadata for packages matching ``context.name``\n |      (or all names if ``None`` indicated) along the paths in the list\n |      of directories ``context.path``.\n |\n |  invalidate_caches()\n |      Call the invalidate_caches() method on all path entry finders\n |      stored in sys.path_importer_cache (where implemented).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: PathFinder()",
        "other-params": ""
    },
    "importlib._bootstrap_external.SourceFileLoader": {
        "function": "SourceFileLoader(fullname, path)",
        "alias": "SourceFileLoader",
        "help": "Help on class SourceFileLoader in module importlib._bootstrap_external:\n\nclass SourceFileLoader(FileLoader, SourceLoader)\n |  SourceFileLoader(fullname, path)\n |\n |  Concrete implementation of SourceLoader using the file system.\n |\n |  Method resolution order:\n |      SourceFileLoader\n |      FileLoader\n |      SourceLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  path_stats(self, path)\n |      Return the metadata for the path.\n |\n |  set_data(self, path, data, *, _mode=438)\n |      Write bytes data to a file.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from SourceLoader:\n |\n |  get_code(self, fullname)\n |      Concrete implementation of InspectLoader.get_code.\n |\n |      Reading of bytecode requires path_stats to be implemented. To write\n |      bytecode, set_data must also be implemented.\n |\n |  get_source(self, fullname)\n |      Concrete implementation of InspectLoader.get_source.\n |\n |  path_mtime(self, path)\n |      Optional method that returns the modification time (an int) for the\n |      specified path (a str).\n |\n |      Raises OSError when the path cannot be handled.\n |\n |  source_to_code(self, data, path, *, _optimize=-1)\n |      Return the code object compiled from source.\n |\n |      The 'data' argument can be any object type that compile() supports.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourceFileLoader(fullname, path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.SourceLoader": {
        "function": "SourceLoader()",
        "alias": "SourceLoader",
        "help": "Help on class SourceLoader in module importlib._bootstrap_external:\n\nclass SourceLoader(_LoaderBasics)\n |  Method resolution order:\n |      SourceLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  get_code(self, fullname)\n |      Concrete implementation of InspectLoader.get_code.\n |\n |      Reading of bytecode requires path_stats to be implemented. To write\n |      bytecode, set_data must also be implemented.\n |\n |  get_source(self, fullname)\n |      Concrete implementation of InspectLoader.get_source.\n |\n |  path_mtime(self, path)\n |      Optional method that returns the modification time (an int) for the\n |      specified path (a str).\n |\n |      Raises OSError when the path cannot be handled.\n |\n |  path_stats(self, path)\n |      Optional method returning a metadata dict for the specified\n |      path (a str).\n |\n |      Possible keys:\n |      - 'mtime' (mandatory) is the numeric timestamp of last source\n |        code modification;\n |      - 'size' (optional) is the size in bytes of the source code.\n |\n |      Implementing this method allows the loader to read bytecode files.\n |      Raises OSError when the path cannot be handled.\n |\n |  set_data(self, path, data)\n |      Optional method which writes data (bytes) to a file path (a str).\n |\n |      Implementing this method allows for the writing of bytecode files.\n |\n |  source_to_code(self, data, path, *, _optimize=-1)\n |      Return the code object compiled from source.\n |\n |      The 'data' argument can be any object type that compile() supports.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.\n |\n |  load_module(self, fullname)\n |      This method is deprecated.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _LoaderBasics:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: SourceLoader()",
        "other-params": ""
    },
    "importlib._bootstrap_external.SourcelessFileLoader": {
        "function": "SourcelessFileLoader(fullname, path)",
        "alias": "SourcelessFileLoader",
        "help": "Help on class SourcelessFileLoader in module importlib._bootstrap_external:\n\nclass SourcelessFileLoader(FileLoader, _LoaderBasics)\n |  SourcelessFileLoader(fullname, path)\n |\n |  Loader which handles sourceless file imports.\n |\n |  Method resolution order:\n |      SourcelessFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  get_code(self, fullname)\n |\n |  get_source(self, fullname)\n |      Return None as there is no source code.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourcelessFileLoader(fullname, path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.WindowsRegistryFinder": {
        "function": "WindowsRegistryFinder()",
        "alias": "WindowsRegistryFinder",
        "help": "Help on class WindowsRegistryFinder in module importlib._bootstrap_external:\n\nclass WindowsRegistryFinder(builtins.object)\n |  Meta path finder for modules declared in the Windows registry.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  DEBUG_BUILD = False\n |\n |  REGISTRY_KEY = r'Software\\Python\\PythonCore\\{sys_version}\\Modules\\{ful...\n |\n |  REGISTRY_KEY_DEBUG = r'Software\\Python\\PythonCore\\{sys_version}\\Module...",
        "syntax": "Syntax: WindowsRegistryFinder()",
        "other-params": ""
    },
    "importlib._bootstrap_external._LoaderBasics": {
        "function": "_LoaderBasics()",
        "alias": "_LoaderBasics",
        "help": "Help on class _LoaderBasics in module importlib._bootstrap_external:\n\nclass _LoaderBasics(builtins.object)\n |  Base class of common code needed by both SourceLoader and\n |  SourcelessFileLoader.\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.\n |\n |  load_module(self, fullname)\n |      This method is deprecated.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _LoaderBasics()",
        "other-params": ""
    },
    "importlib._bootstrap_external._NamespaceLoader": {
        "function": "_NamespaceLoader(name, path, path_finder)",
        "alias": "_NamespaceLoader",
        "help": "Help on class NamespaceLoader in module importlib._bootstrap_external:\n\nclass NamespaceLoader(builtins.object)\n |  NamespaceLoader(name, path, path_finder)\n |\n |  # This class is actually exposed publicly in a namespace package's __loader__\n |  # attribute, so it should be available through a non-private name.\n |  # https://github.com/python/cpython/issues/92054\n |\n |  Methods defined here:\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |\n |  get_code(self, fullname)\n |\n |  get_resource_reader(self, module)\n |\n |  get_source(self, fullname)\n |\n |  is_package(self, fullname)\n |\n |  load_module(self, fullname)\n |      Load a namespace module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _NamespaceLoader(name, path, path_finder)",
        "other-params": ""
    },
    "importlib._bootstrap_external._NamespacePath": {
        "function": "_NamespacePath(name, path, path_finder)",
        "alias": "_NamespacePath",
        "help": "Help on class _NamespacePath in module importlib._bootstrap_external:\n\nclass _NamespacePath(builtins.object)\n |  _NamespacePath(name, path, path_finder)\n |\n |  Represents a namespace package's path.  It uses the module name\n |  to find its parent module, and from there it looks up the parent's\n |  __path__.  When this changes, the module's own path is recomputed,\n |  using path_finder.  For top-level modules, the parent module's path\n |  is sys.path.\n |\n |  Methods defined here:\n |\n |  __contains__(self, item)\n |\n |  __getitem__(self, index)\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self)\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __setitem__(self, index, path)\n |\n |  append(self, item)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _NamespacePath(name, path, path_finder)",
        "other-params": ""
    },
    "importlib._bootstrap_external._bless_my_loader": {
        "function": "_bless_my_loader(module_globals)",
        "alias": "_bless_my_loader",
        "help": "Help on function _bless_my_loader in module importlib._bootstrap_external:\n\n_bless_my_loader(module_globals)\n    Helper function for _warnings.c\n\n    See GH#97850 for details.",
        "syntax": "Syntax: _bless_my_loader(module_globals)",
        "other-params": ""
    },
    "importlib._bootstrap_external._calc_mode": {
        "function": "_calc_mode(path)",
        "alias": "_calc_mode",
        "help": "Help on function _calc_mode in module importlib._bootstrap_external:\n\n_calc_mode(path)\n    Calculate the mode permissions for a bytecode file.",
        "syntax": "Syntax: _calc_mode(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._check_name": {
        "function": "_check_name(method)",
        "alias": "_check_name",
        "help": "Help on function _check_name in module importlib._bootstrap_external:\n\n_check_name(method)\n    Decorator to verify that the module being requested matches the one the\n    loader can handle.\n\n    The first argument (self) must define _name which the second argument is\n    compared against. If the comparison fails then ImportError is raised.",
        "syntax": "Syntax: _check_name(method)",
        "other-params": ""
    },
    "importlib._bootstrap_external._classify_pyc": {
        "function": "_classify_pyc(data, name, exc_details)",
        "alias": "_classify_pyc",
        "help": "Help on function _classify_pyc in module importlib._bootstrap_external:\n\n_classify_pyc(data, name, exc_details)\n    Perform basic validity checking of a pyc header and return the flags field,\n    which determines how the pyc should be further validated against the source.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required, though.)\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    ImportError is raised when the magic number is incorrect or when the flags\n    field is invalid. EOFError is raised when the data is found to be truncated.",
        "syntax": "Syntax: _classify_pyc(data, name, exc_details)",
        "other-params": ""
    },
    "importlib._bootstrap_external._code_to_hash_pyc": {
        "function": "_code_to_hash_pyc(code, source_hash, checked=True)",
        "alias": "_code_to_hash_pyc",
        "help": "Help on function _code_to_hash_pyc in module importlib._bootstrap_external:\n\n_code_to_hash_pyc(code, source_hash, checked=True)\n    Produce the data for a hash-based pyc.",
        "syntax": "Syntax: _code_to_hash_pyc(code, source_hash, checked=True)",
        "other-params": ""
    },
    "importlib._bootstrap_external._code_to_timestamp_pyc": {
        "function": "_code_to_timestamp_pyc(code, mtime=0, source_size=0)",
        "alias": "_code_to_timestamp_pyc",
        "help": "Help on function _code_to_timestamp_pyc in module importlib._bootstrap_external:\n\n_code_to_timestamp_pyc(code, mtime=0, source_size=0)\n    Produce the data for a timestamp-based pyc.",
        "syntax": "Syntax: _code_to_timestamp_pyc(code, mtime=0, source_size=0)",
        "other-params": ""
    },
    "importlib._bootstrap_external._code_type": {
        "function": "_code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "alias": "_code_type",
        "help": "Help on class code in module builtins:\n\nclass code(object)\n |  code(\n |      argcount,\n |      posonlyargcount,\n |      kwonlyargcount,\n |      nlocals,\n |      stacksize,\n |      flags,\n |      codestring,\n |      constants,\n |      names,\n |      varnames,\n |      filename,\n |      name,\n |      qualname,\n |      firstlineno,\n |      linetable,\n |      exceptiontable,\n |      freevars=(),\n |      cellvars=(),\n |      /\n |  )\n |\n |  Create a code object.  Not for the faint of heart.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __replace__(self, /, **changes)\n |      The same as replace().\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  co_lines(self, /)\n |\n |  co_positions(self, /)\n |\n |  replace(self, /, **changes)\n |      Return a copy of the code object with new values for the specified fields.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  co_argcount\n |\n |  co_cellvars\n |\n |  co_code\n |\n |  co_consts\n |\n |  co_exceptiontable\n |\n |  co_filename\n |\n |  co_firstlineno\n |\n |  co_flags\n |\n |  co_freevars\n |\n |  co_kwonlyargcount\n |\n |  co_linetable\n |\n |  co_lnotab\n |\n |  co_name\n |\n |  co_names\n |\n |  co_nlocals\n |\n |  co_posonlyargcount\n |\n |  co_qualname\n |\n |  co_stacksize\n |\n |  co_varnames",
        "syntax": "Syntax: _code_type(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "other-params": ""
    },
    "importlib._bootstrap_external._compile_bytecode": {
        "function": "_compile_bytecode(data, name=None, bytecode_path=None, source_path=None)",
        "alias": "_compile_bytecode",
        "help": "Help on function _compile_bytecode in module importlib._bootstrap_external:\n\n_compile_bytecode(data, name=None, bytecode_path=None, source_path=None)\n    Compile bytecode as found in a pyc.",
        "syntax": "Syntax: _compile_bytecode(data, name=None, bytecode_path=None, source_path=None)",
        "other-params": ""
    },
    "importlib._bootstrap_external._fix_up_module": {
        "function": "_fix_up_module(ns, name, pathname, cpathname=None)",
        "alias": "_fix_up_module",
        "help": "Help on function _fix_up_module in module importlib._bootstrap_external:\n\n_fix_up_module(ns, name, pathname, cpathname=None)",
        "syntax": "Syntax: _fix_up_module(ns, name, pathname, cpathname=None)",
        "other-params": ""
    },
    "importlib._bootstrap_external._get_cached": {
        "function": "_get_cached(filename)",
        "alias": "_get_cached",
        "help": "Help on function _get_cached in module importlib._bootstrap_external:\n\n_get_cached(filename)",
        "syntax": "Syntax: _get_cached(filename)",
        "other-params": ""
    },
    "importlib._bootstrap_external._get_sourcefile": {
        "function": "_get_sourcefile(bytecode_path)",
        "alias": "_get_sourcefile",
        "help": "Help on function _get_sourcefile in module importlib._bootstrap_external:\n\n_get_sourcefile(bytecode_path)\n    Convert a bytecode file path to a source path (if possible).\n\n    This function exists purely for backwards-compatibility for\n    PyImport_ExecCodeModuleWithFilenames() in the C API.",
        "syntax": "Syntax: _get_sourcefile(bytecode_path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._get_supported_file_loaders": {
        "function": "_get_supported_file_loaders()",
        "alias": "_get_supported_file_loaders",
        "help": "Help on function _get_supported_file_loaders in module importlib._bootstrap_external:\n\n_get_supported_file_loaders()\n    Returns a list of file-based module loaders.\n\n    Each item is a tuple (loader, suffixes).",
        "syntax": "Syntax: _get_supported_file_loaders()",
        "other-params": ""
    },
    "importlib._bootstrap_external._install": {
        "function": "_install(_bootstrap_module)",
        "alias": "_install",
        "help": "Help on function _install in module importlib._bootstrap_external:\n\n_install(_bootstrap_module)\n    Install the path-based import components.",
        "syntax": "Syntax: _install(_bootstrap_module)",
        "other-params": ""
    },
    "importlib._bootstrap_external._make_relax_case": {
        "function": "_make_relax_case()",
        "alias": "_make_relax_case",
        "help": "Help on function _make_relax_case in module importlib._bootstrap_external:\n\n_make_relax_case()",
        "syntax": "Syntax: _make_relax_case()",
        "other-params": ""
    },
    "importlib._bootstrap_external._pack_uint32": {
        "function": "_pack_uint32(x)",
        "alias": "_pack_uint32",
        "help": "Help on function _pack_uint32 in module importlib._bootstrap_external:\n\n_pack_uint32(x)\n    Convert a 32-bit integer to little-endian.",
        "syntax": "Syntax: _pack_uint32(x)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_abspath": {
        "function": "_path_abspath(path)",
        "alias": "_path_abspath",
        "help": "Help on function _path_abspath in module importlib._bootstrap_external:\n\n_path_abspath(path)\n    Replacement for os.path.abspath.",
        "syntax": "Syntax: _path_abspath(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_is_mode_type": {
        "function": "_path_is_mode_type(path, mode)",
        "alias": "_path_is_mode_type",
        "help": "Help on function _path_is_mode_type in module importlib._bootstrap_external:\n\n_path_is_mode_type(path, mode)\n    Test whether the path is the specified mode type.",
        "syntax": "Syntax: _path_is_mode_type(path, mode)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_isabs": {
        "function": "_path_isabs(path)",
        "alias": "_path_isabs",
        "help": "Help on function _path_isabs in module importlib._bootstrap_external:\n\n_path_isabs(path)\n    Replacement for os.path.isabs.",
        "syntax": "Syntax: _path_isabs(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_isdir": {
        "function": "_path_isdir(path)",
        "alias": "_path_isdir",
        "help": "Help on function _path_isdir in module importlib._bootstrap_external:\n\n_path_isdir(path)\n    Replacement for os.path.isdir.",
        "syntax": "Syntax: _path_isdir(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_isfile": {
        "function": "_path_isfile(path)",
        "alias": "_path_isfile",
        "help": "Help on function _path_isfile in module importlib._bootstrap_external:\n\n_path_isfile(path)\n    Replacement for os.path.isfile.",
        "syntax": "Syntax: _path_isfile(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_join": {
        "function": "_path_join(*path_parts)",
        "alias": "_path_join",
        "help": "Help on function _path_join in module importlib._bootstrap_external:\n\n_path_join(*path_parts)\n    Replacement for os.path.join().",
        "syntax": "Syntax: _path_join(*path_parts)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_split": {
        "function": "_path_split(path)",
        "alias": "_path_split",
        "help": "Help on function _path_split in module importlib._bootstrap_external:\n\n_path_split(path)\n    Replacement for os.path.split().",
        "syntax": "Syntax: _path_split(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._path_stat": {
        "function": "_path_stat(path)",
        "alias": "_path_stat",
        "help": "Help on function _path_stat in module importlib._bootstrap_external:\n\n_path_stat(path)\n    Stat the path.\n\n    Made a separate function to make it easier to override in experiments\n    (e.g. cache stat results).",
        "syntax": "Syntax: _path_stat(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external._relax_case": {
        "function": "_relax_case()",
        "alias": "_relax_case",
        "help": "Help on function _relax_case in module importlib._bootstrap_external:\n\n_relax_case()\n    True if filenames must be checked case-insensitively and ignore environment flags are not set.",
        "syntax": "Syntax: _relax_case()",
        "other-params": ""
    },
    "importlib._bootstrap_external._set_bootstrap_module": {
        "function": "_set_bootstrap_module(_bootstrap_module)",
        "alias": "_set_bootstrap_module",
        "help": "Help on function _set_bootstrap_module in module importlib._bootstrap_external:\n\n_set_bootstrap_module(_bootstrap_module)",
        "syntax": "Syntax: _set_bootstrap_module(_bootstrap_module)",
        "other-params": ""
    },
    "importlib._bootstrap_external._unpack_uint16": {
        "function": "_unpack_uint16(data)",
        "alias": "_unpack_uint16",
        "help": "Help on function _unpack_uint16 in module importlib._bootstrap_external:\n\n_unpack_uint16(data)\n    Convert 2 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint16(data)",
        "other-params": ""
    },
    "importlib._bootstrap_external._unpack_uint32": {
        "function": "_unpack_uint32(data)",
        "alias": "_unpack_uint32",
        "help": "Help on function _unpack_uint32 in module importlib._bootstrap_external:\n\n_unpack_uint32(data)\n    Convert 4 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint32(data)",
        "other-params": ""
    },
    "importlib._bootstrap_external._unpack_uint64": {
        "function": "_unpack_uint64(data)",
        "alias": "_unpack_uint64",
        "help": "Help on function _unpack_uint64 in module importlib._bootstrap_external:\n\n_unpack_uint64(data)\n    Convert 8 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint64(data)",
        "other-params": ""
    },
    "importlib._bootstrap_external._validate_hash_pyc": {
        "function": "_validate_hash_pyc(data, source_hash, name, exc_details)",
        "alias": "_validate_hash_pyc",
        "help": "Help on function _validate_hash_pyc in module importlib._bootstrap_external:\n\n_validate_hash_pyc(data, source_hash, name, exc_details)\n    Validate a hash-based pyc by checking the real source hash against the one in\n    the pyc header.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required.)\n\n    *source_hash* is the importlib.util.source_hash() of the source file.\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    An ImportError is raised if the bytecode is stale.",
        "syntax": "Syntax: _validate_hash_pyc(data, source_hash, name, exc_details)",
        "other-params": ""
    },
    "importlib._bootstrap_external._validate_timestamp_pyc": {
        "function": "_validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)",
        "alias": "_validate_timestamp_pyc",
        "help": "Help on function _validate_timestamp_pyc in module importlib._bootstrap_external:\n\n_validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)\n    Validate a pyc against the source last-modified time.\n\n    *data* is the contents of the pyc file. (Only the first 16 bytes are\n    required.)\n\n    *source_mtime* is the last modified timestamp of the source file.\n\n    *source_size* is None or the size of the source file in bytes.\n\n    *name* is the name of the module being imported. It is used for logging.\n\n    *exc_details* is a dictionary passed to ImportError if it raised for\n    improved debugging.\n\n    An ImportError is raised if the bytecode is stale.",
        "syntax": "Syntax: _validate_timestamp_pyc(data, source_mtime, source_size, name, exc_details)",
        "other-params": ""
    },
    "importlib._bootstrap_external._write_atomic": {
        "function": "_write_atomic(path, data, mode=438)",
        "alias": "_write_atomic",
        "help": "Help on function _write_atomic in module importlib._bootstrap_external:\n\n_write_atomic(path, data, mode=438)\n    Best-effort function to write data to a path atomically.\n    Be prepared to handle a FileExistsError if concurrent writing of the\n    temporary file is attempted.",
        "syntax": "Syntax: _write_atomic(path, data, mode=438)",
        "other-params": ""
    },
    "importlib._bootstrap_external.cache_from_source": {
        "function": "cache_from_source(path, debug_override=None, *, optimization=None)",
        "alias": "cache_from_source",
        "help": "Help on function cache_from_source in module importlib._bootstrap_external:\n\ncache_from_source(path, debug_override=None, *, optimization=None)\n    Given the path to a .py file, return the path to its .pyc file.\n\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError\n    is raised).\n\n    The debug_override parameter is deprecated. If debug_override is not None,\n    a True value is the same as setting 'optimization' to the empty string\n    while a False value is equivalent to setting 'optimization' to '1'.\n\n    If sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: cache_from_source(path, debug_override=None, *, optimization=None)",
        "other-params": ""
    },
    "importlib._bootstrap_external.decode_source": {
        "function": "decode_source(source_bytes)",
        "alias": "decode_source",
        "help": "Help on function decode_source in module importlib._bootstrap_external:\n\ndecode_source(source_bytes)\n    Decode bytes representing source code and return the string.\n\n    Universal newline support is used in the decoding.",
        "syntax": "Syntax: decode_source(source_bytes)",
        "other-params": ""
    },
    "importlib._bootstrap_external.source_from_cache": {
        "function": "source_from_cache(path)",
        "alias": "source_from_cache",
        "help": "Help on function source_from_cache in module importlib._bootstrap_external:\n\nsource_from_cache(path)\n    Given the path to a .pyc. file, return the path to its .py file.\n\n    The .pyc file does not need to exist; this simply returns the path to\n    the .py file calculated to correspond to the .pyc file.  If path does\n    not conform to PEP 3147/488 format, ValueError will be raised. If\n    sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: source_from_cache(path)",
        "other-params": ""
    },
    "importlib._bootstrap_external.spec_from_file_location": {
        "function": "spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "alias": "spec_from_file_location",
        "help": "Help on function spec_from_file_location in module importlib._bootstrap_external:\n\nspec_from_file_location(\n    name,\n    location=None,\n    *,\n    loader=None,\n    submodule_search_locations=<object object at 0x000001950D0901C0>\n)\n    Return a module spec based on a file location.\n\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n\n    The loader must take a spec as its only __init__() arg.",
        "syntax": "Syntax: spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "other-params": ""
    },
    "importlib._pack_uint32": {
        "function": "_pack_uint32(x)",
        "alias": "_pack_uint32",
        "help": "Help on function _pack_uint32 in module importlib._bootstrap_external:\n\n_pack_uint32(x)\n    Convert a 32-bit integer to little-endian.",
        "syntax": "Syntax: _pack_uint32(x)",
        "other-params": ""
    },
    "importlib._unpack_uint32": {
        "function": "_unpack_uint32(data)",
        "alias": "_unpack_uint32",
        "help": "Help on function _unpack_uint32 in module importlib._bootstrap_external:\n\n_unpack_uint32(data)\n    Convert 4 bytes in little-endian to an integer.",
        "syntax": "Syntax: _unpack_uint32(data)",
        "other-params": ""
    },
    "importlib.import_module": {
        "function": "import_module(name, package=None)",
        "alias": "import_module",
        "help": "Help on function import_module in module importlib:\n\nimport_module(name, package=None)\n    Import a module.\n\n    The 'package' argument is required when performing a relative import. It\n    specifies the package to use as the anchor point from which to resolve the\n    relative import to an absolute import.",
        "syntax": "Syntax: import_module(name, package=None)",
        "other-params": ""
    },
    "importlib.invalidate_caches": {
        "function": "invalidate_caches()",
        "alias": "invalidate_caches",
        "help": "Help on function invalidate_caches in module importlib:\n\ninvalidate_caches()\n    Call the invalidate_caches() method on all meta path finders stored in\n    sys.meta_path (where implemented).",
        "syntax": "Syntax: invalidate_caches()",
        "other-params": ""
    },
    "importlib.reload": {
        "function": "reload(module)",
        "alias": "reload",
        "help": "Help on function reload in module importlib:\n\nreload(module)\n    Reload the module and return it.\n\n    The module must have been successfully imported before.",
        "syntax": "Syntax: reload(module)",
        "other-params": ""
    },
    "importlib.machinery.AppleFrameworkLoader": {
        "function": "AppleFrameworkLoader(name, path)",
        "alias": "AppleFrameworkLoader",
        "help": "Help on class AppleFrameworkLoader in module importlib._bootstrap_external:\n\nclass AppleFrameworkLoader(ExtensionFileLoader)\n |  AppleFrameworkLoader(name, path)\n |\n |  A loader for modules that have been packaged as frameworks for\n |  compatibility with Apple's iOS App Store policies.\n |\n |  Method resolution order:\n |      AppleFrameworkLoader\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from ExtensionFileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: AppleFrameworkLoader(name, path)",
        "other-params": ""
    },
    "importlib.machinery.BuiltinImporter": {
        "function": "BuiltinImporter()",
        "alias": "BuiltinImporter",
        "help": "Help on class BuiltinImporter in module importlib._bootstrap:\n\nclass BuiltinImporter(builtins.object)\n |  Meta path import for built-in modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return None as built-in modules do not have code objects.\n |\n |  get_source(fullname)\n |      Return None as built-in modules do not have source code.\n |\n |  is_package(fullname)\n |      Return False as built-in modules are never packages.\n |\n |  load_module = _load_module_shim(fullname) from _frozen_importlib\n |      Load the specified module into sys.modules and return it.\n |\n |      This method is deprecated.  Use loader.exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Create a built-in module\n |\n |  exec_module(module)\n |      Exec a built-in module\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: BuiltinImporter()",
        "other-params": ""
    },
    "importlib.machinery.ExtensionFileLoader": {
        "function": "ExtensionFileLoader(name, path)",
        "alias": "ExtensionFileLoader",
        "help": "Help on class ExtensionFileLoader in module importlib._bootstrap_external:\n\nclass ExtensionFileLoader(FileLoader, _LoaderBasics)\n |  ExtensionFileLoader(name, path)\n |\n |  Loader for extension modules.\n |\n |  The constructor is designed to work with FileFinder.\n |\n |  Method resolution order:\n |      ExtensionFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, name, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  create_module(self, spec)\n |      Create an uninitialized extension module\n |\n |  exec_module(self, module)\n |      Initialize an extension module\n |\n |  get_code(self, fullname)\n |      Return None as an extension module cannot create a code object.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_source(self, fullname)\n |      Return None as extension modules have no source code.\n |\n |  is_package(self, fullname)\n |      Return True if the extension module is a package.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: ExtensionFileLoader(name, path)",
        "other-params": ""
    },
    "importlib.machinery.FileFinder": {
        "function": "FileFinder(path, *loader_details)",
        "alias": "FileFinder",
        "help": "Help on class FileFinder in module importlib._bootstrap_external:\n\nclass FileFinder(builtins.object)\n |  FileFinder(path, *loader_details)\n |\n |  File-based finder.\n |\n |  Interactions with the file system are cached for performance, being\n |  refreshed when the directory the finder is handling has been modified.\n |\n |  Methods defined here:\n |\n |  __init__(self, path, *loader_details)\n |      Initialize with the path to search on and a variable number of\n |      2-tuples containing the loader and the file suffixes the loader\n |      recognizes.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  find_spec(self, fullname, target=None)\n |      Try to find a spec for the specified module.\n |\n |      Returns the matching spec, or None if not found.\n |\n |  invalidate_caches(self)\n |      Invalidate the directory mtime.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  path_hook(*loader_details)\n |      A class method which returns a closure to use on sys.path_hook\n |      which will return an instance using the specified loaders and the path\n |      called on the closure.\n |\n |      If the path called on the closure is not a directory, ImportError is\n |      raised.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FileFinder(path, *loader_details)",
        "other-params": ""
    },
    "importlib.machinery.FrozenImporter": {
        "function": "FrozenImporter()",
        "alias": "FrozenImporter",
        "help": "Help on class FrozenImporter in module importlib._bootstrap:\n\nclass FrozenImporter(builtins.object)\n |  Meta path import for frozen modules.\n |\n |  All methods are either class or static methods to avoid the need to\n |  instantiate the class.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  get_code(fullname)\n |      Return the code object for the frozen module.\n |\n |  get_source(fullname)\n |      Return None as frozen modules do not have source code.\n |\n |  is_package(fullname)\n |      Return True if the frozen module is a package.\n |\n |  load_module(fullname)\n |      Load a frozen module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  create_module(spec)\n |      Set __file__, if able.\n |\n |  exec_module(module)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: FrozenImporter()",
        "other-params": ""
    },
    "importlib.machinery.ModuleSpec": {
        "function": "ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "alias": "ModuleSpec",
        "help": "Help on class ModuleSpec in module importlib._bootstrap:\n\nclass ModuleSpec(builtins.object)\n |  ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)\n |\n |  The specification for a module, used for loading.\n |\n |  A module's spec is the source for information about the module.  For\n |  data associated with the module, including source, use the spec's\n |  loader.\n |\n |  `name` is the absolute name of the module.  `loader` is the loader\n |  to use when loading the module.  `parent` is the name of the\n |  package the module is in.  The parent is derived from the name.\n |\n |  `is_package` determines if the module is considered a package or\n |  not.  On modules this is reflected by the `__path__` attribute.\n |\n |  `origin` is the specific location used by the loader from which to\n |  load the module, if that information is available.  When filename is\n |  set, origin will match.\n |\n |  `has_location` indicates that a spec's \"origin\" reflects a location.\n |  When this is True, `__file__` attribute of the module is set.\n |\n |  `cached` is the location of the cached bytecode file, if any.  It\n |  corresponds to the `__cached__` attribute.\n |\n |  `submodule_search_locations` is the sequence of path entries to\n |  search when importing submodules.  If set, is_package should be\n |  True--and False otherwise.\n |\n |  Packages are simply modules that (may) have submodules.  If a spec\n |  has a non-None value in `submodule_search_locations`, the import\n |  system will consider modules loaded from the spec as packages.\n |\n |  Only finders (see importlib.abc.MetaPathFinder and\n |  importlib.abc.PathEntryFinder) should modify ModuleSpec instances.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __init__(self, name, loader, *, origin=None, loader_state=None, is_package=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  parent\n |      The name of the module's parent.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  cached\n |\n |  has_location\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "other-params": ""
    },
    "importlib.machinery.NamespaceLoader": {
        "function": "NamespaceLoader(name, path, path_finder)",
        "alias": "NamespaceLoader",
        "help": "Help on class NamespaceLoader in module importlib._bootstrap_external:\n\nclass NamespaceLoader(builtins.object)\n |  NamespaceLoader(name, path, path_finder)\n |\n |  # This class is actually exposed publicly in a namespace package's __loader__\n |  # attribute, so it should be available through a non-private name.\n |  # https://github.com/python/cpython/issues/92054\n |\n |  Methods defined here:\n |\n |  __init__(self, name, path, path_finder)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |\n |  get_code(self, fullname)\n |\n |  get_resource_reader(self, module)\n |\n |  get_source(self, fullname)\n |\n |  is_package(self, fullname)\n |\n |  load_module(self, fullname)\n |      Load a namespace module.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: NamespaceLoader(name, path, path_finder)",
        "other-params": ""
    },
    "importlib.machinery.PathFinder": {
        "function": "PathFinder()",
        "alias": "PathFinder",
        "help": "Help on class PathFinder in module importlib._bootstrap_external:\n\nclass PathFinder(builtins.object)\n |  Meta path finder for sys.path and package __path__ attributes.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |      Try to find a spec for 'fullname' on sys.path or 'path'.\n |\n |      The search is based on sys.path_hooks and sys.path_importer_cache.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  find_distributions(*args, **kwargs)\n |      Find distributions.\n |\n |      Return an iterable of all Distribution instances capable of\n |      loading the metadata for packages matching ``context.name``\n |      (or all names if ``None`` indicated) along the paths in the list\n |      of directories ``context.path``.\n |\n |  invalidate_caches()\n |      Call the invalidate_caches() method on all path entry finders\n |      stored in sys.path_importer_cache (where implemented).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: PathFinder()",
        "other-params": ""
    },
    "importlib.machinery.SourceFileLoader": {
        "function": "SourceFileLoader(fullname, path)",
        "alias": "SourceFileLoader",
        "help": "Help on class SourceFileLoader in module importlib._bootstrap_external:\n\nclass SourceFileLoader(FileLoader, SourceLoader)\n |  SourceFileLoader(fullname, path)\n |\n |  Concrete implementation of SourceLoader using the file system.\n |\n |  Method resolution order:\n |      SourceFileLoader\n |      FileLoader\n |      SourceLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  path_stats(self, path)\n |      Return the metadata for the path.\n |\n |  set_data(self, path, data, *, _mode=438)\n |      Write bytes data to a file.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from SourceLoader:\n |\n |  get_code(self, fullname)\n |      Concrete implementation of InspectLoader.get_code.\n |\n |      Reading of bytecode requires path_stats to be implemented. To write\n |      bytecode, set_data must also be implemented.\n |\n |  get_source(self, fullname)\n |      Concrete implementation of InspectLoader.get_source.\n |\n |  path_mtime(self, path)\n |      Optional method that returns the modification time (an int) for the\n |      specified path (a str).\n |\n |      Raises OSError when the path cannot be handled.\n |\n |  source_to_code(self, data, path, *, _optimize=-1)\n |      Return the code object compiled from source.\n |\n |      The 'data' argument can be any object type that compile() supports.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourceFileLoader(fullname, path)",
        "other-params": ""
    },
    "importlib.machinery.SourcelessFileLoader": {
        "function": "SourcelessFileLoader(fullname, path)",
        "alias": "SourcelessFileLoader",
        "help": "Help on class SourcelessFileLoader in module importlib._bootstrap_external:\n\nclass SourcelessFileLoader(FileLoader, _LoaderBasics)\n |  SourcelessFileLoader(fullname, path)\n |\n |  Loader which handles sourceless file imports.\n |\n |  Method resolution order:\n |      SourcelessFileLoader\n |      FileLoader\n |      _LoaderBasics\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  get_code(self, fullname)\n |\n |  get_source(self, fullname)\n |      Return None as there is no source code.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from FileLoader:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, fullname, path)\n |      Cache the module name and the path to the file found by the\n |      finder.\n |\n |  get_data(self, path)\n |      Return the data from path as raw bytes.\n |\n |  get_filename(self, name=None, *args, **kwargs)\n |      Return the path to the source file as found by the finder.\n |\n |  get_resource_reader(self, name=None, *args, **kwargs)\n |\n |  load_module(self, name=None, *args, **kwargs)\n |      Load a module from a file.\n |\n |      This method is deprecated.  Use exec_module() instead.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from FileLoader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _LoaderBasics:\n |\n |  create_module(self, spec)\n |      Use default semantics for module creation.\n |\n |  exec_module(self, module)\n |      Execute the module.\n |\n |  is_package(self, fullname)\n |      Concrete implementation of InspectLoader.is_package by checking if\n |      the path returned by get_filename has a filename of '__init__.py'.",
        "syntax": "Syntax: SourcelessFileLoader(fullname, path)",
        "other-params": ""
    },
    "importlib.machinery.WindowsRegistryFinder": {
        "function": "WindowsRegistryFinder()",
        "alias": "WindowsRegistryFinder",
        "help": "Help on class WindowsRegistryFinder in module importlib._bootstrap_external:\n\nclass WindowsRegistryFinder(builtins.object)\n |  Meta path finder for modules declared in the Windows registry.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  DEBUG_BUILD = False\n |\n |  REGISTRY_KEY = r'Software\\Python\\PythonCore\\{sys_version}\\Modules\\{ful...\n |\n |  REGISTRY_KEY_DEBUG = r'Software\\Python\\PythonCore\\{sys_version}\\Module...",
        "syntax": "Syntax: WindowsRegistryFinder()",
        "other-params": ""
    },
    "importlib.machinery.all_suffixes": {
        "function": "all_suffixes()",
        "alias": "all_suffixes",
        "help": "Help on function all_suffixes in module importlib.machinery:\n\nall_suffixes()\n    Returns a list of all recognized module suffixes for this process",
        "syntax": "Syntax: all_suffixes()",
        "other-params": ""
    },
    "importlib._abc.Loader": {
        "function": "Loader()",
        "alias": "Loader",
        "help": "Help on class Loader in module importlib._abc:\n\nclass Loader(builtins.object)\n |  Abstract base class for import loaders.\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Return a module to initialize and into which to load.\n |\n |      This method should raise ImportError if anything prevents it\n |      from creating a new module.  It may return None to indicate\n |      that the spec should create the new module.\n |\n |  load_module(self, fullname)\n |      Return the loaded module.\n |\n |      The module must be added to sys.modules and have import-related\n |      attributes set properly.  The fullname is a str.\n |\n |      ImportError is raised on failure.\n |\n |      This method is deprecated in favor of loader.exec_module(). If\n |      exec_module() exists then it is used to provide a backwards-compatible\n |      functionality for this method.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()",
        "syntax": "Syntax: Loader()",
        "other-params": ""
    },
    "types.AsyncGeneratorType": {
        "function": "AsyncGeneratorType()",
        "alias": "AsyncGeneratorType",
        "help": "Help on class async_generator in module builtins:\n\nclass async_generator(object)\n |  Methods defined here:\n |\n |  __aiter__(self, /)\n |      Return an awaitable, that resolves in asynchronous iterator.\n |\n |  __anext__(self, /)\n |      Return a value or raise StopAsyncIteration.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  aclose(self, /)\n |      aclose() -> raise GeneratorExit inside generator.\n |\n |  asend(self, object, /)\n |      asend(v) -> send 'v' in generator.\n |\n |  athrow(...)\n |      athrow(value)\n |      athrow(type[,value[,tb]])\n |\n |      raise exception in generator.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  ag_await\n |      object being awaited on, or None\n |\n |  ag_code\n |\n |  ag_frame\n |\n |  ag_running\n |\n |  ag_suspended",
        "syntax": "Syntax: AsyncGeneratorType()",
        "other-params": ""
    },
    "types.BuiltinFunctionType": {
        "function": "BuiltinFunctionType()",
        "alias": "BuiltinFunctionType",
        "help": "Help on class builtin_function_or_method in module builtins:\n\nclass builtin_function_or_method(object)\n |  Built-in subclasses:\n |      builtin_method\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __self__\n |\n |  __text_signature__",
        "syntax": "Syntax: BuiltinFunctionType()",
        "other-params": ""
    },
    "types.BuiltinMethodType": {
        "function": "BuiltinMethodType()",
        "alias": "BuiltinMethodType",
        "help": "Help on class builtin_function_or_method in module builtins:\n\nclass builtin_function_or_method(object)\n |  Built-in subclasses:\n |      builtin_method\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __self__\n |\n |  __text_signature__",
        "syntax": "Syntax: BuiltinMethodType()",
        "other-params": ""
    },
    "types.CellType": {
        "function": "Error retrieving signature: <class 'cell'> builtin has invalid signature",
        "alias": "CellType",
        "help": "Help on class cell in module builtins:\n\nclass cell(object)\n |  cell([contents])\n |\n |  Create a new cell object.\n |\n |   contents\n |     the contents of the cell. If not specified, the cell will be empty,\n |     and\n |  further attempts to access its cell_contents attribute will\n |     raise a ValueError.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  cell_contents\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: <class 'cell'> builtin has invalid signature",
        "other-params": ""
    },
    "types.ClassMethodDescriptorType": {
        "function": "ClassMethodDescriptorType()",
        "alias": "ClassMethodDescriptorType",
        "help": "Help on class classmethod_descriptor in module builtins:\n\nclass classmethod_descriptor(object)\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__\n |\n |  __text_signature__",
        "syntax": "Syntax: ClassMethodDescriptorType()",
        "other-params": ""
    },
    "types.CodeType": {
        "function": "CodeType(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "alias": "CodeType",
        "help": "Help on class code in module builtins:\n\nclass code(object)\n |  code(\n |      argcount,\n |      posonlyargcount,\n |      kwonlyargcount,\n |      nlocals,\n |      stacksize,\n |      flags,\n |      codestring,\n |      constants,\n |      names,\n |      varnames,\n |      filename,\n |      name,\n |      qualname,\n |      firstlineno,\n |      linetable,\n |      exceptiontable,\n |      freevars=(),\n |      cellvars=(),\n |      /\n |  )\n |\n |  Create a code object.  Not for the faint of heart.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __replace__(self, /, **changes)\n |      The same as replace().\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      Size of object in memory, in bytes.\n |\n |  co_lines(self, /)\n |\n |  co_positions(self, /)\n |\n |  replace(self, /, **changes)\n |      Return a copy of the code object with new values for the specified fields.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  co_argcount\n |\n |  co_cellvars\n |\n |  co_code\n |\n |  co_consts\n |\n |  co_exceptiontable\n |\n |  co_filename\n |\n |  co_firstlineno\n |\n |  co_flags\n |\n |  co_freevars\n |\n |  co_kwonlyargcount\n |\n |  co_linetable\n |\n |  co_lnotab\n |\n |  co_name\n |\n |  co_names\n |\n |  co_nlocals\n |\n |  co_posonlyargcount\n |\n |  co_qualname\n |\n |  co_stacksize\n |\n |  co_varnames",
        "syntax": "Syntax: CodeType(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable, freevars=(), cellvars=(), /)",
        "other-params": ""
    },
    "types.CoroutineType": {
        "function": "CoroutineType()",
        "alias": "CoroutineType",
        "help": "Help on class coroutine in module builtins:\n\nclass coroutine(object)\n |  Methods defined here:\n |\n |  __await__(self, /)\n |      Return an iterator to be used in await expression.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside coroutine.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into coroutine,\n |      return next iterated value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,traceback]])\n |\n |      Raise exception in coroutine, return next iterated value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  cr_await\n |      object being awaited on, or None\n |\n |  cr_code\n |\n |  cr_frame\n |\n |  cr_origin\n |\n |  cr_running\n |\n |  cr_suspended",
        "syntax": "Syntax: CoroutineType()",
        "other-params": ""
    },
    "types.DynamicClassAttribute": {
        "function": "DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)",
        "alias": "DynamicClassAttribute",
        "help": "Help on class DynamicClassAttribute in module types:\n\nclass DynamicClassAttribute(builtins.object)\n |  DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)\n |\n |  Route attribute access on a class to __getattr__.\n |\n |  This is a descriptor, used to define attributes that act differently when\n |  accessed through an instance and through a class.  Instance access remains\n |  normal, but access to an attribute through a class will be routed to the\n |  class's __getattr__ method; this is done by raising AttributeError.\n |\n |  This allows one to have properties active on an instance, and have virtual\n |  attributes on the class with the same name.  (Enum used this between Python\n |  versions 3.4 - 3.9 .)\n |\n |  Subclass from this to use a different method of accessing virtual attributes\n |  and still be treated properly by the inspect module. (Enum uses this since\n |  Python 3.10 .)\n |\n |  Methods defined here:\n |\n |  __delete__(self, instance)\n |\n |  __get__(self, instance, ownerclass=None)\n |\n |  __init__(self, fget=None, fset=None, fdel=None, doc=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __set__(self, instance, value)\n |\n |  deleter(self, fdel)\n |\n |  getter(self, fget)\n |\n |  setter(self, fset)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)",
        "other-params": ""
    },
    "types.EllipsisType": {
        "function": "EllipsisType()",
        "alias": "EllipsisType",
        "help": "Help on class ellipsis in module builtins:\n\nclass ellipsis(object)\n |  The type of the Ellipsis singleton.\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: EllipsisType()",
        "other-params": ""
    },
    "types.FrameType": {
        "function": "FrameType()",
        "alias": "FrameType",
        "help": "Help on class frame in module builtins:\n\nclass frame(object)\n |  Methods defined here:\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      F.__sizeof__() -> size of F in memory, in bytes\n |\n |  clear(self, /)\n |      F.clear(): clear most references held by the frame\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  f_back\n |\n |  f_builtins\n |\n |  f_code\n |\n |  f_globals\n |\n |  f_lasti\n |\n |  f_lineno\n |\n |  f_locals\n |\n |  f_trace\n |\n |  f_trace_lines\n |\n |  f_trace_opcodes",
        "syntax": "Syntax: FrameType()",
        "other-params": ""
    },
    "types.FunctionType": {
        "function": "FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "alias": "FunctionType",
        "help": "Help on class function in module builtins:\n\nclass function(object)\n |  function(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)\n |\n |  Create a function object.\n |\n |  code\n |    a code object\n |  globals\n |    the globals dictionary\n |  name\n |    a string that overrides the name from the code object\n |  argdefs\n |    a tuple that specifies the default argument values\n |  closure\n |    a tuple that supplies the bindings for free variables\n |  kwdefaults\n |    a dictionary that specifies the default keyword argument values\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __closure__\n |\n |  __code__\n |\n |  __defaults__\n |\n |  __dict__\n |\n |  __globals__\n |\n |  __kwdefaults__\n |\n |  __type_params__",
        "syntax": "Syntax: FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "other-params": ""
    },
    "types.GeneratorType": {
        "function": "GeneratorType()",
        "alias": "GeneratorType",
        "help": "Help on class generator in module builtins:\n\nclass generator(object)\n |  Methods defined here:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside generator.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into generator,\n |      return next yielded value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,tb]])\n |\n |      Raise exception in generator, return next yielded value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  gi_code\n |\n |  gi_frame\n |\n |  gi_running\n |\n |  gi_suspended\n |\n |  gi_yieldfrom\n |      object being iterated by yield from, or None",
        "syntax": "Syntax: GeneratorType()",
        "other-params": ""
    },
    "types.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "types.GetSetDescriptorType": {
        "function": "GetSetDescriptorType()",
        "alias": "GetSetDescriptorType",
        "help": "Help on class getset_descriptor in module builtins:\n\nclass getset_descriptor(object)\n |  Methods defined here:\n |\n |  __delete__(self, instance, /)\n |      Delete an attribute of instance.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __set__(self, instance, value, /)\n |      Set an attribute of instance to value.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__",
        "syntax": "Syntax: GetSetDescriptorType()",
        "other-params": ""
    },
    "types.LambdaType": {
        "function": "LambdaType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "alias": "LambdaType",
        "help": "Help on class function in module builtins:\n\nclass function(object)\n |  function(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)\n |\n |  Create a function object.\n |\n |  code\n |    a code object\n |  globals\n |    the globals dictionary\n |  name\n |    a string that overrides the name from the code object\n |  argdefs\n |    a tuple that specifies the default argument values\n |  closure\n |    a tuple that supplies the bindings for free variables\n |  kwdefaults\n |    a dictionary that specifies the default keyword argument values\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __closure__\n |\n |  __code__\n |\n |  __defaults__\n |\n |  __dict__\n |\n |  __globals__\n |\n |  __kwdefaults__\n |\n |  __type_params__",
        "syntax": "Syntax: LambdaType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "other-params": ""
    },
    "types.MappingProxyType": {
        "function": "MappingProxyType(mapping)",
        "alias": "MappingProxyType",
        "help": "Help on class mappingproxy in module builtins:\n\nclass mappingproxy(object)\n |  mappingproxy(mapping)\n |\n |  Read-only proxy of a mapping.\n |\n |  Methods defined here:\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      D.__reversed__() -> reverse iterator\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  copy(self, /)\n |      D.copy() -> a shallow copy of D\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the mapping, else default.\n |\n |  items(self, /)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self, /)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self, /)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: MappingProxyType(mapping)",
        "other-params": ""
    },
    "types.MemberDescriptorType": {
        "function": "MemberDescriptorType()",
        "alias": "MemberDescriptorType",
        "help": "Help on class member_descriptor in module builtins:\n\nclass member_descriptor(object)\n |  Methods defined here:\n |\n |  __delete__(self, instance, /)\n |      Delete an attribute of instance.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __set__(self, instance, value, /)\n |      Set an attribute of instance to value.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__",
        "syntax": "Syntax: MemberDescriptorType()",
        "other-params": ""
    },
    "types.MethodDescriptorType": {
        "function": "MethodDescriptorType()",
        "alias": "MethodDescriptorType",
        "help": "Help on class method_descriptor in module builtins:\n\nclass method_descriptor(object)\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__\n |\n |  __text_signature__",
        "syntax": "Syntax: MethodDescriptorType()",
        "other-params": ""
    },
    "types.MethodType": {
        "function": "MethodType(function, instance, /)",
        "alias": "MethodType",
        "help": "Help on class method in module builtins:\n\nclass method(object)\n |  method(function, instance, /)\n |\n |  Create a bound instance method object.\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __func__\n |      the function (or other callable) implementing a method\n |\n |  __self__\n |      the instance to which a method is bound",
        "syntax": "Syntax: MethodType(function, instance, /)",
        "other-params": ""
    },
    "types.MethodWrapperType": {
        "function": "MethodWrapperType()",
        "alias": "MethodWrapperType",
        "help": "Help on class method-wrapper in module builtins:\n\nclass method-wrapper(object)\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__\n |\n |  __self__\n |\n |  __text_signature__",
        "syntax": "Syntax: MethodWrapperType()",
        "other-params": ""
    },
    "types.ModuleType": {
        "function": "ModuleType(name, doc=None)",
        "alias": "ModuleType",
        "help": "Help on class module in module builtins:\n\nclass module(object)\n |  module(name, doc=None)\n |\n |  Create a module object.\n |\n |  The name must be a string; the optional doc argument can have any type.\n |\n |  Methods defined here:\n |\n |  __dir__(self, /)\n |      __dir__() -> list\n |      specialized dir() implementation\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __dict__",
        "syntax": "Syntax: ModuleType(name, doc=None)",
        "other-params": ""
    },
    "types.NoneType": {
        "function": "NoneType()",
        "alias": "NoneType",
        "help": "Help on class NoneType in module builtins:\n\nclass NoneType(object)\n |  The type of the None singleton.\n |\n |  Methods defined here:\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: NoneType()",
        "other-params": ""
    },
    "types.NotImplementedType": {
        "function": "NotImplementedType()",
        "alias": "NotImplementedType",
        "help": "Help on class NotImplementedType in module builtins:\n\nclass NotImplementedType(object)\n |  The type of the NotImplemented singleton.\n |\n |  Methods defined here:\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: NotImplementedType()",
        "other-params": ""
    },
    "types.SimpleNamespace": {
        "function": "SimpleNamespace(mapping_or_iterable=(), /, **kwargs)",
        "alias": "SimpleNamespace",
        "help": "Help on class SimpleNamespace in module types:\n\nclass SimpleNamespace(builtins.object)\n |  SimpleNamespace(mapping_or_iterable=(), /, **kwargs)\n |\n |  A simple attribute-based namespace.\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __replace__(self, /, **changes)\n |      Return a copy of the namespace object with new values for the specified attributes.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: SimpleNamespace(mapping_or_iterable=(), /, **kwargs)",
        "other-params": ""
    },
    "types.TracebackType": {
        "function": "TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)",
        "alias": "TracebackType",
        "help": "Help on class traceback in module builtins:\n\nclass traceback(object)\n |  traceback(tb_next, tb_frame, tb_lasti, tb_lineno)\n |\n |  Create a new traceback object.\n |\n |  Methods defined here:\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  tb_frame\n |\n |  tb_lasti\n |\n |  tb_lineno\n |\n |  tb_next",
        "syntax": "Syntax: TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)",
        "other-params": ""
    },
    "types.UnionType": {
        "function": "UnionType()",
        "alias": "UnionType",
        "help": "Help on class UnionType in module types:\n\nclass UnionType(builtins.object)\n |  Represent a PEP 604 union type\n |\n |  E.g. for int | str\n |\n |  Methods defined here:\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __parameters__\n |      Type variables in the types.UnionType.",
        "syntax": "Syntax: UnionType()",
        "other-params": ""
    },
    "types.WrapperDescriptorType": {
        "function": "WrapperDescriptorType()",
        "alias": "WrapperDescriptorType",
        "help": "Help on class wrapper_descriptor in module builtins:\n\nclass wrapper_descriptor(object)\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __objclass__\n |\n |  __text_signature__",
        "syntax": "Syntax: WrapperDescriptorType()",
        "other-params": ""
    },
    "types._GeneratorWrapper": {
        "function": "_GeneratorWrapper(gen)",
        "alias": "_GeneratorWrapper",
        "help": "Help on class _GeneratorWrapper in module types:\n\nclass _GeneratorWrapper(builtins.object)\n |  _GeneratorWrapper(gen)\n |\n |  Methods defined here:\n |\n |  __await__ = __iter__(self)\n |\n |  __init__(self, gen)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |\n |  close(self)\n |\n |  send(self, val)\n |\n |  throw(self, tp, *rest)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  cr_await\n |\n |  cr_code\n |\n |  cr_frame\n |\n |  cr_running\n |\n |  gi_code\n |\n |  gi_frame\n |\n |  gi_running\n |\n |  gi_yieldfrom\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _GeneratorWrapper(gen)",
        "other-params": ""
    },
    "types._calculate_meta": {
        "function": "_calculate_meta(meta, bases)",
        "alias": "_calculate_meta",
        "help": "Help on function _calculate_meta in module types:\n\n_calculate_meta(meta, bases)\n    Calculate the most derived metaclass.",
        "syntax": "Syntax: _calculate_meta(meta, bases)",
        "other-params": ""
    },
    "types.coroutine": {
        "function": "coroutine(func)",
        "alias": "coroutine",
        "help": "Help on function coroutine in module types:\n\ncoroutine(func)\n    Convert regular generator function to a coroutine.",
        "syntax": "Syntax: coroutine(func)",
        "other-params": ""
    },
    "types.get_original_bases": {
        "function": "get_original_bases(cls, /)",
        "alias": "get_original_bases",
        "help": "Help on function get_original_bases in module types:\n\nget_original_bases(cls, /)\n    Return the class's \"original\" bases prior to modification by `__mro_entries__`.\n\n    Examples::\n\n        from typing import TypeVar, Generic, NamedTuple, TypedDict\n\n        T = TypeVar(\"T\")\n        class Foo(Generic[T]): ...\n        class Bar(Foo[int], float): ...\n        class Baz(list[str]): ...\n        Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n        Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n\n        assert get_original_bases(Bar) == (Foo[int], float)\n        assert get_original_bases(Baz) == (list[str],)\n        assert get_original_bases(Eggs) == (NamedTuple,)\n        assert get_original_bases(Spam) == (TypedDict,)\n        assert get_original_bases(int) == (object,)",
        "syntax": "Syntax: get_original_bases(cls, /)",
        "other-params": ""
    },
    "types.new_class": {
        "function": "new_class(name, bases=(), kwds=None, exec_body=None)",
        "alias": "new_class",
        "help": "Help on function new_class in module types:\n\nnew_class(name, bases=(), kwds=None, exec_body=None)\n    Create a class object dynamically using the appropriate metaclass.",
        "syntax": "Syntax: new_class(name, bases=(), kwds=None, exec_body=None)",
        "other-params": ""
    },
    "types.prepare_class": {
        "function": "prepare_class(name, bases=(), kwds=None)",
        "alias": "prepare_class",
        "help": "Help on function prepare_class in module types:\n\nprepare_class(name, bases=(), kwds=None)\n    Call the __prepare__ method of the appropriate metaclass.\n\n    Returns (metaclass, namespace, kwds) as a 3-tuple\n\n    *metaclass* is the appropriate metaclass\n    *namespace* is the prepared class namespace\n    *kwds* is an updated copy of the passed in kwds argument with any\n    'metaclass' entry removed. If no kwds argument is passed in, this will\n    be an empty dict.",
        "syntax": "Syntax: prepare_class(name, bases=(), kwds=None)",
        "other-params": ""
    },
    "types.resolve_bases": {
        "function": "resolve_bases(bases)",
        "alias": "resolve_bases",
        "help": "Help on function resolve_bases in module types:\n\nresolve_bases(bases)\n    Resolve MRO entries dynamically as specified by PEP 560.",
        "syntax": "Syntax: resolve_bases(bases)",
        "other-params": ""
    },
    "importlib.util.LazyLoader": {
        "function": "LazyLoader(loader)",
        "alias": "LazyLoader",
        "help": "Help on class LazyLoader in module importlib.util:\n\nclass LazyLoader(importlib._abc.Loader)\n |  LazyLoader(loader)\n |\n |  A loader that creates a module which defers loading until attribute access.\n |\n |  Method resolution order:\n |      LazyLoader\n |      importlib._abc.Loader\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, loader)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  create_module(self, spec)\n |      Return a module to initialize and into which to load.\n |\n |      This method should raise ImportError if anything prevents it\n |      from creating a new module.  It may return None to indicate\n |      that the spec should create the new module.\n |\n |  exec_module(self, module)\n |      Make the module load lazily.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  factory(loader)\n |      Construct a callable which returns the eager loader made lazy.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from importlib._abc.Loader:\n |\n |  load_module(self, fullname)\n |      Return the loaded module.\n |\n |      The module must be added to sys.modules and have import-related\n |      attributes set properly.  The fullname is a str.\n |\n |      ImportError is raised on failure.\n |\n |      This method is deprecated in favor of loader.exec_module(). If\n |      exec_module() exists then it is used to provide a backwards-compatible\n |      functionality for this method.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from importlib._abc.Loader:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: LazyLoader(loader)",
        "other-params": ""
    },
    "importlib.util.Loader": {
        "function": "Loader()",
        "alias": "Loader",
        "help": "Help on class Loader in module importlib._abc:\n\nclass Loader(builtins.object)\n |  Abstract base class for import loaders.\n |\n |  Methods defined here:\n |\n |  create_module(self, spec)\n |      Return a module to initialize and into which to load.\n |\n |      This method should raise ImportError if anything prevents it\n |      from creating a new module.  It may return None to indicate\n |      that the spec should create the new module.\n |\n |  load_module(self, fullname)\n |      Return the loaded module.\n |\n |      The module must be added to sys.modules and have import-related\n |      attributes set properly.  The fullname is a str.\n |\n |      ImportError is raised on failure.\n |\n |      This method is deprecated in favor of loader.exec_module(). If\n |      exec_module() exists then it is used to provide a backwards-compatible\n |      functionality for this method.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()",
        "syntax": "Syntax: Loader()",
        "other-params": ""
    },
    "importlib.util._LazyModule": {
        "function": "_LazyModule(name, doc=None)",
        "alias": "_LazyModule",
        "help": "Help on class _LazyModule in module importlib.util:\n\nclass _LazyModule(builtins.module)\n |  _LazyModule(name, doc=None)\n |\n |  A subclass of the module type which triggers loading upon attribute access.\n |\n |  Method resolution order:\n |      _LazyModule\n |      builtins.module\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delattr__(self, attr)\n |      Trigger the load and then perform the deletion.\n |\n |  __getattribute__(self, attr)\n |      Trigger the load of the module and return the attribute.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.module:\n |\n |  __dir__(self, /)\n |      __dir__() -> list\n |      specialized dir() implementation\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.module:\n |\n |  __new__(*args, **kwargs) class method of builtins.module\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.module:\n |\n |  __dict__",
        "syntax": "Syntax: _LazyModule(name, doc=None)",
        "other-params": ""
    },
    "importlib.util._find_spec": {
        "function": "_find_spec(name, path, target=None)",
        "alias": "_find_spec",
        "help": "Help on function _find_spec in module importlib._bootstrap:\n\n_find_spec(name, path, target=None)\n    Find a module's spec.",
        "syntax": "Syntax: _find_spec(name, path, target=None)",
        "other-params": ""
    },
    "importlib.util._find_spec_from_path": {
        "function": "_find_spec_from_path(name, path=None)",
        "alias": "_find_spec_from_path",
        "help": "Help on function _find_spec_from_path in module importlib.util:\n\n_find_spec_from_path(name, path=None)\n    Return the spec for the specified module.\n\n    First, sys.modules is checked to see if the module was already imported. If\n    so, then sys.modules[name].__spec__ is returned. If that happens to be\n    set to None, then ValueError is raised. If the module is not in\n    sys.modules, then sys.meta_path is searched for a suitable spec with the\n    value of 'path' given to the finders. None is returned if no spec could\n    be found.\n\n    Dotted names do not have their parent packages implicitly imported. You will\n    most likely need to explicitly import all parent packages in the proper\n    order for a submodule to get the correct spec.",
        "syntax": "Syntax: _find_spec_from_path(name, path=None)",
        "other-params": ""
    },
    "importlib.util._incompatible_extension_module_restrictions": {
        "function": "_incompatible_extension_module_restrictions(*, disable_check)",
        "alias": "_incompatible_extension_module_restrictions",
        "help": "Help on class _incompatible_extension_module_restrictions in module importlib.util:\n\nclass _incompatible_extension_module_restrictions(builtins.object)\n |  _incompatible_extension_module_restrictions(*, disable_check)\n |\n |  A context manager that can temporarily skip the compatibility check.\n |\n |  NOTE: This function is meant to accommodate an unusual case; one\n |  which is likely to eventually go away.  There's is a pretty good\n |  chance this is not what you were looking for.\n |\n |  WARNING: Using this function to disable the check can lead to\n |  unexpected behavior and even crashes.  It should only be used during\n |  extension module development.\n |\n |  If \"disable_check\" is True then the compatibility check will not\n |  happen while the context manager is active.  Otherwise the check\n |  *will* happen.\n |\n |  Normally, extensions that do not support multiple interpreters\n |  may not be imported in a subinterpreter.  That implies modules\n |  that do not implement multi-phase init or that explicitly of out.\n |\n |  Likewise for modules import in a subinterpreter with its own GIL\n |  when the extension does not support a per-interpreter GIL.  This\n |  implies the module does not have a Py_mod_multiple_interpreters slot\n |  set to Py_MOD_PER_INTERPRETER_GIL_SUPPORTED.\n |\n |  In both cases, this context manager may be used to temporarily\n |  disable the check for compatible extension modules.\n |\n |  You can get the same effect as this function by implementing the\n |  basic interface of multi-phase init (PEP 489) and lying about\n |  support for multiple interpreters (or per-interpreter GIL).\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *args)\n |\n |  __init__(self, *, disable_check)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  override\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _incompatible_extension_module_restrictions(*, disable_check)",
        "other-params": ""
    },
    "importlib.util._resolve_name": {
        "function": "_resolve_name(name, package, level)",
        "alias": "_resolve_name",
        "help": "Help on function _resolve_name in module importlib._bootstrap:\n\n_resolve_name(name, package, level)\n    Resolve a relative module name to an absolute one.",
        "syntax": "Syntax: _resolve_name(name, package, level)",
        "other-params": ""
    },
    "importlib.util.cache_from_source": {
        "function": "cache_from_source(path, debug_override=None, *, optimization=None)",
        "alias": "cache_from_source",
        "help": "Help on function cache_from_source in module importlib._bootstrap_external:\n\ncache_from_source(path, debug_override=None, *, optimization=None)\n    Given the path to a .py file, return the path to its .pyc file.\n\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError\n    is raised).\n\n    The debug_override parameter is deprecated. If debug_override is not None,\n    a True value is the same as setting 'optimization' to the empty string\n    while a False value is equivalent to setting 'optimization' to '1'.\n\n    If sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: cache_from_source(path, debug_override=None, *, optimization=None)",
        "other-params": ""
    },
    "importlib.util.decode_source": {
        "function": "decode_source(source_bytes)",
        "alias": "decode_source",
        "help": "Help on function decode_source in module importlib._bootstrap_external:\n\ndecode_source(source_bytes)\n    Decode bytes representing source code and return the string.\n\n    Universal newline support is used in the decoding.",
        "syntax": "Syntax: decode_source(source_bytes)",
        "other-params": ""
    },
    "importlib.util.find_spec": {
        "function": "find_spec(name, package=None)",
        "alias": "find_spec",
        "help": "Help on function find_spec in module importlib.util:\n\nfind_spec(name, package=None)\n    Return the spec for the specified module.\n\n    First, sys.modules is checked to see if the module was already imported. If\n    so, then sys.modules[name].__spec__ is returned. If that happens to be\n    set to None, then ValueError is raised. If the module is not in\n    sys.modules, then sys.meta_path is searched for a suitable spec with the\n    value of 'path' given to the finders. None is returned if no spec could\n    be found.\n\n    If the name is for submodule (contains a dot), the parent module is\n    automatically imported.\n\n    The name and package arguments work the same as importlib.import_module().\n    In other words, relative module names (with leading dots) work.",
        "syntax": "Syntax: find_spec(name, package=None)",
        "other-params": ""
    },
    "importlib.util.module_from_spec": {
        "function": "module_from_spec(spec)",
        "alias": "module_from_spec",
        "help": "Help on function module_from_spec in module importlib._bootstrap:\n\nmodule_from_spec(spec)\n    Create a module based on the provided spec.",
        "syntax": "Syntax: module_from_spec(spec)",
        "other-params": ""
    },
    "importlib.util.resolve_name": {
        "function": "resolve_name(name, package)",
        "alias": "resolve_name",
        "help": "Help on function resolve_name in module importlib.util:\n\nresolve_name(name, package)\n    Resolve a relative module name to an absolute one.",
        "syntax": "Syntax: resolve_name(name, package)",
        "other-params": ""
    },
    "importlib.util.source_from_cache": {
        "function": "source_from_cache(path)",
        "alias": "source_from_cache",
        "help": "Help on function source_from_cache in module importlib._bootstrap_external:\n\nsource_from_cache(path)\n    Given the path to a .pyc. file, return the path to its .py file.\n\n    The .pyc file does not need to exist; this simply returns the path to\n    the .py file calculated to correspond to the .pyc file.  If path does\n    not conform to PEP 3147/488 format, ValueError will be raised. If\n    sys.implementation.cache_tag is None then NotImplementedError is raised.",
        "syntax": "Syntax: source_from_cache(path)",
        "other-params": ""
    },
    "importlib.util.source_hash": {
        "function": "source_hash(source_bytes)",
        "alias": "source_hash",
        "help": "Help on function source_hash in module importlib.util:\n\nsource_hash(source_bytes)\n    Return the hash of *source_bytes* as used in hash-based pyc files.",
        "syntax": "Syntax: source_hash(source_bytes)",
        "other-params": ""
    },
    "importlib.util.spec_from_file_location": {
        "function": "spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "alias": "spec_from_file_location",
        "help": "Help on function spec_from_file_location in module importlib._bootstrap_external:\n\nspec_from_file_location(\n    name,\n    location=None,\n    *,\n    loader=None,\n    submodule_search_locations=<object object at 0x000001950D0901C0>\n)\n    Return a module spec based on a file location.\n\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n\n    The loader must take a spec as its only __init__() arg.",
        "syntax": "Syntax: spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "other-params": ""
    },
    "importlib.util.spec_from_loader": {
        "function": "spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "alias": "spec_from_loader",
        "help": "Help on function spec_from_loader in module importlib._bootstrap:\n\nspec_from_loader(name, loader, *, origin=None, is_package=None)\n    Return a module spec based on various loader methods.",
        "syntax": "Syntax: spec_from_loader(name, loader, *, origin=None, is_package=None)",
        "other-params": ""
    },
    "collections.abc.ABCMeta": {
        "function": "ABCMeta(name, bases, namespace, /, **kwargs)",
        "alias": "ABCMeta",
        "help": "Help on class ABCMeta in module abc:\n\nclass ABCMeta(builtins.type)\n |  ABCMeta(name, bases, namespace, /, **kwargs)\n |\n |  Metaclass for defining Abstract Base Classes (ABCs).\n |\n |  Use this metaclass to create an ABC.  An ABC can be subclassed\n |  directly, and then acts as a mix-in class.  You can also register\n |  unrelated concrete classes (even built-in classes) and unrelated\n |  ABCs as 'virtual subclasses' -- these and their descendants will\n |  be considered subclasses of the registering ABC by the built-in\n |  issubclass() function, but the registering ABC won't show up in\n |  their MRO (Method Resolution Order) nor will method\n |  implementations defined by the registering ABC be callable (not\n |  even via super()).\n |\n |  Method resolution order:\n |      ABCMeta\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __instancecheck__(cls, instance)\n |      Override for isinstance(instance, cls).\n |\n |  __subclasscheck__(cls, subclass)\n |      Override for issubclass(subclass, cls).\n |\n |  register(cls, subclass)\n |      Register a virtual subclass of an ABC.\n |\n |      Returns the subclass, to allow usage as a class decorator.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(mcls, name, bases, namespace, /, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __dir__(self, /)\n |      Specialized __dir__ implementation for types.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.type:\n |\n |  __prepare__(name, bases, /, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'type'>\n |      type(object) -> the object's type\n |      type(name, bases, dict, **kwds) -> a new type\n |\n |\n |  __bases__ = (<class 'type'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155896320\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: ABCMeta(name, bases, namespace, /, **kwargs)",
        "other-params": ""
    },
    "collections.abc.AsyncGenerator": {
        "function": "AsyncGenerator()",
        "alias": "AsyncGenerator",
        "help": "Help on class AsyncGenerator in module collections.abc:\n\nclass AsyncGenerator(AsyncIterator)\n |  Method resolution order:\n |      AsyncGenerator\n |      AsyncIterator\n |      AsyncIterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __anext__(self)\n |      Return the next item from the asynchronous generator.\n |      When exhausted, raise StopAsyncIteration.\n |\n |  async aclose(self)\n |      Raise GeneratorExit inside coroutine.\n |\n |  async asend(self, value)\n |      Send a value into the asynchronous generator.\n |      Return next yielded value or raise StopAsyncIteration.\n |\n |  async athrow(self, typ, val=None, tb=None)\n |      Raise an exception in the asynchronous generator.\n |      Return next yielded value or raise StopAsyncIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'asend', 'athrow'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from AsyncIterator:\n |\n |  __aiter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AsyncIterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: AsyncGenerator()",
        "other-params": ""
    },
    "collections.abc.AsyncIterable": {
        "function": "AsyncIterable()",
        "alias": "AsyncIterable",
        "help": "Help on class AsyncIterable in module collections.abc:\n\nclass AsyncIterable(builtins.object)\n |  Methods defined here:\n |\n |  __aiter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__aiter__'})",
        "syntax": "Syntax: AsyncIterable()",
        "other-params": ""
    },
    "collections.abc.AsyncIterator": {
        "function": "AsyncIterator()",
        "alias": "AsyncIterator",
        "help": "Help on class AsyncIterator in module collections.abc:\n\nclass AsyncIterator(AsyncIterable)\n |  Method resolution order:\n |      AsyncIterator\n |      AsyncIterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __aiter__(self)\n |\n |  async __anext__(self)\n |      Return the next item or raise StopAsyncIteration when exhausted.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__anext__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AsyncIterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: AsyncIterator()",
        "other-params": ""
    },
    "collections.abc.Awaitable": {
        "function": "Awaitable()",
        "alias": "Awaitable",
        "help": "Help on class Awaitable in module collections.abc:\n\nclass Awaitable(builtins.object)\n |  Methods defined here:\n |\n |  __await__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__await__'})",
        "syntax": "Syntax: Awaitable()",
        "other-params": ""
    },
    "collections.abc.Buffer": {
        "function": "Buffer()",
        "alias": "Buffer",
        "help": "Help on class Buffer in module collections.abc:\n\nclass Buffer(builtins.object)\n |  Methods defined here:\n |\n |  __buffer__(self, flags: int, /) -> memoryview\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__buffer__'})",
        "syntax": "Syntax: Buffer()",
        "other-params": ""
    },
    "collections.abc.ByteString": {
        "function": "ByteString()",
        "alias": "ByteString",
        "help": "Help on class ByteString in module collections.abc:\n\nclass ByteString(Sequence)\n |  This unifies bytes and bytearray.\n |\n |  XXX Should add all their methods.\n |\n |  Method resolution order:\n |      ByteString\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__len__'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sequence:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: ByteString()",
        "other-params": ""
    },
    "collections.abc.Callable": {
        "function": "Callable()",
        "alias": "Callable",
        "help": "Help on class Callable in module collections.abc:\n\nclass Callable(builtins.object)\n |  Methods defined here:\n |\n |  __call__(self, *args, **kwds)\n |      Call self as a function.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = _CallableGenericAlias(args)\n |      Represent `Callable[argtypes, resulttype]`.\n |\n |      This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n |      followed by ``resulttype``.\n |\n |      Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n |      ``(int, str, float)``.\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__call__'})",
        "syntax": "Syntax: Callable()",
        "other-params": ""
    },
    "collections.abc.Collection": {
        "function": "Collection()",
        "alias": "Collection",
        "help": "Help on class Collection in module collections.abc:\n\nclass Collection(Sized, Iterable, Container)\n |  Method resolution order:\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: Collection()",
        "other-params": ""
    },
    "collections.abc.Container": {
        "function": "Container()",
        "alias": "Container",
        "help": "Help on class Container in module collections.abc:\n\nclass Container(builtins.object)\n |  Methods defined here:\n |\n |  __contains__(self, x)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__'})",
        "syntax": "Syntax: Container()",
        "other-params": ""
    },
    "collections.abc.Coroutine": {
        "function": "Coroutine()",
        "alias": "Coroutine",
        "help": "Help on class Coroutine in module collections.abc:\n\nclass Coroutine(Awaitable)\n |  Method resolution order:\n |      Coroutine\n |      Awaitable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  close(self)\n |      Raise GeneratorExit inside coroutine.\n |\n |  send(self, value)\n |      Send a value into the coroutine.\n |      Return next yielded value or raise StopIteration.\n |\n |  throw(self, typ, val=None, tb=None)\n |      Raise an exception in the coroutine.\n |      Return next yielded value or raise StopIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__await__', 'send', 'throw'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Awaitable:\n |\n |  __await__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Awaitable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Coroutine()",
        "other-params": ""
    },
    "collections.abc.EllipsisType": {
        "function": "EllipsisType()",
        "alias": "EllipsisType",
        "help": "Help on class ellipsis in module builtins:\n\nclass ellipsis(object)\n |  The type of the Ellipsis singleton.\n |\n |  Methods defined here:\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: EllipsisType()",
        "other-params": ""
    },
    "collections.abc.FunctionType": {
        "function": "FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "alias": "FunctionType",
        "help": "Help on class function in module builtins:\n\nclass function(object)\n |  function(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)\n |\n |  Create a function object.\n |\n |  code\n |    a code object\n |  globals\n |    the globals dictionary\n |  name\n |    a string that overrides the name from the code object\n |  argdefs\n |    a tuple that specifies the default argument values\n |  closure\n |    a tuple that supplies the bindings for free variables\n |  kwdefaults\n |    a dictionary that specifies the default keyword argument values\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __annotations__\n |\n |  __closure__\n |\n |  __code__\n |\n |  __defaults__\n |\n |  __dict__\n |\n |  __globals__\n |\n |  __kwdefaults__\n |\n |  __type_params__",
        "syntax": "Syntax: FunctionType(code, globals, name=None, argdefs=None, closure=None, kwdefaults=None)",
        "other-params": ""
    },
    "collections.abc.Generator": {
        "function": "Generator()",
        "alias": "Generator",
        "help": "Help on class Generator in module collections.abc:\n\nclass Generator(Iterator)\n |  Method resolution order:\n |      Generator\n |      Iterator\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __next__(self)\n |      Return the next item from the generator.\n |      When exhausted, raise StopIteration.\n |\n |  close(self)\n |      Raise GeneratorExit inside generator.\n |\n |  send(self, value)\n |      Send a value into the generator.\n |      Return next yielded value or raise StopIteration.\n |\n |  throw(self, typ, val=None, tb=None)\n |      Raise an exception in the generator.\n |      Return next yielded value or raise StopIteration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'send', 'throw'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterator:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Generator()",
        "other-params": ""
    },
    "collections.abc.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "collections.abc.Hashable": {
        "function": "Hashable()",
        "alias": "Hashable",
        "help": "Help on class Hashable in module collections.abc:\n\nclass Hashable(builtins.object)\n |  Methods defined here:\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__hash__'})",
        "syntax": "Syntax: Hashable()",
        "other-params": ""
    },
    "collections.abc.ItemsView": {
        "function": "ItemsView(mapping)",
        "alias": "ItemsView",
        "help": "Help on class ItemsView in module collections.abc:\n\nclass ItemsView(MappingView, Set)\n |  ItemsView(mapping)\n |\n |  Method resolution order:\n |      ItemsView\n |      MappingView\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, item)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: ItemsView(mapping)",
        "other-params": ""
    },
    "collections.abc.Iterable": {
        "function": "Iterable()",
        "alias": "Iterable",
        "help": "Help on class Iterable in module collections.abc:\n\nclass Iterable(builtins.object)\n |  Methods defined here:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__iter__'})",
        "syntax": "Syntax: Iterable()",
        "other-params": ""
    },
    "collections.abc.Iterator": {
        "function": "Iterator()",
        "alias": "Iterator",
        "help": "Help on class Iterator in module collections.abc:\n\nclass Iterator(Iterable)\n |  Method resolution order:\n |      Iterator\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __iter__(self)\n |\n |  __next__(self)\n |      Return the next item from the iterator. When exhausted, raise StopIteration\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__next__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Iterator()",
        "other-params": ""
    },
    "collections.abc.KeysView": {
        "function": "KeysView(mapping)",
        "alias": "KeysView",
        "help": "Help on class KeysView in module collections.abc:\n\nclass KeysView(MappingView, Set)\n |  KeysView(mapping)\n |\n |  Method resolution order:\n |      KeysView\n |      MappingView\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: KeysView(mapping)",
        "other-params": ""
    },
    "collections.abc.Mapping": {
        "function": "Mapping()",
        "alias": "Mapping",
        "help": "Help on class Mapping in module collections.abc:\n\nclass Mapping(Collection)\n |  A Mapping is a generic container for associating key/value\n |  pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __iter__, and __len__.\n |\n |  Method resolution order:\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__iter__', '__len__'}...\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Mapping()",
        "other-params": ""
    },
    "collections.abc.MappingView": {
        "function": "MappingView(mapping)",
        "alias": "MappingView",
        "help": "Help on class MappingView in module collections.abc:\n\nclass MappingView(Sized)\n |  MappingView(mapping)\n |\n |  Method resolution order:\n |      MappingView\n |      Sized\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Sized:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: MappingView(mapping)",
        "other-params": ""
    },
    "collections.abc.MutableMapping": {
        "function": "MutableMapping()",
        "alias": "MutableMapping",
        "help": "Help on class MutableMapping in module collections.abc:\n\nclass MutableMapping(Mapping)\n |  A MutableMapping is a generic container for associating\n |  key/value pairs.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __getitem__, __setitem__, __delitem__,\n |  __iter__, and __len__.\n |\n |  Method resolution order:\n |      MutableMapping\n |      Mapping\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, key)\n |\n |  __setitem__(self, key, value)\n |\n |  clear(self)\n |      D.clear() -> None.  Remove all items from D.\n |\n |  pop(self, key, default=<object object at 0x000001950D090200>)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised.\n |\n |  popitem(self)\n |      D.popitem() -> (k, v), remove and return some (key, value) pair\n |      as a 2-tuple; but raise KeyError if D is empty.\n |\n |  setdefault(self, key, default=None)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__delitem__', '__getitem__', '__iter...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Mapping:\n |\n |  __contains__(self, key)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __getitem__(self, key)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: MutableMapping()",
        "other-params": ""
    },
    "collections.abc.MutableSequence": {
        "function": "MutableSequence()",
        "alias": "MutableSequence",
        "help": "Help on class MutableSequence in module collections.abc:\n\nclass MutableSequence(Sequence)\n |  All the operations on a read-write sequence.\n |\n |  Concrete subclasses must provide __new__ or __init__,\n |  __getitem__, __setitem__, __delitem__, __len__, and insert().\n |\n |  Method resolution order:\n |      MutableSequence\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, index)\n |\n |  __iadd__(self, values)\n |\n |  __setitem__(self, index, value)\n |\n |  append(self, value)\n |      S.append(value) -- append value to the end of the sequence\n |\n |  clear(self)\n |      S.clear() -> None -- remove all items from S\n |\n |  extend(self, values)\n |      S.extend(iterable) -- extend sequence by appending elements from the iterable\n |\n |  insert(self, index, value)\n |      S.insert(index, value) -- insert value before index\n |\n |  pop(self, index=-1)\n |      S.pop([index]) -> item -- remove and return item at index (default last).\n |      Raise IndexError if list is empty or index is out of range.\n |\n |  remove(self, value)\n |      S.remove(value) -- remove first occurrence of value.\n |      Raise ValueError if the value is not present.\n |\n |  reverse(self)\n |      S.reverse() -- reverse *IN PLACE*\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__delitem__', '__getitem__', '__len_...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sequence:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: MutableSequence()",
        "other-params": ""
    },
    "collections.abc.MutableSet": {
        "function": "MutableSet()",
        "alias": "MutableSet",
        "help": "Help on class MutableSet in module collections.abc:\n\nclass MutableSet(Set)\n |  A mutable set is a finite, iterable container.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __contains__, __iter__, __len__,\n |  add(), and discard().\n |\n |  To override the comparisons (presumably for speed, as the\n |  semantics are fixed), all you have to do is redefine __le__ and\n |  then the other operations will automatically follow suit.\n |\n |  Method resolution order:\n |      MutableSet\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __iand__(self, it)\n |\n |  __ior__(self, it)\n |\n |  __isub__(self, it)\n |\n |  __ixor__(self, it)\n |\n |  add(self, value)\n |      Add an element.\n |\n |  clear(self)\n |      This is slow (creates N new iterators!) but effective.\n |\n |  discard(self, value)\n |      Remove an element.  Do not raise an exception if absent.\n |\n |  pop(self)\n |      Return the popped value.  Raise KeyError if empty.\n |\n |  remove(self, value)\n |      Remove an element. If not a member, raise a KeyError.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: MutableSet()",
        "other-params": ""
    },
    "collections.abc.Reversible": {
        "function": "Reversible()",
        "alias": "Reversible",
        "help": "Help on class Reversible in module collections.abc:\n\nclass Reversible(Iterable)\n |  Method resolution order:\n |      Reversible\n |      Iterable\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__iter__', '__reversed__'})\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Reversible()",
        "other-params": ""
    },
    "collections.abc.Sequence": {
        "function": "Sequence()",
        "alias": "Sequence",
        "help": "Help on class Sequence in module collections.abc:\n\nclass Sequence(Reversible, Collection)\n |  All the operations on a read-only sequence.\n |\n |  Concrete subclasses must override __new__ or __init__,\n |  __getitem__, and __len__.\n |\n |  Method resolution order:\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__len__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Sequence()",
        "other-params": ""
    },
    "collections.abc.Set": {
        "function": "Set()",
        "alias": "Set",
        "help": "Help on class Set in module collections.abc:\n\nclass Set(Collection)\n |  A set is a finite, iterable container.\n |\n |  This class provides concrete generic implementations of all\n |  methods except for __contains__, __iter__ and __len__.\n |\n |  To override the comparisons (presumably for speed, as the\n |  semantics are fixed), redefine __le__ and __ge__,\n |  then the other operations will automatically follow suit.\n |\n |  Method resolution order:\n |      Set\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__contains__', '__iter__', '__len__'...\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Iterable:\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Container:\n |\n |  __contains__(self, x)",
        "syntax": "Syntax: Set()",
        "other-params": ""
    },
    "collections.abc.Sized": {
        "function": "Sized()",
        "alias": "Sized",
        "help": "Help on class Sized in module collections.abc:\n\nclass Sized(builtins.object)\n |  Methods defined here:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__len__'})",
        "syntax": "Syntax: Sized()",
        "other-params": ""
    },
    "collections.abc.ValuesView": {
        "function": "ValuesView(mapping)",
        "alias": "ValuesView",
        "help": "Help on class ValuesView in module collections.abc:\n\nclass ValuesView(MappingView, Collection)\n |  ValuesView(mapping)\n |\n |  Method resolution order:\n |      ValuesView\n |      MappingView\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, value)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: ValuesView(mapping)",
        "other-params": ""
    },
    "collections.abc._CallableGenericAlias": {
        "function": "_CallableGenericAlias(origin, args)",
        "alias": "_CallableGenericAlias",
        "help": "Help on class _CallableGenericAlias in module collections.abc:\n\nclass _CallableGenericAlias(types.GenericAlias)\n |  _CallableGenericAlias(origin, args)\n |\n |  Represent `Callable[argtypes, resulttype]`.\n |\n |  This sets ``__args__`` to a tuple containing the flattened ``argtypes``\n |  followed by ``resulttype``.\n |\n |  Example: ``Callable[[int, str], float]`` sets ``__args__`` to\n |  ``(int, str, float)``.\n |\n |  Method resolution order:\n |      _CallableGenericAlias\n |      types.GenericAlias\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getitem__(self, item)\n |      Return self[key].\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, origin, args)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from types.GenericAlias:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from types.GenericAlias:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: _CallableGenericAlias(origin, args)",
        "other-params": ""
    },
    "collections.abc._DeprecateByteStringMeta": {
        "function": "_DeprecateByteStringMeta(name, bases, namespace, **kwargs)",
        "alias": "_DeprecateByteStringMeta",
        "help": "Help on class _DeprecateByteStringMeta in module collections.abc:\n\nclass _DeprecateByteStringMeta(abc.ABCMeta)\n |  _DeprecateByteStringMeta(name, bases, namespace, **kwargs)\n |\n |  Method resolution order:\n |      _DeprecateByteStringMeta\n |      abc.ABCMeta\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __instancecheck__(cls, instance)\n |      Override for isinstance(instance, cls).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, name, bases, namespace, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from abc.ABCMeta:\n |\n |  __subclasscheck__(cls, subclass)\n |      Override for issubclass(subclass, cls).\n |\n |  register(cls, subclass)\n |      Register a virtual subclass of an ABC.\n |\n |      Returns the subclass, to allow usage as a class decorator.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __dir__(self, /)\n |      Specialized __dir__ implementation for types.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.type:\n |\n |  __prepare__(name, bases, /, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'abc.ABCMeta'>\n |      Metaclass for defining Abstract Base Classes (ABCs).\n |\n |      Use this metaclass to create an ABC.  An ABC can be subclassed\n |      directly, and then acts as a mix-in class.  You can also register\n |      unrelated concrete classes (even built-in classes) and unrelated\n |      ABCs as 'virtual subclasses' -- these and their descendants will\n |      be considered subclasses of the registering ABC by the built-in\n |      issubclass() function, but the registering ABC won't show up in\n |      their MRO (Method Resolution Order) nor will method\n |      implementations defined by the registering ABC be callable (not\n |      even via super()).\n |\n |\n |  __bases__ = (<class 'abc.ABCMeta'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155896320\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'collections.abc._DeprecateByteStringMeta'>, <class ...\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: _DeprecateByteStringMeta(name, bases, namespace, **kwargs)",
        "other-params": ""
    },
    "collections.abc._check_methods": {
        "function": "_check_methods(C, *methods)",
        "alias": "_check_methods",
        "help": "Help on function _check_methods in module collections.abc:\n\n_check_methods(C, *methods)",
        "syntax": "Syntax: _check_methods(C, *methods)",
        "other-params": ""
    },
    "collections.abc._is_param_expr": {
        "function": "_is_param_expr(obj)",
        "alias": "_is_param_expr",
        "help": "Help on function _is_param_expr in module collections.abc:\n\n_is_param_expr(obj)\n    Checks if obj matches either a list of types, ``...``, ``ParamSpec`` or\n    ``_ConcatenateGenericAlias`` from typing.py",
        "syntax": "Syntax: _is_param_expr(obj)",
        "other-params": ""
    },
    "collections.abc._type_repr": {
        "function": "_type_repr(obj)",
        "alias": "_type_repr",
        "help": "Help on function _type_repr in module collections.abc:\n\n_type_repr(obj)\n    Return the repr() of an object, special-casing types (internal helper).\n\n    Copied from :mod:`typing` since collections.abc\n    shouldn't depend on that module.\n    (Keep this roughly in sync with the typing version.)",
        "syntax": "Syntax: _type_repr(obj)",
        "other-params": ""
    },
    "collections.abc.abstractmethod": {
        "function": "abstractmethod(funcobj)",
        "alias": "abstractmethod",
        "help": "Help on function abstractmethod in module abc:\n\nabstractmethod(funcobj)\n    A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...",
        "syntax": "Syntax: abstractmethod(funcobj)",
        "other-params": ""
    },
    "collections.abc.async_generator": {
        "function": "async_generator()",
        "alias": "async_generator",
        "help": "Help on class async_generator in module builtins:\n\nclass async_generator(object)\n |  Methods defined here:\n |\n |  __aiter__(self, /)\n |      Return an awaitable, that resolves in asynchronous iterator.\n |\n |  __anext__(self, /)\n |      Return a value or raise StopAsyncIteration.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  aclose(self, /)\n |      aclose() -> raise GeneratorExit inside generator.\n |\n |  asend(self, object, /)\n |      asend(v) -> send 'v' in generator.\n |\n |  athrow(...)\n |      athrow(value)\n |      athrow(type[,value[,tb]])\n |\n |      raise exception in generator.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  ag_await\n |      object being awaited on, or None\n |\n |  ag_code\n |\n |  ag_frame\n |\n |  ag_running\n |\n |  ag_suspended",
        "syntax": "Syntax: async_generator()",
        "other-params": ""
    },
    "collections.abc.bytearray_iterator": {
        "function": "bytearray_iterator()",
        "alias": "bytearray_iterator",
        "help": "Help on class bytearray_iterator in module builtins:\n\nclass bytearray_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: bytearray_iterator()",
        "other-params": ""
    },
    "collections.abc.bytes_iterator": {
        "function": "bytes_iterator()",
        "alias": "bytes_iterator",
        "help": "Help on class bytes_iterator in module builtins:\n\nclass bytes_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: bytes_iterator()",
        "other-params": ""
    },
    "collections.abc.coroutine": {
        "function": "coroutine()",
        "alias": "coroutine",
        "help": "Help on class coroutine in module builtins:\n\nclass coroutine(object)\n |  Methods defined here:\n |\n |  __await__(self, /)\n |      Return an iterator to be used in await expression.\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside coroutine.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into coroutine,\n |      return next iterated value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,traceback]])\n |\n |      Raise exception in coroutine, return next iterated value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  cr_await\n |      object being awaited on, or None\n |\n |  cr_code\n |\n |  cr_frame\n |\n |  cr_origin\n |\n |  cr_running\n |\n |  cr_suspended",
        "syntax": "Syntax: coroutine()",
        "other-params": ""
    },
    "collections.abc.dict_itemiterator": {
        "function": "dict_itemiterator()",
        "alias": "dict_itemiterator",
        "help": "Help on class dict_itemiterator in module builtins:\n\nclass dict_itemiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_itemiterator()",
        "other-params": ""
    },
    "collections.abc.dict_items": {
        "function": "dict_items()",
        "alias": "dict_items",
        "help": "Help on class dict_items in module builtins:\n\nclass dict_items(object)\n |  Built-in subclasses:\n |      odict_items\n |\n |  Methods defined here:\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict items.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  isdisjoint(self, object, /)\n |      Return True if the view and the given iterable have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: dict_items()",
        "other-params": ""
    },
    "collections.abc.dict_keyiterator": {
        "function": "dict_keyiterator()",
        "alias": "dict_keyiterator",
        "help": "Help on class dict_keyiterator in module builtins:\n\nclass dict_keyiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_keyiterator()",
        "other-params": ""
    },
    "collections.abc.dict_keys": {
        "function": "dict_keys()",
        "alias": "dict_keys",
        "help": "Help on class dict_keys in module builtins:\n\nclass dict_keys(object)\n |  Built-in subclasses:\n |      odict_keys\n |\n |  Methods defined here:\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  isdisjoint(self, object, /)\n |      Return True if the view and the given iterable have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: dict_keys()",
        "other-params": ""
    },
    "collections.abc.dict_valueiterator": {
        "function": "dict_valueiterator()",
        "alias": "dict_valueiterator",
        "help": "Help on class dict_valueiterator in module builtins:\n\nclass dict_valueiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: dict_valueiterator()",
        "other-params": ""
    },
    "collections.abc.dict_values": {
        "function": "dict_values()",
        "alias": "dict_values",
        "help": "Help on class dict_values in module builtins:\n\nclass dict_values(object)\n |  Built-in subclasses:\n |      odict_values\n |\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict values.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  mapping\n |      dictionary that this view refers to",
        "syntax": "Syntax: dict_values()",
        "other-params": ""
    },
    "collections.abc.framelocalsproxy": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'FrameLocalsProxy'>",
        "alias": "framelocalsproxy",
        "help": "Help on class FrameLocalsProxy in module builtins:\n\nclass FrameLocalsProxy(object)\n |  Methods defined here:\n |\n |  __contains__(self, object, /)\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, object, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  copy(self, /)\n |\n |  get(...)\n |\n |  items(self, /)\n |\n |  keys(self, /)\n |\n |  pop(...)\n |\n |  setdefault(...)\n |\n |  update(self, object, /)\n |\n |  values(self, /)\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'FrameLocalsProxy'>",
        "other-params": ""
    },
    "collections.abc.generator": {
        "function": "generator()",
        "alias": "generator",
        "help": "Help on class generator in module builtins:\n\nclass generator(object)\n |  Methods defined here:\n |\n |  __del__(self, /)\n |      Called when the instance is about to be destroyed.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __sizeof__(self, /)\n |      gen.__sizeof__() -> size of gen in memory, in bytes\n |\n |  close(self, /)\n |      close() -> raise GeneratorExit inside generator.\n |\n |  send(self, object, /)\n |      send(arg) -> send 'arg' into generator,\n |      return next yielded value or raise StopIteration.\n |\n |  throw(...)\n |      throw(value)\n |      throw(type[,value[,tb]])\n |\n |      Raise exception in generator, return next yielded value or raise\n |      StopIteration.\n |      the (type, val, tb) signature is deprecated,\n |      and may be removed in a future version of Python.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  gi_code\n |\n |  gi_frame\n |\n |  gi_running\n |\n |  gi_suspended\n |\n |  gi_yieldfrom\n |      object being iterated by yield from, or None",
        "syntax": "Syntax: generator()",
        "other-params": ""
    },
    "collections.abc.list_iterator": {
        "function": "list_iterator()",
        "alias": "list_iterator",
        "help": "Help on class list_iterator in module builtins:\n\nclass list_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: list_iterator()",
        "other-params": ""
    },
    "collections.abc.list_reverseiterator": {
        "function": "list_reverseiterator()",
        "alias": "list_reverseiterator",
        "help": "Help on class list_reverseiterator in module builtins:\n\nclass list_reverseiterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: list_reverseiterator()",
        "other-params": ""
    },
    "collections.abc.longrange_iterator": {
        "function": "longrange_iterator()",
        "alias": "longrange_iterator",
        "help": "Help on class longrange_iterator in module builtins:\n\nclass longrange_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: longrange_iterator()",
        "other-params": ""
    },
    "collections.abc.mappingproxy": {
        "function": "mappingproxy(mapping)",
        "alias": "mappingproxy",
        "help": "Help on class mappingproxy in module builtins:\n\nclass mappingproxy(object)\n |  mappingproxy(mapping)\n |\n |  Read-only proxy of a mapping.\n |\n |  Methods defined here:\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      D.__reversed__() -> reverse iterator\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  copy(self, /)\n |      D.copy() -> a shallow copy of D\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the mapping, else default.\n |\n |  items(self, /)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self, /)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self, /)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: mappingproxy(mapping)",
        "other-params": ""
    },
    "collections.abc.range_iterator": {
        "function": "range_iterator()",
        "alias": "range_iterator",
        "help": "Help on class range_iterator in module builtins:\n\nclass range_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: range_iterator()",
        "other-params": ""
    },
    "collections.abc.set_iterator": {
        "function": "set_iterator()",
        "alias": "set_iterator",
        "help": "Help on class set_iterator in module builtins:\n\nclass set_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.",
        "syntax": "Syntax: set_iterator()",
        "other-params": ""
    },
    "collections.abc.str_iterator": {
        "function": "str_iterator()",
        "alias": "str_iterator",
        "help": "Help on class str_ascii_iterator in module builtins:\n\nclass str_ascii_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: str_iterator()",
        "other-params": ""
    },
    "collections.abc.tuple_iterator": {
        "function": "tuple_iterator()",
        "alias": "tuple_iterator",
        "help": "Help on class tuple_iterator in module builtins:\n\nclass tuple_iterator(object)\n |  Methods defined here:\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.",
        "syntax": "Syntax: tuple_iterator()",
        "other-params": ""
    },
    "collections.abc.zip_iterator": {
        "function": "zip_iterator(*iterables, strict=False)",
        "alias": "zip_iterator",
        "help": "Help on class zip in module builtins:\n\nclass zip(object)\n |  zip(*iterables, strict=False)\n |\n |  The zip object yields n-length tuples, where n is the number of iterables\n |  passed as positional arguments to zip().  The i-th element in every tuple\n |  comes from the i-th iterable argument to zip().  This continues until the\n |  shortest argument is exhausted.\n |\n |  If strict is true and one of the arguments is exhausted before the others,\n |  raise a ValueError.\n |\n |     >>> list(zip('abcdefg', range(3), range(4)))\n |     [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: zip_iterator(*iterables, strict=False)",
        "other-params": ""
    },
    "keyword.iskeyword": {
        "function": "iskeyword(object, /)",
        "alias": "iskeyword",
        "help": "Help on built-in function __contains__:\n\n__contains__(object, /) method of builtins.frozenset instance\n    x.__contains__(y) <==> y in x.",
        "syntax": "Syntax: iskeyword(object, /)",
        "other-params": ""
    },
    "keyword.issoftkeyword": {
        "function": "issoftkeyword(object, /)",
        "alias": "issoftkeyword",
        "help": "Help on built-in function __contains__:\n\n__contains__(object, /) method of builtins.frozenset instance\n    x.__contains__(y) <==> y in x.",
        "syntax": "Syntax: issoftkeyword(object, /)",
        "other-params": ""
    },
    "operator._abs": {
        "function": "_abs(x, /)",
        "alias": "_abs",
        "help": "Help on built-in function abs in module builtins:\n\nabs(x, /)\n    Return the absolute value of the argument.",
        "syntax": "Syntax: _abs(x, /)",
        "other-params": ""
    },
    "operator.abs": {
        "function": "abs(a, /)",
        "alias": "abs",
        "help": "Help on built-in function abs in module _operator:\n\nabs(a, /)\n    Same as abs(a).",
        "syntax": "Syntax: abs(a, /)",
        "other-params": ""
    },
    "operator.add": {
        "function": "add(a, b, /)",
        "alias": "add",
        "help": "Help on built-in function add in module _operator:\n\nadd(a, b, /)\n    Same as a + b.",
        "syntax": "Syntax: add(a, b, /)",
        "other-params": ""
    },
    "operator.and_": {
        "function": "and_(a, b, /)",
        "alias": "and_",
        "help": "Help on built-in function and_ in module _operator:\n\nand_(a, b, /)\n    Same as a & b.",
        "syntax": "Syntax: and_(a, b, /)",
        "other-params": ""
    },
    "operator.attrgetter": {
        "function": "attrgetter(attr, /, *attrs)",
        "alias": "attrgetter",
        "help": "Help on class attrgetter in module operator:\n\nclass attrgetter(builtins.object)\n |  attrgetter(attr, /, *attrs)\n |\n |  Return a callable object that fetches the given attribute(s) from its operand.\n |  After f = attrgetter('name'), the call f(r) returns r.name.\n |  After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n |  After h = attrgetter('name.first', 'name.last'), the call h(r) returns\n |  (r.name.first, r.name.last).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __vectorcalloffset__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __text_signature__ = '(attr, /, *attrs)'",
        "syntax": "Syntax: attrgetter(attr, /, *attrs)",
        "other-params": ""
    },
    "operator.call": {
        "function": "call(obj, /, *args, **kwargs)",
        "alias": "call",
        "help": "Help on built-in function call in module _operator:\n\ncall(obj, /, *args, **kwargs)\n    Same as obj(*args, **kwargs).",
        "syntax": "Syntax: call(obj, /, *args, **kwargs)",
        "other-params": ""
    },
    "operator.concat": {
        "function": "concat(a, b, /)",
        "alias": "concat",
        "help": "Help on built-in function concat in module _operator:\n\nconcat(a, b, /)\n    Same as a + b, for a and b sequences.",
        "syntax": "Syntax: concat(a, b, /)",
        "other-params": ""
    },
    "operator.contains": {
        "function": "contains(a, b, /)",
        "alias": "contains",
        "help": "Help on built-in function contains in module _operator:\n\ncontains(a, b, /)\n    Same as b in a (note reversed operands).",
        "syntax": "Syntax: contains(a, b, /)",
        "other-params": ""
    },
    "operator.countOf": {
        "function": "countOf(a, b, /)",
        "alias": "countOf",
        "help": "Help on built-in function countOf in module _operator:\n\ncountOf(a, b, /)\n    Return the number of items in a which are, or which equal, b.",
        "syntax": "Syntax: countOf(a, b, /)",
        "other-params": ""
    },
    "operator.delitem": {
        "function": "delitem(a, b, /)",
        "alias": "delitem",
        "help": "Help on built-in function delitem in module _operator:\n\ndelitem(a, b, /)\n    Same as del a[b].",
        "syntax": "Syntax: delitem(a, b, /)",
        "other-params": ""
    },
    "operator.eq": {
        "function": "eq(a, b, /)",
        "alias": "eq",
        "help": "Help on built-in function eq in module _operator:\n\neq(a, b, /)\n    Same as a == b.",
        "syntax": "Syntax: eq(a, b, /)",
        "other-params": ""
    },
    "operator.floordiv": {
        "function": "floordiv(a, b, /)",
        "alias": "floordiv",
        "help": "Help on built-in function floordiv in module _operator:\n\nfloordiv(a, b, /)\n    Same as a // b.",
        "syntax": "Syntax: floordiv(a, b, /)",
        "other-params": ""
    },
    "operator.ge": {
        "function": "ge(a, b, /)",
        "alias": "ge",
        "help": "Help on built-in function ge in module _operator:\n\nge(a, b, /)\n    Same as a >= b.",
        "syntax": "Syntax: ge(a, b, /)",
        "other-params": ""
    },
    "operator.getitem": {
        "function": "getitem(a, b, /)",
        "alias": "getitem",
        "help": "Help on built-in function getitem in module _operator:\n\ngetitem(a, b, /)\n    Same as a[b].",
        "syntax": "Syntax: getitem(a, b, /)",
        "other-params": ""
    },
    "operator.gt": {
        "function": "gt(a, b, /)",
        "alias": "gt",
        "help": "Help on built-in function gt in module _operator:\n\ngt(a, b, /)\n    Same as a > b.",
        "syntax": "Syntax: gt(a, b, /)",
        "other-params": ""
    },
    "operator.iadd": {
        "function": "iadd(a, b, /)",
        "alias": "iadd",
        "help": "Help on built-in function iadd in module _operator:\n\niadd(a, b, /)\n    Same as a += b.",
        "syntax": "Syntax: iadd(a, b, /)",
        "other-params": ""
    },
    "operator.iand": {
        "function": "iand(a, b, /)",
        "alias": "iand",
        "help": "Help on built-in function iand in module _operator:\n\niand(a, b, /)\n    Same as a &= b.",
        "syntax": "Syntax: iand(a, b, /)",
        "other-params": ""
    },
    "operator.iconcat": {
        "function": "iconcat(a, b, /)",
        "alias": "iconcat",
        "help": "Help on built-in function iconcat in module _operator:\n\niconcat(a, b, /)\n    Same as a += b, for a and b sequences.",
        "syntax": "Syntax: iconcat(a, b, /)",
        "other-params": ""
    },
    "operator.ifloordiv": {
        "function": "ifloordiv(a, b, /)",
        "alias": "ifloordiv",
        "help": "Help on built-in function ifloordiv in module _operator:\n\nifloordiv(a, b, /)\n    Same as a //= b.",
        "syntax": "Syntax: ifloordiv(a, b, /)",
        "other-params": ""
    },
    "operator.ilshift": {
        "function": "ilshift(a, b, /)",
        "alias": "ilshift",
        "help": "Help on built-in function ilshift in module _operator:\n\nilshift(a, b, /)\n    Same as a <<= b.",
        "syntax": "Syntax: ilshift(a, b, /)",
        "other-params": ""
    },
    "operator.imatmul": {
        "function": "imatmul(a, b, /)",
        "alias": "imatmul",
        "help": "Help on built-in function imatmul in module _operator:\n\nimatmul(a, b, /)\n    Same as a @= b.",
        "syntax": "Syntax: imatmul(a, b, /)",
        "other-params": ""
    },
    "operator.imod": {
        "function": "imod(a, b, /)",
        "alias": "imod",
        "help": "Help on built-in function imod in module _operator:\n\nimod(a, b, /)\n    Same as a %= b.",
        "syntax": "Syntax: imod(a, b, /)",
        "other-params": ""
    },
    "operator.imul": {
        "function": "imul(a, b, /)",
        "alias": "imul",
        "help": "Help on built-in function imul in module _operator:\n\nimul(a, b, /)\n    Same as a *= b.",
        "syntax": "Syntax: imul(a, b, /)",
        "other-params": ""
    },
    "operator.index": {
        "function": "index(a, /)",
        "alias": "index",
        "help": "Help on built-in function index in module _operator:\n\nindex(a, /)\n    Same as a.__index__()",
        "syntax": "Syntax: index(a, /)",
        "other-params": ""
    },
    "operator.indexOf": {
        "function": "indexOf(a, b, /)",
        "alias": "indexOf",
        "help": "Help on built-in function indexOf in module _operator:\n\nindexOf(a, b, /)\n    Return the first index of b in a.",
        "syntax": "Syntax: indexOf(a, b, /)",
        "other-params": ""
    },
    "operator.inv": {
        "function": "inv(a, /)",
        "alias": "inv",
        "help": "Help on built-in function inv in module _operator:\n\ninv(a, /)\n    Same as ~a.",
        "syntax": "Syntax: inv(a, /)",
        "other-params": ""
    },
    "operator.invert": {
        "function": "invert(a, /)",
        "alias": "invert",
        "help": "Help on built-in function invert in module _operator:\n\ninvert(a, /)\n    Same as ~a.",
        "syntax": "Syntax: invert(a, /)",
        "other-params": ""
    },
    "operator.ior": {
        "function": "ior(a, b, /)",
        "alias": "ior",
        "help": "Help on built-in function ior in module _operator:\n\nior(a, b, /)\n    Same as a |= b.",
        "syntax": "Syntax: ior(a, b, /)",
        "other-params": ""
    },
    "operator.ipow": {
        "function": "ipow(a, b, /)",
        "alias": "ipow",
        "help": "Help on built-in function ipow in module _operator:\n\nipow(a, b, /)\n    Same as a **= b.",
        "syntax": "Syntax: ipow(a, b, /)",
        "other-params": ""
    },
    "operator.irshift": {
        "function": "irshift(a, b, /)",
        "alias": "irshift",
        "help": "Help on built-in function irshift in module _operator:\n\nirshift(a, b, /)\n    Same as a >>= b.",
        "syntax": "Syntax: irshift(a, b, /)",
        "other-params": ""
    },
    "operator.is_": {
        "function": "is_(a, b, /)",
        "alias": "is_",
        "help": "Help on built-in function is_ in module _operator:\n\nis_(a, b, /)\n    Same as a is b.",
        "syntax": "Syntax: is_(a, b, /)",
        "other-params": ""
    },
    "operator.is_not": {
        "function": "is_not(a, b, /)",
        "alias": "is_not",
        "help": "Help on built-in function is_not in module _operator:\n\nis_not(a, b, /)\n    Same as a is not b.",
        "syntax": "Syntax: is_not(a, b, /)",
        "other-params": ""
    },
    "operator.isub": {
        "function": "isub(a, b, /)",
        "alias": "isub",
        "help": "Help on built-in function isub in module _operator:\n\nisub(a, b, /)\n    Same as a -= b.",
        "syntax": "Syntax: isub(a, b, /)",
        "other-params": ""
    },
    "operator.itemgetter": {
        "function": "itemgetter(item, /, *items)",
        "alias": "itemgetter",
        "help": "Help on class itemgetter in module operator:\n\nclass itemgetter(builtins.object)\n |  itemgetter(item, /, *items)\n |\n |  Return a callable object that fetches the given item(s) from its operand.\n |  After f = itemgetter(2), the call f(r) returns r[2].\n |  After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __vectorcalloffset__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __text_signature__ = '(item, /, *items)'",
        "syntax": "Syntax: itemgetter(item, /, *items)",
        "other-params": ""
    },
    "operator.itruediv": {
        "function": "itruediv(a, b, /)",
        "alias": "itruediv",
        "help": "Help on built-in function itruediv in module _operator:\n\nitruediv(a, b, /)\n    Same as a /= b.",
        "syntax": "Syntax: itruediv(a, b, /)",
        "other-params": ""
    },
    "operator.ixor": {
        "function": "ixor(a, b, /)",
        "alias": "ixor",
        "help": "Help on built-in function ixor in module _operator:\n\nixor(a, b, /)\n    Same as a ^= b.",
        "syntax": "Syntax: ixor(a, b, /)",
        "other-params": ""
    },
    "operator.le": {
        "function": "le(a, b, /)",
        "alias": "le",
        "help": "Help on built-in function le in module _operator:\n\nle(a, b, /)\n    Same as a <= b.",
        "syntax": "Syntax: le(a, b, /)",
        "other-params": ""
    },
    "operator.length_hint": {
        "function": "length_hint(obj, default=0, /)",
        "alias": "length_hint",
        "help": "Help on built-in function length_hint in module _operator:\n\nlength_hint(obj, default=0, /)\n    Return an estimate of the number of items in obj.\n\n    This is useful for presizing containers when building from an iterable.\n\n    If the object supports len(), the result will be exact.\n    Otherwise, it may over- or under-estimate by an arbitrary amount.\n    The result will be an integer >= 0.",
        "syntax": "Syntax: length_hint(obj, default=0, /)",
        "other-params": ""
    },
    "operator.lshift": {
        "function": "lshift(a, b, /)",
        "alias": "lshift",
        "help": "Help on built-in function lshift in module _operator:\n\nlshift(a, b, /)\n    Same as a << b.",
        "syntax": "Syntax: lshift(a, b, /)",
        "other-params": ""
    },
    "operator.lt": {
        "function": "lt(a, b, /)",
        "alias": "lt",
        "help": "Help on built-in function lt in module _operator:\n\nlt(a, b, /)\n    Same as a < b.",
        "syntax": "Syntax: lt(a, b, /)",
        "other-params": ""
    },
    "operator.matmul": {
        "function": "matmul(a, b, /)",
        "alias": "matmul",
        "help": "Help on built-in function matmul in module _operator:\n\nmatmul(a, b, /)\n    Same as a @ b.",
        "syntax": "Syntax: matmul(a, b, /)",
        "other-params": ""
    },
    "operator.methodcaller": {
        "function": "methodcaller(name, /, *args, **kwargs)",
        "alias": "methodcaller",
        "help": "Help on class methodcaller in module operator:\n\nclass methodcaller(builtins.object)\n |  methodcaller(name, /, *args, **kwargs)\n |\n |  Return a callable object that calls the given method on its operand.\n |  After f = methodcaller('name'), the call f(r) returns r.name().\n |  After g = methodcaller('name', 'date', foo=1), the call g(r) returns\n |  r.name('date', foo=1).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __vectorcalloffset__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __text_signature__ = '(name, /, *args, **kwargs)'",
        "syntax": "Syntax: methodcaller(name, /, *args, **kwargs)",
        "other-params": ""
    },
    "operator.mod": {
        "function": "mod(a, b, /)",
        "alias": "mod",
        "help": "Help on built-in function mod in module _operator:\n\nmod(a, b, /)\n    Same as a % b.",
        "syntax": "Syntax: mod(a, b, /)",
        "other-params": ""
    },
    "operator.mul": {
        "function": "mul(a, b, /)",
        "alias": "mul",
        "help": "Help on built-in function mul in module _operator:\n\nmul(a, b, /)\n    Same as a * b.",
        "syntax": "Syntax: mul(a, b, /)",
        "other-params": ""
    },
    "operator.ne": {
        "function": "ne(a, b, /)",
        "alias": "ne",
        "help": "Help on built-in function ne in module _operator:\n\nne(a, b, /)\n    Same as a != b.",
        "syntax": "Syntax: ne(a, b, /)",
        "other-params": ""
    },
    "operator.neg": {
        "function": "neg(a, /)",
        "alias": "neg",
        "help": "Help on built-in function neg in module _operator:\n\nneg(a, /)\n    Same as -a.",
        "syntax": "Syntax: neg(a, /)",
        "other-params": ""
    },
    "operator.not_": {
        "function": "not_(a, /)",
        "alias": "not_",
        "help": "Help on built-in function not_ in module _operator:\n\nnot_(a, /)\n    Same as not a.",
        "syntax": "Syntax: not_(a, /)",
        "other-params": ""
    },
    "operator.or_": {
        "function": "or_(a, b, /)",
        "alias": "or_",
        "help": "Help on built-in function or_ in module _operator:\n\nor_(a, b, /)\n    Same as a | b.",
        "syntax": "Syntax: or_(a, b, /)",
        "other-params": ""
    },
    "operator.pos": {
        "function": "pos(a, /)",
        "alias": "pos",
        "help": "Help on built-in function pos in module _operator:\n\npos(a, /)\n    Same as +a.",
        "syntax": "Syntax: pos(a, /)",
        "other-params": ""
    },
    "operator.pow": {
        "function": "pow(a, b, /)",
        "alias": "pow",
        "help": "Help on built-in function pow in module _operator:\n\npow(a, b, /)\n    Same as a ** b.",
        "syntax": "Syntax: pow(a, b, /)",
        "other-params": ""
    },
    "operator.rshift": {
        "function": "rshift(a, b, /)",
        "alias": "rshift",
        "help": "Help on built-in function rshift in module _operator:\n\nrshift(a, b, /)\n    Same as a >> b.",
        "syntax": "Syntax: rshift(a, b, /)",
        "other-params": ""
    },
    "operator.setitem": {
        "function": "setitem(a, b, c, /)",
        "alias": "setitem",
        "help": "Help on built-in function setitem in module _operator:\n\nsetitem(a, b, c, /)\n    Same as a[b] = c.",
        "syntax": "Syntax: setitem(a, b, c, /)",
        "other-params": ""
    },
    "operator.sub": {
        "function": "sub(a, b, /)",
        "alias": "sub",
        "help": "Help on built-in function sub in module _operator:\n\nsub(a, b, /)\n    Same as a - b.",
        "syntax": "Syntax: sub(a, b, /)",
        "other-params": ""
    },
    "operator.truediv": {
        "function": "truediv(a, b, /)",
        "alias": "truediv",
        "help": "Help on built-in function truediv in module _operator:\n\ntruediv(a, b, /)\n    Same as a / b.",
        "syntax": "Syntax: truediv(a, b, /)",
        "other-params": ""
    },
    "operator.truth": {
        "function": "truth(a, /)",
        "alias": "truth",
        "help": "Help on built-in function truth in module _operator:\n\ntruth(a, /)\n    Return True if a is true, False otherwise.",
        "syntax": "Syntax: truth(a, /)",
        "other-params": ""
    },
    "operator.xor": {
        "function": "xor(a, b, /)",
        "alias": "xor",
        "help": "Help on built-in function xor in module _operator:\n\nxor(a, b, /)\n    Same as a ^ b.",
        "syntax": "Syntax: xor(a, b, /)",
        "other-params": ""
    },
    "reprlib.Repr": {
        "function": "Repr(*, maxlevel=6, maxtuple=6, maxlist=6, maxarray=5, maxdict=4, maxset=6, maxfrozenset=6, maxdeque=6, maxstring=30, maxlong=40, maxother=30, fillvalue='...', indent=None)",
        "alias": "Repr",
        "help": "Help on class Repr in module reprlib:\n\nclass Repr(builtins.object)\n |  Repr(\n |      *,\n |      maxlevel=6,\n |      maxtuple=6,\n |      maxlist=6,\n |      maxarray=5,\n |      maxdict=4,\n |      maxset=6,\n |      maxfrozenset=6,\n |      maxdeque=6,\n |      maxstring=30,\n |      maxlong=40,\n |      maxother=30,\n |      fillvalue='...',\n |      indent=None\n |  )\n |\n |  Methods defined here:\n |\n |  __init__(\n |      self,\n |      *,\n |      maxlevel=6,\n |      maxtuple=6,\n |      maxlist=6,\n |      maxarray=5,\n |      maxdict=4,\n |      maxset=6,\n |      maxfrozenset=6,\n |      maxdeque=6,\n |      maxstring=30,\n |      maxlong=40,\n |      maxother=30,\n |      fillvalue='...',\n |      indent=None\n |  )\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  repr(self, x)\n |\n |  repr1(self, x, level)\n |\n |  repr_array(self, x, level)\n |\n |  repr_deque(self, x, level)\n |\n |  repr_dict(self, x, level)\n |\n |  repr_frozenset(self, x, level)\n |\n |  repr_instance(self, x, level)\n |\n |  repr_int(self, x, level)\n |\n |  repr_list(self, x, level)\n |\n |  repr_set(self, x, level)\n |\n |  repr_str(self, x, level)\n |\n |  repr_tuple(self, x, level)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Repr(*, maxlevel=6, maxtuple=6, maxlist=6, maxarray=5, maxdict=4, maxset=6, maxfrozenset=6, maxdeque=6, maxstring=30, maxlong=40, maxother=30, fillvalue='...', indent=None)",
        "other-params": ""
    },
    "reprlib._possibly_sorted": {
        "function": "_possibly_sorted(x)",
        "alias": "_possibly_sorted",
        "help": "Help on function _possibly_sorted in module reprlib:\n\n_possibly_sorted(x)",
        "syntax": "Syntax: _possibly_sorted(x)",
        "other-params": ""
    },
    "reprlib.get_ident": {
        "function": "get_ident()",
        "alias": "get_ident",
        "help": "Help on built-in function get_ident in module _thread:\n\nget_ident()\n    Return a non-zero integer that uniquely identifies the current thread\n    amongst other threads that exist simultaneously.\n    This may be used to identify per-thread resources.\n    Even though on some platforms threads identities may appear to be\n    allocated consecutive numbers starting at 1, this behavior should not\n    be relied upon, and the number should be seen purely as a magic cookie.\n    A thread's identity may be reused for another thread after it exits.",
        "syntax": "Syntax: get_ident()",
        "other-params": ""
    },
    "reprlib.islice": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'itertools.islice'>",
        "alias": "islice",
        "help": "Help on class islice in module itertools:\n\nclass islice(builtins.object)\n |  islice(iterable, stop) --> islice object\n |  islice(iterable, start, stop[, step]) --> islice object\n |\n |  Return an iterator whose next() method returns selected values from an\n |  iterable.  If start is specified, will skip all preceding elements;\n |  otherwise, start defaults to zero.  Step defaults to one.  If\n |  specified as another value, step determines how many values are\n |  skipped between successive calls.  Works like a slice() on a list\n |  but returns an iterator.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'itertools.islice'>",
        "other-params": ""
    },
    "reprlib.recursive_repr": {
        "function": "recursive_repr(fillvalue='...')",
        "alias": "recursive_repr",
        "help": "Help on function recursive_repr in module reprlib:\n\nrecursive_repr(fillvalue='...')\n    Decorator to make a repr function return fillvalue for a recursive call",
        "syntax": "Syntax: recursive_repr(fillvalue='...')",
        "other-params": ""
    },
    "reprlib.repr": {
        "function": "repr(x)",
        "alias": "repr",
        "help": "Help on method repr in module reprlib:\n\nrepr(x) method of reprlib.Repr instance",
        "syntax": "Syntax: repr(x)",
        "other-params": ""
    },
    "collections.ChainMap": {
        "function": "ChainMap(*maps)",
        "alias": "ChainMap",
        "help": "Help on class ChainMap in module collections:\n\nclass ChainMap(collections.abc.MutableMapping)\n |  ChainMap(*maps)\n |\n |  A ChainMap groups multiple dicts (or other mappings) together\n |  to create a single, updateable view.\n |\n |  The underlying mappings are stored in a list.  That list is public and can\n |  be accessed or updated using the *maps* attribute.  There is no other\n |  state.\n |\n |  Lookups search the underlying mappings successively until a key is found.\n |  In contrast, writes, updates, and deletions only operate on the first\n |  mapping.\n |\n |  Method resolution order:\n |      ChainMap\n |      collections.abc.MutableMapping\n |      collections.abc.Mapping\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __bool__(self)\n |\n |  __contains__(self, key)\n |\n |  __copy__ = copy(self)\n |\n |  __delitem__(self, key)\n |\n |  __getitem__(self, key)\n |\n |  __init__(self, *maps)\n |      Initialize a ChainMap by setting *maps* to the given mappings.\n |      If no mappings are provided, a single empty dictionary is used.\n |\n |  __ior__(self, other)\n |\n |  __iter__(self)\n |\n |  __len__(self)\n |\n |  __missing__(self, key)\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __ror__(self, other)\n |      Return value|self.\n |\n |  __setitem__(self, key, value)\n |\n |  clear(self)\n |      Clear maps[0], leaving maps[1:] intact.\n |\n |  copy(self)\n |      New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  new_child(self, m=None, **kwargs)\n |      New ChainMap with a new map followed by all previous maps.\n |      If no map is provided, an empty dict is used.\n |      Keyword arguments update the map or new empty dict.\n |\n |  pop(self, key, *args)\n |      Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].\n |\n |  popitem(self)\n |      Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  fromkeys(iterable, value=None, /)\n |      Create a new ChainMap with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  parents\n |      New ChainMap from maps[1:].\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MutableMapping:\n |\n |  setdefault(self, key, default=None)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Mapping:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from collections.abc.Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: ChainMap(*maps)",
        "other-params": ""
    },
    "collections.Counter": {
        "function": "Counter(iterable=None, /, **kwds)",
        "alias": "Counter",
        "help": "Help on class Counter in module collections:\n\nclass Counter(builtins.dict)\n |  Counter(iterable=None, /, **kwds)\n |\n |  Dict subclass for counting hashable items.  Sometimes called a bag\n |  or multiset.  Elements are stored as dictionary keys and their counts\n |  are stored as dictionary values.\n |\n |  >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n |\n |  >>> c.most_common(3)                # three most common elements\n |  [('a', 5), ('b', 4), ('c', 3)]\n |  >>> sorted(c)                       # list all unique elements\n |  ['a', 'b', 'c', 'd', 'e']\n |  >>> ''.join(sorted(c.elements()))   # list elements with repetitions\n |  'aaaaabbbbcccdde'\n |  >>> sum(c.values())                 # total of all counts\n |  15\n |\n |  >>> c['a']                          # count of letter 'a'\n |  5\n |  >>> for elem in 'shazam':           # update counts from an iterable\n |  ...     c[elem] += 1                # by adding 1 to each element's count\n |  >>> c['a']                          # now there are seven 'a'\n |  7\n |  >>> del c['b']                      # remove all 'b'\n |  >>> c['b']                          # now there are zero 'b'\n |  0\n |\n |  >>> d = Counter('simsalabim')       # make another counter\n |  >>> c.update(d)                     # add in the second counter\n |  >>> c['a']                          # now there are nine 'a'\n |  9\n |\n |  >>> c.clear()                       # empty the counter\n |  >>> c\n |  Counter()\n |\n |  Note:  If a count is set to zero or reduced to zero, it will remain\n |  in the counter until the entry is deleted or the counter is cleared:\n |\n |  >>> c = Counter('aaabbc')\n |  >>> c['b'] -= 2                     # reduce the count of 'b' by two\n |  >>> c.most_common()                 # 'b' is still in, but its count is zero\n |  [('a', 3), ('c', 1), ('b', 0)]\n |\n |  Method resolution order:\n |      Counter\n |      builtins.dict\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __add__(self, other)\n |      Add counts from two counters.\n |\n |      >>> Counter('abbb') + Counter('bcc')\n |      Counter({'b': 4, 'c': 2, 'a': 1})\n |\n |  __and__(self, other)\n |      Intersection is the minimum of corresponding counts.\n |\n |      >>> Counter('abbb') & Counter('bcc')\n |      Counter({'b': 1})\n |\n |  __delitem__(self, elem)\n |      Like dict.__delitem__() but does not raise KeyError for missing values.\n |\n |  __eq__(self, other)\n |      True if all counts agree. Missing counts are treated as zero.\n |\n |  __ge__(self, other)\n |      True if all counts in self are a superset of those in other.\n |\n |  __gt__(self, other)\n |      True if all counts in self are a proper superset of those in other.\n |\n |  __iadd__(self, other)\n |      Inplace add from another counter, keeping only positive counts.\n |\n |      >>> c = Counter('abbb')\n |      >>> c += Counter('bcc')\n |      >>> c\n |      Counter({'b': 4, 'c': 2, 'a': 1})\n |\n |  __iand__(self, other)\n |      Inplace intersection is the minimum of corresponding counts.\n |\n |      >>> c = Counter('abbb')\n |      >>> c &= Counter('bcc')\n |      >>> c\n |      Counter({'b': 1})\n |\n |  __init__(self, iterable=None, /, **kwds)\n |      Create a new, empty Counter object.  And if given, count elements\n |      from an input iterable.  Or, initialize the count from another mapping\n |      of elements to their counts.\n |\n |      >>> c = Counter()                           # a new, empty counter\n |      >>> c = Counter('gallahad')                 # a new counter from an iterable\n |      >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping\n |      >>> c = Counter(a=4, b=2)                   # a new counter from keyword args\n |\n |  __ior__(self, other)\n |      Inplace union is the maximum of value from either counter.\n |\n |      >>> c = Counter('abbb')\n |      >>> c |= Counter('bcc')\n |      >>> c\n |      Counter({'b': 3, 'c': 2, 'a': 1})\n |\n |  __isub__(self, other)\n |      Inplace subtract counter, but keep only results with positive counts.\n |\n |      >>> c = Counter('abbbc')\n |      >>> c -= Counter('bccd')\n |      >>> c\n |      Counter({'b': 2, 'a': 1})\n |\n |  __le__(self, other)\n |      True if all counts in self are a subset of those in other.\n |\n |  __lt__(self, other)\n |      True if all counts in self are a proper subset of those in other.\n |\n |  __missing__(self, key)\n |      The count of elements not in the Counter is zero.\n |\n |  __ne__(self, other)\n |      True if any counts disagree. Missing counts are treated as zero.\n |\n |  __neg__(self)\n |      Subtracts from an empty counter.  Strips positive and zero counts,\n |      and flips the sign on negative counts.\n |\n |  __or__(self, other)\n |      Union is the maximum of value in either of the input counters.\n |\n |      >>> Counter('abbb') | Counter('bcc')\n |      Counter({'b': 3, 'c': 2, 'a': 1})\n |\n |  __pos__(self)\n |      Adds an empty counter, effectively stripping negative and zero counts\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __sub__(self, other)\n |      Subtract count, but keep only results with positive counts.\n |\n |      >>> Counter('abbbc') - Counter('bccd')\n |      Counter({'b': 2, 'a': 1})\n |\n |  copy(self)\n |      Return a shallow copy.\n |\n |  elements(self)\n |      Iterator over elements repeating each as many times as its count.\n |\n |      >>> c = Counter('ABCABC')\n |      >>> sorted(c.elements())\n |      ['A', 'A', 'B', 'B', 'C', 'C']\n |\n |      Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n |\n |      >>> import math\n |      >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})\n |      >>> math.prod(prime_factors.elements())\n |      1836\n |\n |      Note, if an element's count has been set to zero or is a negative\n |      number, elements() will ignore it.\n |\n |  most_common(self, n=None)\n |      List the n most common elements and their counts from the most\n |      common to the least.  If n is None, then list all element counts.\n |\n |      >>> Counter('abracadabra').most_common(3)\n |      [('a', 5), ('b', 2), ('r', 2)]\n |\n |  subtract(self, iterable=None, /, **kwds)\n |      Like dict.update() but subtracts counts instead of replacing them.\n |      Counts can be reduced below zero.  Both the inputs and outputs are\n |      allowed to contain zero and negative counts.\n |\n |      Source can be an iterable, a dictionary, or another Counter instance.\n |\n |      >>> c = Counter('which')\n |      >>> c.subtract('witch')             # subtract elements from another iterable\n |      >>> c.subtract(Counter('watch'))    # subtract elements from another counter\n |      >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch\n |      0\n |      >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch\n |      -1\n |\n |  total(self)\n |      Sum of the counts\n |\n |  update(self, iterable=None, /, **kwds)\n |      Like dict.update() but add counts instead of replacing them.\n |\n |      Source can be an iterable, a dictionary, or another Counter instance.\n |\n |      >>> c = Counter('which')\n |      >>> c.update('witch')           # add elements from another iterable\n |      >>> d = Counter('watch')\n |      >>> c.update(d)                 # add elements from another counter\n |      >>> c['h']                      # four 'h' in which, witch, and watch\n |      4\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  fromkeys(iterable, v=None)\n |      Create a new dictionary with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |\n |  __contains__(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the dict in memory, in bytes.\n |\n |  clear(self, /)\n |      Remove all items from the dict.\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  items(self, /)\n |      Return a set-like object providing a view on the dict's items.\n |\n |  keys(self, /)\n |      Return a set-like object providing a view on the dict's keys.\n |\n |  pop(self, key, default=<unrepresentable>, /)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |\n |      If the key is not found, return the default if given; otherwise,\n |      raise a KeyError.\n |\n |  popitem(self, /)\n |      Remove and return a (key, value) pair as a 2-tuple.\n |\n |      Pairs are returned in LIFO (last-in, first-out) order.\n |      Raises KeyError if the dict is empty.\n |\n |  setdefault(self, key, default=None, /)\n |      Insert key with a value of default if key is not in the dictionary.\n |\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  values(self, /)\n |      Return an object providing a view on the dict's values.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.dict:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |\n |  __new__(*args, **kwargs) class method of builtins.dict\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Counter(iterable=None, /, **kwds)",
        "other-params": ""
    },
    "collections.OrderedDict": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'collections.OrderedDict'>",
        "alias": "OrderedDict",
        "help": "Help on class OrderedDict in module collections:\n\nclass OrderedDict(builtins.dict)\n |  Dictionary that remembers insertion order\n |\n |  Method resolution order:\n |      OrderedDict\n |      builtins.dict\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      od.__reversed__() <==> reversed(od)\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the dict in memory, in bytes.\n |\n |  clear(self, /)\n |      od.clear() -> None.  Remove all items from od.\n |\n |  copy(self, /)\n |      od.copy() -> a shallow copy of od\n |\n |  items(self, /)\n |      Return a set-like object providing a view on the dict's items.\n |\n |  keys(self, /)\n |      Return a set-like object providing a view on the dict's keys.\n |\n |  move_to_end(self, /, key, last=True)\n |      Move an existing element to the end (or beginning if last is false).\n |\n |      Raise KeyError if the element does not exist.\n |\n |  pop(self, /, key, default=<unrepresentable>)\n |      od.pop(key[,default]) -> v, remove specified key and return the corresponding value.\n |\n |      If the key is not found, return the default if given; otherwise,\n |      raise a KeyError.\n |\n |  popitem(self, /, last=True)\n |      Remove and return a (key, value) pair from the dictionary.\n |\n |      Pairs are returned in LIFO order if last is true or FIFO order if false.\n |\n |  setdefault(self, /, key, default=None)\n |      Insert key with a value of default if key is not in the dictionary.\n |\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  update(...)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |\n |  values(self, /)\n |      Return an object providing a view on the dict's values.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  fromkeys(iterable, value=None)\n |      Create a new ordered dictionary with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |\n |  __contains__(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.dict:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |\n |  __new__(*args, **kwargs) class method of builtins.dict\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'collections.OrderedDict'>",
        "other-params": ""
    },
    "collections.UserDict": {
        "function": "UserDict(dict=None, /, **kwargs)",
        "alias": "UserDict",
        "help": "Help on class UserDict in module collections:\n\nclass UserDict(collections.abc.MutableMapping)\n |  UserDict(dict=None, /, **kwargs)\n |\n |  Method resolution order:\n |      UserDict\n |      collections.abc.MutableMapping\n |      collections.abc.Mapping\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, key)\n |      # Modify __contains__ and get() to work like dict\n |      # does when __missing__ is present.\n |\n |  __copy__(self)\n |\n |  __delitem__(self, key)\n |\n |  __getitem__(self, key)\n |\n |  __init__(self, dict=None, /, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __ior__(self, other)\n |\n |  __iter__(self)\n |\n |  __len__(self)\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __ror__(self, other)\n |      Return value|self.\n |\n |  __setitem__(self, key, item)\n |\n |  copy(self)\n |\n |  get(self, key, default=None)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  fromkeys(iterable, value=None)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MutableMapping:\n |\n |  clear(self)\n |      D.clear() -> None.  Remove all items from D.\n |\n |  pop(self, key, default=<object object at 0x000001950D090200>)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised.\n |\n |  popitem(self)\n |      D.popitem() -> (k, v), remove and return some (key, value) pair\n |      as a 2-tuple; but raise KeyError if D is empty.\n |\n |  setdefault(self, key, default=None)\n |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D\n |\n |  update(self, other=(), /, **kwds)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E present and has a .keys() method, does:     for k in E.keys(): D[k] = E[k]\n |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n |      In either case, this is followed by: for k, v in F.items(): D[k] = v\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Mapping:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  items(self)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from collections.abc.Mapping:\n |\n |  __hash__ = None\n |\n |  __reversed__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: UserDict(dict=None, /, **kwargs)",
        "other-params": ""
    },
    "collections.UserList": {
        "function": "UserList(initlist=None)",
        "alias": "UserList",
        "help": "Help on class UserList in module collections:\n\nclass UserList(collections.abc.MutableSequence)\n |  UserList(initlist=None)\n |\n |  A more or less complete user-defined wrapper around list objects.\n |\n |  Method resolution order:\n |      UserList\n |      collections.abc.MutableSequence\n |      collections.abc.Sequence\n |      collections.abc.Reversible\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __add__(self, other)\n |\n |  __contains__(self, item)\n |\n |  __copy__(self)\n |\n |  __delitem__(self, i)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __getitem__(self, i)\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __iadd__(self, other)\n |\n |  __imul__(self, n)\n |\n |  __init__(self, initlist=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __len__(self)\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __mul__(self, n)\n |\n |  __radd__(self, other)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rmul__ = __mul__(self, n)\n |\n |  __setitem__(self, i, item)\n |\n |  append(self, item)\n |      S.append(value) -- append value to the end of the sequence\n |\n |  clear(self)\n |      S.clear() -> None -- remove all items from S\n |\n |  copy(self)\n |\n |  count(self, item)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  extend(self, other)\n |      S.extend(iterable) -- extend sequence by appending elements from the iterable\n |\n |  index(self, item, *args)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  insert(self, i, item)\n |      S.insert(index, value) -- insert value before index\n |\n |  pop(self, i=-1)\n |      S.pop([index]) -> item -- remove and return item at index (default last).\n |      Raise IndexError if list is empty or index is out of range.\n |\n |  remove(self, item)\n |      S.remove(value) -- remove first occurrence of value.\n |      Raise ValueError if the value is not present.\n |\n |  reverse(self)\n |      S.reverse() -- reverse *IN PLACE*\n |\n |  sort(self, /, *args, **kwds)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Sequence:\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: UserList(initlist=None)",
        "other-params": ""
    },
    "collections.UserString": {
        "function": "UserString(seq)",
        "alias": "UserString",
        "help": "Help on class UserString in module collections:\n\nclass UserString(collections.abc.Sequence)\n |  UserString(seq)\n |\n |  Method resolution order:\n |      UserString\n |      collections.abc.Sequence\n |      collections.abc.Reversible\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __add__(self, other)\n |\n |  __complex__(self)\n |\n |  __contains__(self, char)\n |\n |  __eq__(self, string)\n |      Return self==value.\n |\n |  __float__(self)\n |\n |  __ge__(self, string)\n |      Return self>=value.\n |\n |  __getitem__(self, index)\n |\n |  __getnewargs__(self)\n |\n |  __gt__(self, string)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, seq)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __int__(self)\n |\n |  __le__(self, string)\n |      Return self<=value.\n |\n |  __len__(self)\n |\n |  __lt__(self, string)\n |      Return self<value.\n |\n |  __mod__(self, args)\n |\n |  __mul__(self, n)\n |\n |  __radd__(self, other)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rmod__(self, template)\n |\n |  __rmul__ = __mul__(self, n)\n |\n |  __str__(self)\n |      Return str(self).\n |\n |  capitalize(self)\n |      # the following methods are defined in alphabetical order:\n |\n |  casefold(self)\n |\n |  center(self, width, *args)\n |\n |  count(self, sub, start=0, end=9223372036854775807)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  encode(self, encoding='utf-8', errors='strict')\n |\n |  endswith(self, suffix, start=0, end=9223372036854775807)\n |\n |  expandtabs(self, tabsize=8)\n |\n |  find(self, sub, start=0, end=9223372036854775807)\n |\n |  format(self, /, *args, **kwds)\n |\n |  format_map(self, mapping)\n |\n |  index(self, sub, start=0, end=9223372036854775807)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  isalnum(self)\n |\n |  isalpha(self)\n |\n |  isascii(self)\n |\n |  isdecimal(self)\n |\n |  isdigit(self)\n |\n |  isidentifier(self)\n |\n |  islower(self)\n |\n |  isnumeric(self)\n |\n |  isprintable(self)\n |\n |  isspace(self)\n |\n |  istitle(self)\n |\n |  isupper(self)\n |\n |  join(self, seq)\n |\n |  ljust(self, width, *args)\n |\n |  lower(self)\n |\n |  lstrip(self, chars=None)\n |\n |  partition(self, sep)\n |\n |  removeprefix(self, prefix, /)\n |\n |  removesuffix(self, suffix, /)\n |\n |  replace(self, old, new, maxsplit=-1)\n |\n |  rfind(self, sub, start=0, end=9223372036854775807)\n |\n |  rindex(self, sub, start=0, end=9223372036854775807)\n |\n |  rjust(self, width, *args)\n |\n |  rpartition(self, sep)\n |\n |  rsplit(self, sep=None, maxsplit=-1)\n |\n |  rstrip(self, chars=None)\n |\n |  split(self, sep=None, maxsplit=-1)\n |\n |  splitlines(self, keepends=False)\n |\n |  startswith(self, prefix, start=0, end=9223372036854775807)\n |\n |  strip(self, chars=None)\n |\n |  swapcase(self)\n |\n |  title(self)\n |\n |  translate(self, *args)\n |\n |  upper(self)\n |\n |  zfill(self, width)\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  maketrans(x, y=<unrepresentable>, z=<unrepresentable>, /)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Sequence:\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: UserString(seq)",
        "other-params": ""
    },
    "collections._Link": {
        "function": "_Link()",
        "alias": "_Link",
        "help": "Help on class _Link in module collections:\n\nclass _Link(builtins.object)\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  key\n |\n |  next\n |\n |  prev",
        "syntax": "Syntax: _Link()",
        "other-params": ""
    },
    "collections._OrderedDictItemsView": {
        "function": "_OrderedDictItemsView(mapping)",
        "alias": "_OrderedDictItemsView",
        "help": "Help on class _OrderedDictItemsView in module collections:\n\nclass _OrderedDictItemsView(collections.abc.ItemsView)\n |  _OrderedDictItemsView(mapping)\n |\n |  Method resolution order:\n |      _OrderedDictItemsView\n |      collections.abc.ItemsView\n |      collections.abc.MappingView\n |      collections.abc.Set\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.ItemsView:\n |\n |  __contains__(self, item)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from collections.abc.Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: _OrderedDictItemsView(mapping)",
        "other-params": ""
    },
    "collections._OrderedDictKeysView": {
        "function": "_OrderedDictKeysView(mapping)",
        "alias": "_OrderedDictKeysView",
        "help": "Help on class _OrderedDictKeysView in module collections:\n\nclass _OrderedDictKeysView(collections.abc.KeysView)\n |  _OrderedDictKeysView(mapping)\n |\n |  Method resolution order:\n |      _OrderedDictKeysView\n |      collections.abc.KeysView\n |      collections.abc.MappingView\n |      collections.abc.Set\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.KeysView:\n |\n |  __contains__(self, key)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Set:\n |\n |  __and__(self, other)\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __or__(self, other)\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rsub__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __sub__(self, other)\n |\n |  __xor__(self, other)\n |\n |  isdisjoint(self, other)\n |      Return True if two sets have a null intersection.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from collections.abc.Set:\n |\n |  __hash__ = None\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: _OrderedDictKeysView(mapping)",
        "other-params": ""
    },
    "collections._OrderedDictValuesView": {
        "function": "_OrderedDictValuesView(mapping)",
        "alias": "_OrderedDictValuesView",
        "help": "Help on class _OrderedDictValuesView in module collections:\n\nclass _OrderedDictValuesView(collections.abc.ValuesView)\n |  _OrderedDictValuesView(mapping)\n |\n |  Method resolution order:\n |      _OrderedDictValuesView\n |      collections.abc.ValuesView\n |      collections.abc.MappingView\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __reversed__(self)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.ValuesView:\n |\n |  __contains__(self, value)\n |\n |  __iter__(self)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.MappingView:\n |\n |  __init__(self, mapping)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.MappingView:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Collection:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: _OrderedDictValuesView(mapping)",
        "other-params": ""
    },
    "collections._chain": {
        "function": "_chain(*iterables)",
        "alias": "_chain",
        "help": "Help on class chain in module itertools:\n\nclass chain(builtins.object)\n |  chain(*iterables)\n |\n |  Return a chain object whose .__next__() method returns elements from the\n |  first iterable until it is exhausted, then elements from the next\n |  iterable, until all of the iterables are exhausted.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  from_iterable(iterable, /)\n |      Alternative chain() constructor taking a single iterable argument that evaluates lazily.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: _chain(*iterables)",
        "other-params": ""
    },
    "collections._count_elements": {
        "function": "_count_elements(mapping, iterable, /)",
        "alias": "_count_elements",
        "help": "Help on built-in function _count_elements in module _collections:\n\n_count_elements(mapping, iterable, /)\n    Count elements in the iterable, updating the mapping",
        "syntax": "Syntax: _count_elements(mapping, iterable, /)",
        "other-params": ""
    },
    "collections._deque_iterator": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'collections._deque_iterator'>",
        "alias": "_deque_iterator",
        "help": "Help on class _deque_iterator in module collections:\n\nclass _deque_iterator(builtins.object)\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'collections._deque_iterator'>",
        "other-params": ""
    },
    "collections._eq": {
        "function": "_eq(a, b, /)",
        "alias": "_eq",
        "help": "Help on built-in function eq in module _operator:\n\neq(a, b, /)\n    Same as a == b.",
        "syntax": "Syntax: _eq(a, b, /)",
        "other-params": ""
    },
    "collections._iskeyword": {
        "function": "_iskeyword(object, /)",
        "alias": "_iskeyword",
        "help": "Help on built-in function __contains__:\n\n__contains__(object, /) method of builtins.frozenset instance\n    x.__contains__(y) <==> y in x.",
        "syntax": "Syntax: _iskeyword(object, /)",
        "other-params": ""
    },
    "collections._itemgetter": {
        "function": "_itemgetter(item, /, *items)",
        "alias": "_itemgetter",
        "help": "Help on class itemgetter in module operator:\n\nclass itemgetter(builtins.object)\n |  itemgetter(item, /, *items)\n |\n |  Return a callable object that fetches the given item(s) from its operand.\n |  After f = itemgetter(2), the call f(r) returns r[2].\n |  After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __vectorcalloffset__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __text_signature__ = '(item, /, *items)'",
        "syntax": "Syntax: _itemgetter(item, /, *items)",
        "other-params": ""
    },
    "collections._proxy": {
        "function": "_proxy(object, callback=None, /)",
        "alias": "_proxy",
        "help": "Help on built-in function proxy in module _weakref:\n\nproxy(object, callback=None, /)\n    Create a proxy object that weakly references 'object'.\n\n    'callback', if given, is called with a reference to the\n    proxy when 'object' is about to be finalized.",
        "syntax": "Syntax: _proxy(object, callback=None, /)",
        "other-params": ""
    },
    "collections._recursive_repr": {
        "function": "_recursive_repr(fillvalue='...')",
        "alias": "_recursive_repr",
        "help": "Help on function recursive_repr in module reprlib:\n\nrecursive_repr(fillvalue='...')\n    Decorator to make a repr function return fillvalue for a recursive call",
        "syntax": "Syntax: _recursive_repr(fillvalue='...')",
        "other-params": ""
    },
    "collections._repeat": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'itertools.repeat'>",
        "alias": "_repeat",
        "help": "Help on class repeat in module itertools:\n\nclass repeat(builtins.object)\n |  repeat(object [,times]) -> create an iterator which returns the object\n |  for the specified number of times.  If not specified, returns the object\n |  endlessly.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __length_hint__(self, /)\n |      Private method returning an estimate of len(list(it)).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'itertools.repeat'>",
        "other-params": ""
    },
    "collections._starmap": {
        "function": "_starmap(function, iterable, /)",
        "alias": "_starmap",
        "help": "Help on class starmap in module itertools:\n\nclass starmap(builtins.object)\n |  starmap(function, iterable, /)\n |\n |  Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: _starmap(function, iterable, /)",
        "other-params": ""
    },
    "collections._tuplegetter": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'collections._tuplegetter'>",
        "alias": "_tuplegetter",
        "help": "Help on class _tuplegetter in module collections:\n\nclass _tuplegetter(builtins.object)\n |  Methods defined here:\n |\n |  __delete__(self, instance, /)\n |      Delete an attribute of instance.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __set__(self, instance, value, /)\n |      Set an attribute of instance to value.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'collections._tuplegetter'>",
        "other-params": ""
    },
    "collections.defaultdict": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'collections.defaultdict'>",
        "alias": "defaultdict",
        "help": "Help on class defaultdict in module collections:\n\nclass defaultdict(builtins.dict)\n |  defaultdict(default_factory=None, /, [...]) --> dict with default factory\n |\n |  The default factory is called without arguments to produce\n |  a new value when a key is not present, in __getitem__ only.\n |  A defaultdict compares equal to a dict with the same items.\n |  All remaining arguments are treated the same as if they were\n |  passed to the dict constructor, including keyword arguments.\n |\n |  Method resolution order:\n |      defaultdict\n |      builtins.dict\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __copy__(self, /)\n |      D.copy() -> a shallow copy of D.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __missing__(self, object, /)\n |      __missing__(key) # Called by __getitem__ for missing key; pseudo-code:\n |      if self.default_factory is None: raise KeyError((key,))\n |      self[key] = value = self.default_factory()\n |      return value\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  copy(self, /)\n |      D.copy() -> a shallow copy of D.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  default_factory\n |      Factory for default value called by __missing__().\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |\n |  __contains__(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the dict in memory, in bytes.\n |\n |  clear(self, /)\n |      Remove all items from the dict.\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  items(self, /)\n |      Return a set-like object providing a view on the dict's items.\n |\n |  keys(self, /)\n |      Return a set-like object providing a view on the dict's keys.\n |\n |  pop(self, key, default=<unrepresentable>, /)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |\n |      If the key is not found, return the default if given; otherwise,\n |      raise a KeyError.\n |\n |  popitem(self, /)\n |      Remove and return a (key, value) pair as a 2-tuple.\n |\n |      Pairs are returned in LIFO (last-in, first-out) order.\n |      Raises KeyError if the dict is empty.\n |\n |  setdefault(self, key, default=None, /)\n |      Insert key with a value of default if key is not in the dictionary.\n |\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  update(...)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |\n |  values(self, /)\n |      Return an object providing a view on the dict's values.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.dict:\n |\n |  fromkeys(iterable, value=None, /)\n |      Create a new dictionary with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |\n |  __new__(*args, **kwargs) class method of builtins.dict\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.dict:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'collections.defaultdict'>",
        "other-params": ""
    },
    "collections.deque": {
        "function": "Error retrieving signature: <class 'collections.deque'> builtin has invalid signature",
        "alias": "deque",
        "help": "Help on class deque in module collections:\n\nclass deque(builtins.object)\n |  deque([iterable[, maxlen]])\n |\n |  A list-like sequence optimized for data accesses near its endpoints.\n |\n |  Methods defined here:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __copy__(self, /)\n |      Return a shallow copy of a deque.\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |\n |  __imul__(self, value, /)\n |      Implement self*=value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the deque.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the deque in memory, in bytes.\n |\n |  append(self, item, /)\n |      Add an element to the right side of the deque.\n |\n |  appendleft(self, item, /)\n |      Add an element to the left side of the deque.\n |\n |  clear(self, /)\n |      Remove all elements from the deque.\n |\n |  copy(self, /)\n |      Return a shallow copy of a deque.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  extend(self, iterable, /)\n |      Extend the right side of the deque with elements from the iterable.\n |\n |  extendleft(self, iterable, /)\n |      Extend the left side of the deque with elements from the iterable.\n |\n |  index(self, value, [start, [stop]])\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  insert(self, index, value, /)\n |      Insert value before index.\n |\n |  pop(self, /)\n |      Remove and return the rightmost element.\n |\n |  popleft(self, /)\n |      Remove and return the leftmost element.\n |\n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |\n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |\n |  rotate(self, n=1, /)\n |      Rotate the deque n steps to the right.  If n is negative, rotates left.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  maxlen\n |      maximum size of a deque or None if unbounded\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: <class 'collections.deque'> builtin has invalid signature",
        "other-params": ""
    },
    "collections.namedtuple": {
        "function": "namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)",
        "alias": "namedtuple",
        "help": "Help on function namedtuple in module collections:\n\nnamedtuple(typename, field_names, *, rename=False, defaults=None, module=None)\n    Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)",
        "syntax": "Syntax: namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)",
        "other-params": ""
    },
    "functools.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "functools.RLock": {
        "function": "Error retrieving signature: no signature found for builtin type <class '_thread.RLock'>",
        "alias": "RLock",
        "help": "Help on class RLock in module _thread:\n\nclass RLock(builtins.object)\n |  Methods defined here:\n |\n |  __enter__(self, /)\n |      Lock the lock.\n |\n |  __exit__(self, /, *exc_info)\n |      Release the lock.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  acquire(self, /, blocking=True, timeout=-1)\n |      Lock the lock.  `blocking` indicates whether we should wait\n |      for the lock to be available or not.  If `blocking` is False\n |      and another thread holds the lock, the method will return False\n |      immediately.  If `blocking` is True and another thread holds\n |      the lock, the method will wait for the lock to be released,\n |      take it and then return True.\n |      (note: the blocking operation is interruptible.)\n |\n |      In all other cases, the method will return True immediately.\n |      Precisely, if the current thread already holds the lock, its\n |      internal counter is simply incremented. If nobody holds the lock,\n |      the lock is taken and its internal counter initialized to 1.\n |\n |  release(self, /)\n |      Release the lock, allowing another thread that is blocked waiting for\n |      the lock to acquire the lock.  The lock must be in the locked state,\n |      and must be locked by the same thread that unlocks it; otherwise a\n |      `RuntimeError` is raised.\n |\n |      Do note that if the lock was acquire()d several times in a row by the\n |      current thread, release() needs to be called as many times for the lock\n |      to be available for other threads.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class '_thread.RLock'>",
        "other-params": ""
    },
    "functools._CacheInfo": {
        "function": "_CacheInfo(hits, misses, maxsize, currsize)",
        "alias": "_CacheInfo",
        "help": "Help on class CacheInfo in module functools:\n\nclass CacheInfo(builtins.tuple)\n |  CacheInfo(hits, misses, maxsize, currsize)\n |\n |  CacheInfo(hits, misses, maxsize, currsize)\n |\n |  Method resolution order:\n |      CacheInfo\n |      builtins.tuple\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getnewargs__(self) from collections.CacheInfo\n |      Return self as a plain tuple.  Used by copy and pickle.\n |\n |  __replace__ = _replace(self, /, **kwds)\n |\n |  __repr__(self) from collections.CacheInfo\n |      Return a nicely formatted representation string\n |\n |  _asdict(self) from collections.CacheInfo\n |      Return a new dict which maps field names to their values.\n |\n |  _replace(self, /, **kwds) from collections.CacheInfo\n |      Return a new CacheInfo object replacing specified fields with new values\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  _make(iterable) from collections.CacheInfo\n |      Make a new CacheInfo object from a sequence or iterable\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(_cls, hits, misses, maxsize, currsize) from namedtuple_CacheInfo.CacheInfo\n |      Create new instance of CacheInfo(hits, misses, maxsize, currsize)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  hits\n |      Alias for field number 0\n |\n |  misses\n |      Alias for field number 1\n |\n |  maxsize\n |      Alias for field number 2\n |\n |  currsize\n |      Alias for field number 3\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __match_args__ = ('hits', 'misses', 'maxsize', 'currsize')\n |\n |  _field_defaults = {}\n |\n |  _fields = ('hits', 'misses', 'maxsize', 'currsize')\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.tuple:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.tuple:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585",
        "syntax": "Syntax: _CacheInfo(hits, misses, maxsize, currsize)",
        "other-params": ""
    },
    "functools._HashedSeq": {
        "function": "_HashedSeq(tup, hash=<built-in function hash>)",
        "alias": "_HashedSeq",
        "help": "Help on class _HashedSeq in module functools:\n\nclass _HashedSeq(builtins.list)\n |  _HashedSeq(tup, hash=<built-in function hash>)\n |\n |  This class guarantees that hash() will be called no more than once\n |  per element.  This is important because the lru_cache() will hash\n |  the key multiple times on a cache miss.\n |\n |  Method resolution order:\n |      _HashedSeq\n |      builtins.list\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, tup, hash=<built-in function hash>)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  hashvalue\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.list:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, index, /)\n |      Return self[index].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |\n |  __imul__(self, value, /)\n |      Implement self*=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the list.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the list in memory, in bytes.\n |\n |  append(self, object, /)\n |      Append object to the end of the list.\n |\n |  clear(self, /)\n |      Remove all items from list.\n |\n |  copy(self, /)\n |      Return a shallow copy of the list.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  extend(self, iterable, /)\n |      Extend list by appending elements from the iterable.\n |\n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  insert(self, index, object, /)\n |      Insert object before index.\n |\n |  pop(self, index=-1, /)\n |      Remove and return item at index (default last).\n |\n |      Raises IndexError if list is empty or index is out of range.\n |\n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |\n |  sort(self, /, *, key=None, reverse=False)\n |      Sort the list in ascending order and return None.\n |\n |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\n |      order of two equal elements is maintained).\n |\n |      If a key function is given, apply it once to each list item and sort them,\n |      ascending or descending, according to their function values.\n |\n |      The reverse flag can be set to sort in descending order.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.list:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.list:\n |\n |  __new__(*args, **kwargs) class method of builtins.list\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: _HashedSeq(tup, hash=<built-in function hash>)",
        "other-params": ""
    },
    "functools._c3_merge": {
        "function": "_c3_merge(sequences)",
        "alias": "_c3_merge",
        "help": "Help on function _c3_merge in module functools:\n\n_c3_merge(sequences)\n    Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n\n    Adapted from https://docs.python.org/3/howto/mro.html.",
        "syntax": "Syntax: _c3_merge(sequences)",
        "other-params": ""
    },
    "functools._c3_mro": {
        "function": "_c3_mro(cls, abcs=None)",
        "alias": "_c3_mro",
        "help": "Help on function _c3_mro in module functools:\n\n_c3_mro(cls, abcs=None)\n    Computes the method resolution order using extended C3 linearization.\n\n    If no *abcs* are given, the algorithm works exactly like the built-in C3\n    linearization used for method resolution.\n\n    If given, *abcs* is a list of abstract base classes that should be inserted\n    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the\n    result. The algorithm inserts ABCs where their functionality is introduced,\n    i.e. issubclass(cls, abc) returns True for the class itself but returns\n    False for all its direct base classes. Implicit ABCs for a given class\n    (either registered or inferred from the presence of a special method like\n    __len__) are inserted directly after the last ABC explicitly listed in the\n    MRO of said class. If two implicit ABCs end up next to each other in the\n    resulting MRO, their ordering depends on the order of types in *abcs*.",
        "syntax": "Syntax: _c3_mro(cls, abcs=None)",
        "other-params": ""
    },
    "functools._compose_mro": {
        "function": "_compose_mro(cls, types)",
        "alias": "_compose_mro",
        "help": "Help on function _compose_mro in module functools:\n\n_compose_mro(cls, types)\n    Calculates the method resolution order for a given class *cls*.\n\n    Includes relevant abstract base classes (with their respective bases) from\n    the *types* iterable. Uses a modified C3 linearization algorithm.",
        "syntax": "Syntax: _compose_mro(cls, types)",
        "other-params": ""
    },
    "functools._find_impl": {
        "function": "_find_impl(cls, registry)",
        "alias": "_find_impl",
        "help": "Help on function _find_impl in module functools:\n\n_find_impl(cls, registry)\n    Returns the best matching implementation from *registry* for type *cls*.\n\n    Where there is no registered implementation for a specific type, its method\n    resolution order is used to find a more generic implementation.\n\n    Note: if *registry* does not contain an implementation for the base\n    *object* type, this function may return None.",
        "syntax": "Syntax: _find_impl(cls, registry)",
        "other-params": ""
    },
    "functools._ge_from_gt": {
        "function": "_ge_from_gt(self, other)",
        "alias": "_ge_from_gt",
        "help": "Help on function _ge_from_gt in module functools:\n\n_ge_from_gt(self, other)\n    Return a >= b.  Computed by @total_ordering from (a > b) or (a == b).",
        "syntax": "Syntax: _ge_from_gt(self, other)",
        "other-params": ""
    },
    "functools._ge_from_le": {
        "function": "_ge_from_le(self, other)",
        "alias": "_ge_from_le",
        "help": "Help on function _ge_from_le in module functools:\n\n_ge_from_le(self, other)\n    Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b).",
        "syntax": "Syntax: _ge_from_le(self, other)",
        "other-params": ""
    },
    "functools._ge_from_lt": {
        "function": "_ge_from_lt(self, other)",
        "alias": "_ge_from_lt",
        "help": "Help on function __ge__ in module functools:\n\n__ge__(self, other)\n    Return a >= b.  Computed by @total_ordering from (not a < b).",
        "syntax": "Syntax: _ge_from_lt(self, other)",
        "other-params": ""
    },
    "functools._gt_from_ge": {
        "function": "_gt_from_ge(self, other)",
        "alias": "_gt_from_ge",
        "help": "Help on function _gt_from_ge in module functools:\n\n_gt_from_ge(self, other)\n    Return a > b.  Computed by @total_ordering from (a >= b) and (a != b).",
        "syntax": "Syntax: _gt_from_ge(self, other)",
        "other-params": ""
    },
    "functools._gt_from_le": {
        "function": "_gt_from_le(self, other)",
        "alias": "_gt_from_le",
        "help": "Help on function _gt_from_le in module functools:\n\n_gt_from_le(self, other)\n    Return a > b.  Computed by @total_ordering from (not a <= b).",
        "syntax": "Syntax: _gt_from_le(self, other)",
        "other-params": ""
    },
    "functools._gt_from_lt": {
        "function": "_gt_from_lt(self, other)",
        "alias": "_gt_from_lt",
        "help": "Help on function __gt__ in module functools:\n\n__gt__(self, other)\n    Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).",
        "syntax": "Syntax: _gt_from_lt(self, other)",
        "other-params": ""
    },
    "functools._le_from_ge": {
        "function": "_le_from_ge(self, other)",
        "alias": "_le_from_ge",
        "help": "Help on function _le_from_ge in module functools:\n\n_le_from_ge(self, other)\n    Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b).",
        "syntax": "Syntax: _le_from_ge(self, other)",
        "other-params": ""
    },
    "functools._le_from_gt": {
        "function": "_le_from_gt(self, other)",
        "alias": "_le_from_gt",
        "help": "Help on function _le_from_gt in module functools:\n\n_le_from_gt(self, other)\n    Return a <= b.  Computed by @total_ordering from (not a > b).",
        "syntax": "Syntax: _le_from_gt(self, other)",
        "other-params": ""
    },
    "functools._le_from_lt": {
        "function": "_le_from_lt(self, other)",
        "alias": "_le_from_lt",
        "help": "Help on function __le__ in module functools:\n\n__le__(self, other)\n    Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).",
        "syntax": "Syntax: _le_from_lt(self, other)",
        "other-params": ""
    },
    "functools._lru_cache_wrapper": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'functools._lru_cache_wrapper'>",
        "alias": "_lru_cache_wrapper",
        "help": "Help on class _lru_cache_wrapper in module functools:\n\nclass _lru_cache_wrapper(builtins.object)\n |  Create a cached callable that wraps another function.\n |\n |  user_function:      the function being cached\n |\n |  maxsize:  0         for no caching\n |            None      for unlimited cache size\n |            n         for a bounded cache\n |\n |  typed:    False     cache f(3) and f(3.0) as identical calls\n |            True      cache f(3) and f(3.0) as distinct calls\n |\n |  cache_info_type:    namedtuple class with the fields:\n |                          hits misses currsize maxsize\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __copy__(...)\n |\n |  __deepcopy__(...)\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  cache_clear(self, /)\n |      Clear the cache and cache statistics\n |\n |  cache_info(self, /)\n |      Report cache statistics\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'functools._lru_cache_wrapper'>",
        "other-params": ""
    },
    "functools._lt_from_ge": {
        "function": "_lt_from_ge(self, other)",
        "alias": "_lt_from_ge",
        "help": "Help on function _lt_from_ge in module functools:\n\n_lt_from_ge(self, other)\n    Return a < b.  Computed by @total_ordering from (not a >= b).",
        "syntax": "Syntax: _lt_from_ge(self, other)",
        "other-params": ""
    },
    "functools._lt_from_gt": {
        "function": "_lt_from_gt(self, other)",
        "alias": "_lt_from_gt",
        "help": "Help on function _lt_from_gt in module functools:\n\n_lt_from_gt(self, other)\n    Return a < b.  Computed by @total_ordering from (not a > b) and (a != b).",
        "syntax": "Syntax: _lt_from_gt(self, other)",
        "other-params": ""
    },
    "functools._lt_from_le": {
        "function": "_lt_from_le(self, other)",
        "alias": "_lt_from_le",
        "help": "Help on function _lt_from_le in module functools:\n\n_lt_from_le(self, other)\n    Return a < b.  Computed by @total_ordering from (a <= b) and (a != b).",
        "syntax": "Syntax: _lt_from_le(self, other)",
        "other-params": ""
    },
    "functools._make_key": {
        "function": "_make_key(args, kwds, typed, kwd_mark=(<object object at 0x000001950D0902E0>,), fasttypes={<class 'int'>, <class 'str'>}, tuple=<class 'tuple'>, type=<class 'type'>, len=<built-in function len>)",
        "alias": "_make_key",
        "help": "Help on function _make_key in module functools:\n\n_make_key(\n    args,\n    kwds,\n    typed,\n    kwd_mark=(<object object at 0x000001950D0902E0>,),\n    fasttypes={<class 'int'>, <class 'str'>},\n    tuple=<class 'tuple'>,\n    type=<class 'type'>,\n    len=<built-in function len>\n)\n    Make a cache key from optionally typed positional and keyword arguments\n\n    The key is constructed in a way that is flat as possible rather than\n    as a nested structure that would take more memory.\n\n    If there is only a single argument and its data type is known to cache\n    its hash value, then that argument is returned without a wrapper.  This\n    saves space and improves lookup speed.",
        "syntax": "Syntax: _make_key(args, kwds, typed, kwd_mark=(<object object at 0x000001950D0902E0>,), fasttypes={<class 'int'>, <class 'str'>}, tuple=<class 'tuple'>, type=<class 'type'>, len=<built-in function len>)",
        "other-params": ""
    },
    "functools._unwrap_partial": {
        "function": "_unwrap_partial(func)",
        "alias": "_unwrap_partial",
        "help": "Help on function _unwrap_partial in module functools:\n\n_unwrap_partial(func)",
        "syntax": "Syntax: _unwrap_partial(func)",
        "other-params": ""
    },
    "functools._unwrap_partialmethod": {
        "function": "_unwrap_partialmethod(func)",
        "alias": "_unwrap_partialmethod",
        "help": "Help on function _unwrap_partialmethod in module functools:\n\n_unwrap_partialmethod(func)",
        "syntax": "Syntax: _unwrap_partialmethod(func)",
        "other-params": ""
    },
    "functools.cache": {
        "function": "cache(user_function, /)",
        "alias": "cache",
        "help": "Help on function cache in module functools:\n\ncache(user_function, /)\n    Simple lightweight unbounded cache.  Sometimes called \"memoize\".",
        "syntax": "Syntax: cache(user_function, /)",
        "other-params": ""
    },
    "functools.cached_property": {
        "function": "cached_property(func)",
        "alias": "cached_property",
        "help": "Help on class cached_property in module functools:\n\nclass cached_property(builtins.object)\n |  cached_property(func)\n |\n |  Methods defined here:\n |\n |  __get__(self, instance, owner=None)\n |\n |  __init__(self, func)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __set_name__(self, owner, name)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: cached_property(func)",
        "other-params": ""
    },
    "functools.cmp_to_key": {
        "function": "cmp_to_key(mycmp)",
        "alias": "cmp_to_key",
        "help": "Help on built-in function cmp_to_key in module _functools:\n\ncmp_to_key(mycmp)\n    Convert a cmp= function into a key= function.\n\n    mycmp\n      Function that compares two objects.",
        "syntax": "Syntax: cmp_to_key(mycmp)",
        "other-params": ""
    },
    "functools.get_cache_token": {
        "function": "get_cache_token()",
        "alias": "get_cache_token",
        "help": "Help on built-in function get_cache_token in module _abc:\n\nget_cache_token()\n    Returns the current ABC cache token.\n\n    The token is an opaque object (supporting equality testing) identifying the\n    current version of the ABC cache for virtual subclasses. The token changes\n    with every call to register() on any ABC.",
        "syntax": "Syntax: get_cache_token()",
        "other-params": ""
    },
    "functools.lru_cache": {
        "function": "lru_cache(maxsize=128, typed=False)",
        "alias": "lru_cache",
        "help": "Help on function lru_cache in module functools:\n\nlru_cache(maxsize=128, typed=False)\n    Least-recently-used cache decorator.\n\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(decimal.Decimal(\"3.0\")) and f(3.0) will be treated as\n    distinct calls with distinct results. Some types such as str and int may\n    be cached separately even when typed is false.\n\n    Arguments to the cached function must be hashable.\n\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n\n    See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)",
        "syntax": "Syntax: lru_cache(maxsize=128, typed=False)",
        "other-params": ""
    },
    "functools.namedtuple": {
        "function": "namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)",
        "alias": "namedtuple",
        "help": "Help on function namedtuple in module collections:\n\nnamedtuple(typename, field_names, *, rename=False, defaults=None, module=None)\n    Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)",
        "syntax": "Syntax: namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)",
        "other-params": ""
    },
    "functools.partial": {
        "function": "partial(func, /, *args, **keywords)",
        "alias": "partial",
        "help": "Help on class partial in module functools:\n\nclass partial(builtins.object)\n |  partial(func, /, *args, **keywords)\n |\n |  Create a new function with partial application of the given arguments\n |  and keywords.\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __setstate__(self, object, /)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |\n |  __vectorcalloffset__\n |\n |  args\n |      tuple of arguments to future partial calls\n |\n |  func\n |      function object to use in future partial calls\n |\n |  keywords\n |      dictionary of keyword arguments to future partial calls",
        "syntax": "Syntax: partial(func, /, *args, **keywords)",
        "other-params": ""
    },
    "functools.partialmethod": {
        "function": "partialmethod(func, /, *args, **keywords)",
        "alias": "partialmethod",
        "help": "Help on class partialmethod in module functools:\n\nclass partialmethod(builtins.object)\n |  partialmethod(func, /, *args, **keywords)\n |\n |  Method descriptor with partial application of the given arguments\n |  and keywords.\n |\n |  Supports wrapping existing descriptors and handles non-descriptor\n |  callables as instance methods.\n |\n |  Methods defined here:\n |\n |  __get__(self, obj, cls=None)\n |\n |  __init__(self, func, /, *args, **keywords)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  __isabstractmethod__\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: partialmethod(func, /, *args, **keywords)",
        "other-params": ""
    },
    "functools.recursive_repr": {
        "function": "recursive_repr(fillvalue='...')",
        "alias": "recursive_repr",
        "help": "Help on function recursive_repr in module reprlib:\n\nrecursive_repr(fillvalue='...')\n    Decorator to make a repr function return fillvalue for a recursive call",
        "syntax": "Syntax: recursive_repr(fillvalue='...')",
        "other-params": ""
    },
    "functools.reduce": {
        "function": "Error retrieving signature: no signature found for builtin <built-in function reduce>",
        "alias": "reduce",
        "help": "Help on built-in function reduce in module _functools:\n\nreduce(...)\n    reduce(function, iterable[, initial], /) -> value\n\n    Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    This effectively reduces the iterable to a single value.  If initial is present,\n    it is placed before the items of the iterable in the calculation, and serves as\n    a default when the iterable is empty.\n\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])\n    calculates ((((1 + 2) + 3) + 4) + 5).",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin <built-in function reduce>",
        "other-params": ""
    },
    "functools.singledispatch": {
        "function": "singledispatch(func)",
        "alias": "singledispatch",
        "help": "Help on function singledispatch in module functools:\n\nsingledispatch(func)\n    Single-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.",
        "syntax": "Syntax: singledispatch(func)",
        "other-params": ""
    },
    "functools.singledispatchmethod": {
        "function": "singledispatchmethod(func)",
        "alias": "singledispatchmethod",
        "help": "Help on class singledispatchmethod in module functools:\n\nclass singledispatchmethod(builtins.object)\n |  singledispatchmethod(func)\n |\n |  Single-dispatch generic method descriptor.\n |\n |  Supports wrapping existing descriptors and handles non-descriptor\n |  callables as instance methods.\n |\n |  Methods defined here:\n |\n |  __get__(self, obj, cls=None)\n |\n |  __init__(self, func)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  register(self, cls, method=None)\n |      generic_method.register(cls, func) -> func\n |\n |      Registers a new implementation for the given *cls* on a *generic_method*.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  __isabstractmethod__\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: singledispatchmethod(func)",
        "other-params": ""
    },
    "functools.total_ordering": {
        "function": "total_ordering(cls)",
        "alias": "total_ordering",
        "help": "Help on function total_ordering in module functools:\n\ntotal_ordering(cls)\n    Class decorator that fills in missing ordering methods",
        "syntax": "Syntax: total_ordering(cls)",
        "other-params": ""
    },
    "functools.update_wrapper": {
        "function": "update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "alias": "update_wrapper",
        "help": "Help on function update_wrapper in module functools:\n\nupdate_wrapper(\n    wrapper,\n    wrapped,\n    assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'),\n    updated=('__dict__',)\n)\n    Update a wrapper function to look like the wrapped function\n\n    wrapper is the function to be updated\n    wrapped is the original function\n    assigned is a tuple naming the attributes assigned directly\n    from the wrapped function to the wrapper function (defaults to\n    functools.WRAPPER_ASSIGNMENTS)\n    updated is a tuple naming the attributes of the wrapper that\n    are updated with the corresponding attribute from the wrapped\n    function (defaults to functools.WRAPPER_UPDATES)",
        "syntax": "Syntax: update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "other-params": ""
    },
    "functools.wraps": {
        "function": "wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "alias": "wraps",
        "help": "Help on function wraps in module functools:\n\nwraps(\n    wrapped,\n    assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'),\n    updated=('__dict__',)\n)\n    Decorator factory to apply update_wrapper() to a wrapper function\n\n    Returns a decorator that invokes update_wrapper() with the decorated\n    function as the wrapper argument and the arguments to wraps() as the\n    remaining arguments. Default arguments are as for update_wrapper().\n    This is a convenience function to simplify applying partial() to\n    update_wrapper().",
        "syntax": "Syntax: wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "other-params": ""
    },
    "contextlib.AbstractAsyncContextManager": {
        "function": "AbstractAsyncContextManager()",
        "alias": "AbstractAsyncContextManager",
        "help": "Help on class AbstractAsyncContextManager in module contextlib:\n\nclass AbstractAsyncContextManager(abc.ABC)\n |  An abstract base class for asynchronous context managers.\n |\n |  Method resolution order:\n |      AbstractAsyncContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __aenter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  async __aexit__(self, exc_type, exc_value, traceback)\n |      Raise any exception triggered within the runtime context.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__aexit__'})",
        "syntax": "Syntax: AbstractAsyncContextManager()",
        "other-params": ""
    },
    "contextlib.AbstractContextManager": {
        "function": "AbstractContextManager()",
        "alias": "AbstractContextManager",
        "help": "Help on class AbstractContextManager in module contextlib:\n\nclass AbstractContextManager(abc.ABC)\n |  An abstract base class for context managers.\n |\n |  Method resolution order:\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, exc_type, exc_value, traceback)\n |      Raise any exception triggered within the runtime context.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__exit__'})",
        "syntax": "Syntax: AbstractContextManager()",
        "other-params": ""
    },
    "contextlib.AsyncContextDecorator": {
        "function": "AsyncContextDecorator()",
        "alias": "AsyncContextDecorator",
        "help": "Help on class AsyncContextDecorator in module contextlib:\n\nclass AsyncContextDecorator(builtins.object)\n |  A base class or mixin that enables async context managers to work as decorators.\n |\n |  Methods defined here:\n |\n |  __call__(self, func)\n |      Call self as a function.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: AsyncContextDecorator()",
        "other-params": ""
    },
    "contextlib.AsyncExitStack": {
        "function": "AsyncExitStack()",
        "alias": "AsyncExitStack",
        "help": "Help on class AsyncExitStack in module contextlib:\n\nclass AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager)\n |  Async context manager for dynamic management of a stack of exit\n |  callbacks.\n |\n |  For example:\n |      async with AsyncExitStack() as stack:\n |          connections = [await stack.enter_async_context(get_connection())\n |              for i in range(5)]\n |          # All opened connections will automatically be released at the\n |          # end of the async with statement, even if attempts to open a\n |          # connection later in the list raise an exception.\n |\n |  Method resolution order:\n |      AsyncExitStack\n |      _BaseExitStack\n |      AbstractAsyncContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __aenter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  async __aexit__(self, *exc_details)\n |      Raise any exception triggered within the runtime context.\n |\n |  async aclose(self)\n |      Immediately unwind the context stack.\n |\n |  async enter_async_context(self, cm)\n |      Enters the supplied async context manager.\n |\n |      If successful, also pushes its __aexit__ method as a callback and\n |      returns the result of the __aenter__ method.\n |\n |  push_async_callback(self, callback, /, *args, **kwds)\n |      Registers an arbitrary coroutine function and arguments.\n |\n |      Cannot suppress exceptions.\n |\n |  push_async_exit(self, exit)\n |      Registers a coroutine function with the standard __aexit__ method\n |      signature.\n |\n |      Can suppress exceptions the same way __aexit__ method can.\n |      Also accepts any object with an __aexit__ method (registering a call\n |      to the method instead of the object itself).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BaseExitStack:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  callback(self, callback, /, *args, **kwds)\n |      Registers an arbitrary callback and arguments.\n |\n |      Cannot suppress exceptions.\n |\n |  enter_context(self, cm)\n |      Enters the supplied context manager.\n |\n |      If successful, also pushes its __exit__ method as a callback and\n |      returns the result of the __enter__ method.\n |\n |  pop_all(self)\n |      Preserve the context stack by transferring it to a new instance.\n |\n |  push(self, exit)\n |      Registers a callback with the standard __exit__ method signature.\n |\n |      Can suppress exceptions the same way __exit__ method can.\n |      Also accepts any object with an __exit__ method (registering a call\n |      to the method instead of the object itself).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _BaseExitStack:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractAsyncContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: AsyncExitStack()",
        "other-params": ""
    },
    "contextlib.ContextDecorator": {
        "function": "ContextDecorator()",
        "alias": "ContextDecorator",
        "help": "Help on class ContextDecorator in module contextlib:\n\nclass ContextDecorator(builtins.object)\n |  A base class or mixin that enables context managers to work as decorators.\n |\n |  Methods defined here:\n |\n |  __call__(self, func)\n |      Call self as a function.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: ContextDecorator()",
        "other-params": ""
    },
    "contextlib.ExitStack": {
        "function": "ExitStack()",
        "alias": "ExitStack",
        "help": "Help on class ExitStack in module contextlib:\n\nclass ExitStack(_BaseExitStack, AbstractContextManager)\n |  Context manager for dynamic management of a stack of exit callbacks.\n |\n |  For example:\n |      with ExitStack() as stack:\n |          files = [stack.enter_context(open(fname)) for fname in filenames]\n |          # All opened files will automatically be closed at the end of\n |          # the with statement, even if attempts to open files later\n |          # in the list raise an exception.\n |\n |  Method resolution order:\n |      ExitStack\n |      _BaseExitStack\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, *exc_details)\n |      Raise any exception triggered within the runtime context.\n |\n |  close(self)\n |      Immediately unwind the context stack.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _BaseExitStack:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  callback(self, callback, /, *args, **kwds)\n |      Registers an arbitrary callback and arguments.\n |\n |      Cannot suppress exceptions.\n |\n |  enter_context(self, cm)\n |      Enters the supplied context manager.\n |\n |      If successful, also pushes its __exit__ method as a callback and\n |      returns the result of the __enter__ method.\n |\n |  pop_all(self)\n |      Preserve the context stack by transferring it to a new instance.\n |\n |  push(self, exit)\n |      Registers a callback with the standard __exit__ method signature.\n |\n |      Can suppress exceptions the same way __exit__ method can.\n |      Also accepts any object with an __exit__ method (registering a call\n |      to the method instead of the object itself).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _BaseExitStack:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: ExitStack()",
        "other-params": ""
    },
    "contextlib.GenericAlias": {
        "function": "GenericAlias(origin, args, /)",
        "alias": "GenericAlias",
        "help": "Help on class GenericAlias in module types:\n\nclass GenericAlias(builtins.object)\n |  GenericAlias(origin, args, /)\n |\n |  Represent a PEP 585 generic type\n |\n |  E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __dir__(self, /)\n |      Default dir() implementation.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __instancecheck__(self, object, /)\n |      Check if an object is an instance.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mro_entries__(self, object, /)\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __subclasscheck__(self, object, /)\n |      Check if a class is a subclass.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __args__\n |\n |  __origin__\n |\n |  __parameters__\n |      Type variables in the GenericAlias.\n |\n |  __typing_unpacked_tuple_args__\n |\n |  __unpacked__",
        "syntax": "Syntax: GenericAlias(origin, args, /)",
        "other-params": ""
    },
    "contextlib.MethodType": {
        "function": "MethodType(function, instance, /)",
        "alias": "MethodType",
        "help": "Help on class method in module builtins:\n\nclass method(object)\n |  method(function, instance, /)\n |\n |  Create a bound instance method object.\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __func__\n |      the function (or other callable) implementing a method\n |\n |  __self__\n |      the instance to which a method is bound",
        "syntax": "Syntax: MethodType(function, instance, /)",
        "other-params": ""
    },
    "contextlib._AsyncGeneratorContextManager": {
        "function": "_AsyncGeneratorContextManager(func, args, kwds)",
        "alias": "_AsyncGeneratorContextManager",
        "help": "Help on class _AsyncGeneratorContextManager in module contextlib:\n\nclass _AsyncGeneratorContextManager(_GeneratorContextManagerBase, AbstractAsyncContextManager, AsyncContextDecorator)\n |  _AsyncGeneratorContextManager(func, args, kwds)\n |\n |  Helper for @asynccontextmanager decorator.\n |\n |  Method resolution order:\n |      _AsyncGeneratorContextManager\n |      _GeneratorContextManagerBase\n |      AbstractAsyncContextManager\n |      abc.ABC\n |      AsyncContextDecorator\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __aenter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  async __aexit__(self, typ, value, traceback)\n |      Raise any exception triggered within the runtime context.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _GeneratorContextManagerBase:\n |\n |  __init__(self, func, args, kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _GeneratorContextManagerBase:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractAsyncContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from AsyncContextDecorator:\n |\n |  __call__(self, func)\n |      Call self as a function.",
        "syntax": "Syntax: _AsyncGeneratorContextManager(func, args, kwds)",
        "other-params": ""
    },
    "contextlib._BaseExitStack": {
        "function": "_BaseExitStack()",
        "alias": "_BaseExitStack",
        "help": "Help on class _BaseExitStack in module contextlib:\n\nclass _BaseExitStack(builtins.object)\n |  A base class for ExitStack and AsyncExitStack.\n |\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  callback(self, callback, /, *args, **kwds)\n |      Registers an arbitrary callback and arguments.\n |\n |      Cannot suppress exceptions.\n |\n |  enter_context(self, cm)\n |      Enters the supplied context manager.\n |\n |      If successful, also pushes its __exit__ method as a callback and\n |      returns the result of the __enter__ method.\n |\n |  pop_all(self)\n |      Preserve the context stack by transferring it to a new instance.\n |\n |  push(self, exit)\n |      Registers a callback with the standard __exit__ method signature.\n |\n |      Can suppress exceptions the same way __exit__ method can.\n |      Also accepts any object with an __exit__ method (registering a call\n |      to the method instead of the object itself).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _BaseExitStack()",
        "other-params": ""
    },
    "contextlib._GeneratorContextManager": {
        "function": "_GeneratorContextManager(func, args, kwds)",
        "alias": "_GeneratorContextManager",
        "help": "Help on class _GeneratorContextManager in module contextlib:\n\nclass _GeneratorContextManager(_GeneratorContextManagerBase, AbstractContextManager, ContextDecorator)\n |  _GeneratorContextManager(func, args, kwds)\n |\n |  Helper for @contextmanager decorator.\n |\n |  Method resolution order:\n |      _GeneratorContextManager\n |      _GeneratorContextManagerBase\n |      AbstractContextManager\n |      abc.ABC\n |      ContextDecorator\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, typ, value, traceback)\n |      Raise any exception triggered within the runtime context.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _GeneratorContextManagerBase:\n |\n |  __init__(self, func, args, kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _GeneratorContextManagerBase:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from ContextDecorator:\n |\n |  __call__(self, func)\n |      Call self as a function.",
        "syntax": "Syntax: _GeneratorContextManager(func, args, kwds)",
        "other-params": ""
    },
    "contextlib._GeneratorContextManagerBase": {
        "function": "_GeneratorContextManagerBase(func, args, kwds)",
        "alias": "_GeneratorContextManagerBase",
        "help": "Help on class _GeneratorContextManagerBase in module contextlib:\n\nclass _GeneratorContextManagerBase(builtins.object)\n |  _GeneratorContextManagerBase(func, args, kwds)\n |\n |  Shared functionality for @contextmanager and @asynccontextmanager.\n |\n |  Methods defined here:\n |\n |  __init__(self, func, args, kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _GeneratorContextManagerBase(func, args, kwds)",
        "other-params": ""
    },
    "contextlib._RedirectStream": {
        "function": "_RedirectStream(new_target)",
        "alias": "_RedirectStream",
        "help": "Help on class _RedirectStream in module contextlib:\n\nclass _RedirectStream(AbstractContextManager)\n |  _RedirectStream(new_target)\n |\n |  Method resolution order:\n |      _RedirectStream\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, exctype, excinst, exctb)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, new_target)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: _RedirectStream(new_target)",
        "other-params": ""
    },
    "contextlib.aclosing": {
        "function": "aclosing(thing)",
        "alias": "aclosing",
        "help": "Help on class aclosing in module contextlib:\n\nclass aclosing(AbstractAsyncContextManager)\n |  aclosing(thing)\n |\n |  Async context manager for safely finalizing an asynchronously cleaned-up\n |  resource such as an async generator, calling its ``aclose()`` method.\n |\n |  Code like this:\n |\n |      async with aclosing(<module>.fetch(<arguments>)) as agen:\n |          <block>\n |\n |  is equivalent to this:\n |\n |      agen = <module>.fetch(<arguments>)\n |      try:\n |          <block>\n |      finally:\n |          await agen.aclose()\n |\n |  Method resolution order:\n |      aclosing\n |      AbstractAsyncContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __aenter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  async __aexit__(self, *exc_info)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, thing)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractAsyncContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: aclosing(thing)",
        "other-params": ""
    },
    "contextlib.asynccontextmanager": {
        "function": "asynccontextmanager(func)",
        "alias": "asynccontextmanager",
        "help": "Help on function asynccontextmanager in module contextlib:\n\nasynccontextmanager(func)\n    @asynccontextmanager decorator.\n\n    Typical usage:\n\n        @asynccontextmanager\n        async def some_async_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        async with some_async_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>",
        "syntax": "Syntax: asynccontextmanager(func)",
        "other-params": ""
    },
    "contextlib.chdir": {
        "function": "chdir(path)",
        "alias": "chdir",
        "help": "Help on class chdir in module contextlib:\n\nclass chdir(AbstractContextManager)\n |  chdir(path)\n |\n |  Non thread-safe context manager to change the current working directory.\n |\n |  Method resolution order:\n |      chdir\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, *excinfo)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, path)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: chdir(path)",
        "other-params": ""
    },
    "contextlib.closing": {
        "function": "closing(thing)",
        "alias": "closing",
        "help": "Help on class closing in module contextlib:\n\nclass closing(AbstractContextManager)\n |  closing(thing)\n |\n |  Context to automatically close something at the end of a block.\n |\n |  Code like this:\n |\n |      with closing(<module>.open(<arguments>)) as f:\n |          <block>\n |\n |  is equivalent to this:\n |\n |      f = <module>.open(<arguments>)\n |      try:\n |          <block>\n |      finally:\n |          f.close()\n |\n |  Method resolution order:\n |      closing\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, *exc_info)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, thing)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: closing(thing)",
        "other-params": ""
    },
    "contextlib.contextmanager": {
        "function": "contextmanager(func)",
        "alias": "contextmanager",
        "help": "Help on function contextmanager in module contextlib:\n\ncontextmanager(func)\n    @contextmanager decorator.\n\n    Typical usage:\n\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        with some_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>",
        "syntax": "Syntax: contextmanager(func)",
        "other-params": ""
    },
    "contextlib.deque": {
        "function": "Error retrieving signature: <class 'collections.deque'> builtin has invalid signature",
        "alias": "deque",
        "help": "Help on class deque in module collections:\n\nclass deque(builtins.object)\n |  deque([iterable[, maxlen]])\n |\n |  A list-like sequence optimized for data accesses near its endpoints.\n |\n |  Methods defined here:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __copy__(self, /)\n |      Return a shallow copy of a deque.\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |\n |  __imul__(self, value, /)\n |      Implement self*=value.\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the deque.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |\n |  __sizeof__(self, /)\n |      Return the size of the deque in memory, in bytes.\n |\n |  append(self, item, /)\n |      Add an element to the right side of the deque.\n |\n |  appendleft(self, item, /)\n |      Add an element to the left side of the deque.\n |\n |  clear(self, /)\n |      Remove all elements from the deque.\n |\n |  copy(self, /)\n |      Return a shallow copy of a deque.\n |\n |  count(self, value, /)\n |      Return number of occurrences of value.\n |\n |  extend(self, iterable, /)\n |      Extend the right side of the deque with elements from the iterable.\n |\n |  extendleft(self, iterable, /)\n |      Extend the left side of the deque with elements from the iterable.\n |\n |  index(self, value, [start, [stop]])\n |      Return first index of value.\n |\n |      Raises ValueError if the value is not present.\n |\n |  insert(self, index, value, /)\n |      Insert value before index.\n |\n |  pop(self, /)\n |      Remove and return the rightmost element.\n |\n |  popleft(self, /)\n |      Remove and return the leftmost element.\n |\n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |\n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |\n |  rotate(self, n=1, /)\n |      Rotate the deque n steps to the right.  If n is negative, rotates left.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  maxlen\n |      maximum size of a deque or None if unbounded\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: Error retrieving signature: <class 'collections.deque'> builtin has invalid signature",
        "other-params": ""
    },
    "contextlib.nullcontext": {
        "function": "nullcontext(enter_result=None)",
        "alias": "nullcontext",
        "help": "Help on class nullcontext in module contextlib:\n\nclass nullcontext(AbstractContextManager, AbstractAsyncContextManager)\n |  nullcontext(enter_result=None)\n |\n |  Context manager that does no additional processing.\n |\n |  Used as a stand-in for a normal context manager, when a particular\n |  block of code is only sometimes used with a normal context manager:\n |\n |  cm = optional_cm if condition else nullcontext()\n |  with cm:\n |      # Perform operation, using optional_cm if condition is True\n |\n |  Method resolution order:\n |      nullcontext\n |      AbstractContextManager\n |      AbstractAsyncContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  async __aenter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  async __aexit__(self, *excinfo)\n |      Raise any exception triggered within the runtime context.\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, *excinfo)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, enter_result=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: nullcontext(enter_result=None)",
        "other-params": ""
    },
    "contextlib.redirect_stderr": {
        "function": "redirect_stderr(new_target)",
        "alias": "redirect_stderr",
        "help": "Help on class redirect_stderr in module contextlib:\n\nclass redirect_stderr(_RedirectStream)\n |  redirect_stderr(new_target)\n |\n |  Context manager for temporarily redirecting stderr to another file.\n |\n |  Method resolution order:\n |      redirect_stderr\n |      _RedirectStream\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _RedirectStream:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, exctype, excinst, exctb)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, new_target)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _RedirectStream:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: redirect_stderr(new_target)",
        "other-params": ""
    },
    "contextlib.redirect_stdout": {
        "function": "redirect_stdout(new_target)",
        "alias": "redirect_stdout",
        "help": "Help on class redirect_stdout in module contextlib:\n\nclass redirect_stdout(_RedirectStream)\n |  redirect_stdout(new_target)\n |\n |  Context manager for temporarily redirecting stdout to another file.\n |\n |  # How to send help() to stderr\n |  with redirect_stdout(sys.stderr):\n |      help(dir)\n |\n |  # How to write help() to a file\n |  with open('help.txt', 'w') as f:\n |      with redirect_stdout(f):\n |          help(pow)\n |\n |  Method resolution order:\n |      redirect_stdout\n |      _RedirectStream\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _RedirectStream:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, exctype, excinst, exctb)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, new_target)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _RedirectStream:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: redirect_stdout(new_target)",
        "other-params": ""
    },
    "contextlib.suppress": {
        "function": "suppress(*exceptions)",
        "alias": "suppress",
        "help": "Help on class suppress in module contextlib:\n\nclass suppress(AbstractContextManager)\n |  suppress(*exceptions)\n |\n |  Context manager to suppress specified exceptions\n |\n |  After the exception is suppressed, execution proceeds with the next\n |  statement following the with statement.\n |\n |       with suppress(FileNotFoundError):\n |           os.remove(somefile)\n |       # Execution still resumes here if the file was already removed\n |\n |  Method resolution order:\n |      suppress\n |      AbstractContextManager\n |      abc.ABC\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |      Return `self` upon entering the runtime context.\n |\n |  __exit__(self, exctype, excinst, exctb)\n |      Raise any exception triggered within the runtime context.\n |\n |  __init__(self, *exceptions)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from AbstractContextManager:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).",
        "syntax": "Syntax: suppress(*exceptions)",
        "other-params": ""
    },
    "contextlib.wraps": {
        "function": "wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "alias": "wraps",
        "help": "Help on function wraps in module functools:\n\nwraps(\n    wrapped,\n    assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'),\n    updated=('__dict__',)\n)\n    Decorator factory to apply update_wrapper() to a wrapper function\n\n    Returns a decorator that invokes update_wrapper() with the decorated\n    function as the wrapper argument and the arguments to wraps() as the\n    remaining arguments. Default arguments are as for update_wrapper().\n    This is a convenience function to simplify applying partial() to\n    update_wrapper().",
        "syntax": "Syntax: wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
        "other-params": ""
    },
    "enum.DynamicClassAttribute": {
        "function": "DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)",
        "alias": "DynamicClassAttribute",
        "help": "Help on class DynamicClassAttribute in module types:\n\nclass DynamicClassAttribute(builtins.object)\n |  DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)\n |\n |  Route attribute access on a class to __getattr__.\n |\n |  This is a descriptor, used to define attributes that act differently when\n |  accessed through an instance and through a class.  Instance access remains\n |  normal, but access to an attribute through a class will be routed to the\n |  class's __getattr__ method; this is done by raising AttributeError.\n |\n |  This allows one to have properties active on an instance, and have virtual\n |  attributes on the class with the same name.  (Enum used this between Python\n |  versions 3.4 - 3.9 .)\n |\n |  Subclass from this to use a different method of accessing virtual attributes\n |  and still be treated properly by the inspect module. (Enum uses this since\n |  Python 3.10 .)\n |\n |  Methods defined here:\n |\n |  __delete__(self, instance)\n |\n |  __get__(self, instance, ownerclass=None)\n |\n |  __init__(self, fget=None, fset=None, fdel=None, doc=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __set__(self, instance, value)\n |\n |  deleter(self, fdel)\n |\n |  getter(self, fget)\n |\n |  setter(self, fset)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)",
        "other-params": ""
    },
    "enum.Enum": {
        "function": "Enum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "Enum",
        "help": "Help on class Enum in module enum:\n\nclass Enum(builtins.object)\n |  Enum(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Create a collection of name/value pairs.\n |\n |  Example enumeration:\n |\n |  >>> class Color(Enum):\n |  ...     RED = 1\n |  ...     BLUE = 2\n |  ...     GREEN = 3\n |\n |  Access them by:\n |\n |  - attribute access:\n |\n |    >>> Color.RED\n |    <Color.RED: 1>\n |\n |  - value lookup:\n |\n |    >>> Color(1)\n |    <Color.RED: 1>\n |\n |  - name lookup:\n |\n |    >>> Color['RED']\n |    <Color.RED: 1>\n |\n |  Enumerations can be iterated over, and know how many members they have:\n |\n |  >>> len(Color)\n |  3\n |\n |  >>> list(Color)\n |  [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n |\n |  Methods can be added to enumerations, and members can have their own\n |  attributes -- see the documentation for details.\n |\n |  Static methods defined here:\n |\n |  __new__(cls, value)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from EnumType:\n |\n |  __contains__(value)\n |      Return True if `value` is in `cls`.\n |\n |      `value` is in `cls` if:\n |      1) `value` is a member of `cls`, or\n |      2) `value` is the value of one of the `cls`'s members.\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  __iter__()\n |      Return members in definition order.\n |\n |  __len__()\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: Enum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum.EnumCheck": {
        "function": "EnumCheck(*values)",
        "alias": "EnumCheck",
        "help": "Help on class EnumCheck in module enum:\n\nclass EnumCheck(StrEnum)\n |  EnumCheck(*values)\n |\n |  various conditions to check an enumeration for\n |\n |  Method resolution order:\n |      EnumCheck\n |      StrEnum\n |      builtins.str\n |      ReprEnum\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __format__(self, format_spec, /) from builtins.str\n |      Return a formatted version of the string as described by format_spec.\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __str__(self, /) from builtins.str\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  CONTINUOUS = <EnumCheck.CONTINUOUS: 'no skipped integer values'>\n |\n |  NAMED_FLAGS = <EnumCheck.NAMED_FLAGS: 'multi-flag aliases may not cont...\n |\n |  UNIQUE = <EnumCheck.UNIQUE: 'one name per value'>\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from StrEnum:\n |\n |  __repr__(self) from enum.Enum\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.str:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the string in memory, in bytes.\n |\n |  capitalize(self, /)\n |      Return a capitalized version of the string.\n |\n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |\n |  casefold(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |\n |  center(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  count(self, sub[, start[, end]], /)\n |      Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |\n |  encode(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |\n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |\n |  endswith(self, suffix[, start[, end]], /)\n |      Return True if the string ends with the specified suffix, False otherwise.\n |\n |      suffix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  expandtabs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |\n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |\n |  find(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  format(self, /, *args, **kwargs)\n |      Return a formatted version of the string, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  format_map(self, mapping, /)\n |      Return a formatted version of the string, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  index(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  isalnum(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |\n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |\n |  isalpha(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |\n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |\n |  isascii(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |\n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |\n |  isdecimal(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |\n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |\n |  isdigit(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |\n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |\n |  isidentifier(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |\n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |\n |  islower(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |\n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |\n |  isnumeric(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |\n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |\n |  isprintable(self, /)\n |      Return True if the string is printable, False otherwise.\n |\n |      A string is printable if all of its characters are considered printable in\n |      repr() or if it is empty.\n |\n |  isspace(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |\n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |\n |  istitle(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |\n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |\n |  isupper(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |\n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |\n |  join(self, iterable, /)\n |      Concatenate any number of strings.\n |\n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |\n |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n |\n |  ljust(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  lower(self, /)\n |      Return a copy of the string converted to lowercase.\n |\n |  lstrip(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  partition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |\n |  removeprefix(self, prefix, /)\n |      Return a str with the given prefix string removed if present.\n |\n |      If the string starts with the prefix string, return string[len(prefix):].\n |      Otherwise, return a copy of the original string.\n |\n |  removesuffix(self, suffix, /)\n |      Return a str with the given suffix string removed if present.\n |\n |      If the string ends with the suffix string and that suffix is not empty,\n |      return string[:-len(suffix)]. Otherwise, return a copy of the original\n |      string.\n |\n |  replace(self, old, new, /, count=-1)\n |      Return a copy with all occurrences of substring old replaced by new.\n |\n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |\n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |\n |  rfind(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  rindex(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  rjust(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  rpartition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |\n |  rsplit(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the end of the string and works to the front.\n |\n |  rstrip(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  split(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the front of the string and works to the end.\n |\n |      Note, str.split() is mainly useful for data that has been intentionally\n |      delimited.  With natural text that includes punctuation, consider using\n |      the regular expression module.\n |\n |  splitlines(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |\n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |\n |  startswith(self, prefix[, start[, end]], /)\n |      Return True if the string starts with the specified prefix, False otherwise.\n |\n |      prefix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  strip(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  swapcase(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |\n |  title(self, /)\n |      Return a version of the string where each word is titlecased.\n |\n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |\n |  translate(self, table, /)\n |      Replace each character in the string using the given translation table.\n |\n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |\n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |\n |  upper(self, /)\n |      Return a copy of the string converted to uppercase.\n |\n |  zfill(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |\n |      The string is never truncated.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.str:\n |\n |  maketrans(x, y=<unrepresentable>, z=<unrepresentable>, /)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: EnumCheck(*values)",
        "other-params": ""
    },
    "enum.EnumDict": {
        "function": "EnumDict()",
        "alias": "EnumDict",
        "help": "Help on class EnumDict in module enum:\n\nclass EnumDict(builtins.dict)\n |  Track enum member order and ensure member names are not reused.\n |\n |  EnumType will use the names found in self._member_names as the\n |  enumeration member names.\n |\n |  Method resolution order:\n |      EnumDict\n |      builtins.dict\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __setitem__(self, key, value)\n |      Changes anything not dundered or not a descriptor.\n |\n |      If an enum member name is used twice, an error is raised; duplicate\n |      values are not checked for.\n |\n |      Single underscore (sunder) names are reserved.\n |\n |  update(self, members, **more_members)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  member_names\n |\n |  member_names\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |\n |  __contains__(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the dict in memory, in bytes.\n |\n |  clear(self, /)\n |      Remove all items from the dict.\n |\n |  copy(self, /)\n |      Return a shallow copy of the dict.\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  items(self, /)\n |      Return a set-like object providing a view on the dict's items.\n |\n |  keys(self, /)\n |      Return a set-like object providing a view on the dict's keys.\n |\n |  pop(self, key, default=<unrepresentable>, /)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |\n |      If the key is not found, return the default if given; otherwise,\n |      raise a KeyError.\n |\n |  popitem(self, /)\n |      Remove and return a (key, value) pair as a 2-tuple.\n |\n |      Pairs are returned in LIFO (last-in, first-out) order.\n |      Raises KeyError if the dict is empty.\n |\n |  setdefault(self, key, default=None, /)\n |      Insert key with a value of default if key is not in the dictionary.\n |\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  values(self, /)\n |      Return an object providing a view on the dict's values.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.dict:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  fromkeys(iterable, value=None, /)\n |      Create a new dictionary with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |\n |  __new__(*args, **kwargs) class method of builtins.dict\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.dict:\n |\n |  __hash__ = None",
        "syntax": "Syntax: EnumDict()",
        "other-params": ""
    },
    "enum.EnumMeta": {
        "function": "EnumMeta(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
        "alias": "EnumMeta",
        "help": "Help on class EnumType in module enum:\n\nclass EnumType(builtins.type)\n |  EnumType(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)\n |\n |  Metaclass for Enum\n |\n |  Method resolution order:\n |      EnumType\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __bool__(cls)\n |      classes/types should always be True.\n |\n |  __call__(\n |      cls,\n |      value,\n |      names=<not given>,\n |      *values,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |      Either returns an existing member, or creates a new enum class.\n |\n |      This method is used both when an enum class is given a value to match\n |      to an enumeration member (i.e. Color(3)) and for the functional API\n |      (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n |\n |      The value lookup branch is chosen if the enum is final.\n |\n |      When used for the functional API:\n |\n |      `value` will be the name of the new class.\n |\n |      `names` should be either a string of white-space/comma delimited names\n |      (values will start at `start`), or an iterator/mapping of name, value pairs.\n |\n |      `module` should be set to the module this class is being created in;\n |      if it is not set, an attempt to find that module will be made, but if\n |      it fails the class will not be picklable.\n |\n |      `qualname` should be set to the actual location this class can be found\n |      at in its module; by default it is set to the global scope.  If this is\n |      not correct, unpickling will fail in some circumstances.\n |\n |      `type`, if set, will be mixed in as the first base class.\n |\n |  __contains__(cls, value)\n |      Return True if `value` is in `cls`.\n |\n |      `value` is in `cls` if:\n |      1) `value` is a member of `cls`, or\n |      2) `value` is the value of one of the `cls`'s members.\n |\n |  __delattr__(cls, attr)\n |      Implement delattr(self, name).\n |\n |  __dir__(cls)\n |      Specialized __dir__ implementation for types.\n |\n |  __getitem__(cls, name)\n |      Return the member matching `name`.\n |\n |  __iter__(cls)\n |      Return members in definition order.\n |\n |  __len__(cls)\n |      Return the number of members (no aliases)\n |\n |  __repr__(cls)\n |      Return repr(self).\n |\n |  __reversed__(cls)\n |      Return members in reverse definition order.\n |\n |  __setattr__(cls, name, value)\n |      Block attempts to reassign Enum members.\n |\n |      A simple assignment to the class namespace only changes one of the\n |      several possible ways to get an Enum member from the Enum class,\n |      resulting in an inconsistent Enumeration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __prepare__(cls, bases, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __instancecheck__(self, instance, /)\n |      Check if an object is an instance.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasscheck__(self, subclass, /)\n |      Check if a class is a subclass.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'type'>\n |      type(object) -> the object's type\n |      type(name, bases, dict, **kwds) -> a new type\n |\n |\n |  __bases__ = (<class 'type'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155894272\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'enum.EnumType'>, <class 'type'>, <class 'object'>)\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: EnumMeta(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
        "other-params": ""
    },
    "enum.EnumType": {
        "function": "EnumType(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
        "alias": "EnumType",
        "help": "Help on class EnumType in module enum:\n\nclass EnumType(builtins.type)\n |  EnumType(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)\n |\n |  Metaclass for Enum\n |\n |  Method resolution order:\n |      EnumType\n |      builtins.type\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __bool__(cls)\n |      classes/types should always be True.\n |\n |  __call__(\n |      cls,\n |      value,\n |      names=<not given>,\n |      *values,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |      Either returns an existing member, or creates a new enum class.\n |\n |      This method is used both when an enum class is given a value to match\n |      to an enumeration member (i.e. Color(3)) and for the functional API\n |      (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n |\n |      The value lookup branch is chosen if the enum is final.\n |\n |      When used for the functional API:\n |\n |      `value` will be the name of the new class.\n |\n |      `names` should be either a string of white-space/comma delimited names\n |      (values will start at `start`), or an iterator/mapping of name, value pairs.\n |\n |      `module` should be set to the module this class is being created in;\n |      if it is not set, an attempt to find that module will be made, but if\n |      it fails the class will not be picklable.\n |\n |      `qualname` should be set to the actual location this class can be found\n |      at in its module; by default it is set to the global scope.  If this is\n |      not correct, unpickling will fail in some circumstances.\n |\n |      `type`, if set, will be mixed in as the first base class.\n |\n |  __contains__(cls, value)\n |      Return True if `value` is in `cls`.\n |\n |      `value` is in `cls` if:\n |      1) `value` is a member of `cls`, or\n |      2) `value` is the value of one of the `cls`'s members.\n |\n |  __delattr__(cls, attr)\n |      Implement delattr(self, name).\n |\n |  __dir__(cls)\n |      Specialized __dir__ implementation for types.\n |\n |  __getitem__(cls, name)\n |      Return the member matching `name`.\n |\n |  __iter__(cls)\n |      Return members in definition order.\n |\n |  __len__(cls)\n |      Return the number of members (no aliases)\n |\n |  __repr__(cls)\n |      Return repr(self).\n |\n |  __reversed__(cls)\n |      Return members in reverse definition order.\n |\n |  __setattr__(cls, name, value)\n |      Block attempts to reassign Enum members.\n |\n |      A simple assignment to the class namespace only changes one of the\n |      several possible ways to get an Enum member from the Enum class,\n |      resulting in an inconsistent Enumeration.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __prepare__(cls, bases, **kwds)\n |      Create the namespace for the class statement\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __annotations__ = {}\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.type:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __instancecheck__(self, instance, /)\n |      Check if an object is an instance.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __sizeof__(self, /)\n |      Return memory consumption of the type object.\n |\n |  __subclasscheck__(self, subclass, /)\n |      Check if a class is a subclass.\n |\n |  __subclasses__(self, /)\n |      Return a list of immediate subclasses.\n |\n |  mro(self, /)\n |      Return a type's method resolution order.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.type:\n |\n |  __abstractmethods__\n |\n |  __dict__\n |\n |  __text_signature__\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.type:\n |\n |  __base__ = <class 'type'>\n |      type(object) -> the object's type\n |      type(name, bases, dict, **kwds) -> a new type\n |\n |\n |  __bases__ = (<class 'type'>,)\n |\n |  __basicsize__ = 928\n |\n |  __dictoffset__ = 264\n |\n |  __flags__ = 2155894272\n |\n |  __itemsize__ = 40\n |\n |  __mro__ = (<class 'enum.EnumType'>, <class 'type'>, <class 'object'>)\n |\n |  __type_params__ = ()\n |\n |  __weakrefoffset__ = 368",
        "syntax": "Syntax: EnumType(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
        "other-params": ""
    },
    "enum.Flag": {
        "function": "Flag(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "Flag",
        "help": "Help on class Flag in module enum:\n\nclass Flag(Enum)\n |  Flag(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Support for flags\n |\n |  Method resolution order:\n |      Flag\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, other)\n |      Returns True if self has at least the same flags set as other.\n |\n |  __iter__(self)\n |      Returns flags in definition order.\n |\n |  __len__(self)\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from EnumType:\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: Flag(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum.FlagBoundary": {
        "function": "FlagBoundary(*values)",
        "alias": "FlagBoundary",
        "help": "Help on class FlagBoundary in module enum:\n\nclass FlagBoundary(StrEnum)\n |  FlagBoundary(*values)\n |\n |  control how out of range values are handled\n |  \"strict\" -> error is raised             [default for Flag]\n |  \"conform\" -> extra bits are discarded\n |  \"eject\" -> lose flag status\n |  \"keep\" -> keep flag status and all bits [default for IntFlag]\n |\n |  Method resolution order:\n |      FlagBoundary\n |      StrEnum\n |      builtins.str\n |      ReprEnum\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __format__(self, format_spec, /) from builtins.str\n |      Return a formatted version of the string as described by format_spec.\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __str__(self, /) from builtins.str\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  CONFORM = <FlagBoundary.CONFORM: 'conform'>\n |\n |  EJECT = <FlagBoundary.EJECT: 'eject'>\n |\n |  KEEP = <FlagBoundary.KEEP: 'keep'>\n |\n |  STRICT = <FlagBoundary.STRICT: 'strict'>\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from StrEnum:\n |\n |  __repr__(self) from enum.Enum\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.str:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the string in memory, in bytes.\n |\n |  capitalize(self, /)\n |      Return a capitalized version of the string.\n |\n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |\n |  casefold(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |\n |  center(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  count(self, sub[, start[, end]], /)\n |      Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |\n |  encode(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |\n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |\n |  endswith(self, suffix[, start[, end]], /)\n |      Return True if the string ends with the specified suffix, False otherwise.\n |\n |      suffix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  expandtabs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |\n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |\n |  find(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  format(self, /, *args, **kwargs)\n |      Return a formatted version of the string, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  format_map(self, mapping, /)\n |      Return a formatted version of the string, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  index(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  isalnum(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |\n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |\n |  isalpha(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |\n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |\n |  isascii(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |\n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |\n |  isdecimal(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |\n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |\n |  isdigit(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |\n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |\n |  isidentifier(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |\n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |\n |  islower(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |\n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |\n |  isnumeric(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |\n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |\n |  isprintable(self, /)\n |      Return True if the string is printable, False otherwise.\n |\n |      A string is printable if all of its characters are considered printable in\n |      repr() or if it is empty.\n |\n |  isspace(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |\n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |\n |  istitle(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |\n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |\n |  isupper(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |\n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |\n |  join(self, iterable, /)\n |      Concatenate any number of strings.\n |\n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |\n |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n |\n |  ljust(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  lower(self, /)\n |      Return a copy of the string converted to lowercase.\n |\n |  lstrip(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  partition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |\n |  removeprefix(self, prefix, /)\n |      Return a str with the given prefix string removed if present.\n |\n |      If the string starts with the prefix string, return string[len(prefix):].\n |      Otherwise, return a copy of the original string.\n |\n |  removesuffix(self, suffix, /)\n |      Return a str with the given suffix string removed if present.\n |\n |      If the string ends with the suffix string and that suffix is not empty,\n |      return string[:-len(suffix)]. Otherwise, return a copy of the original\n |      string.\n |\n |  replace(self, old, new, /, count=-1)\n |      Return a copy with all occurrences of substring old replaced by new.\n |\n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |\n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |\n |  rfind(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  rindex(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  rjust(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  rpartition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |\n |  rsplit(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the end of the string and works to the front.\n |\n |  rstrip(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  split(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the front of the string and works to the end.\n |\n |      Note, str.split() is mainly useful for data that has been intentionally\n |      delimited.  With natural text that includes punctuation, consider using\n |      the regular expression module.\n |\n |  splitlines(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |\n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |\n |  startswith(self, prefix[, start[, end]], /)\n |      Return True if the string starts with the specified prefix, False otherwise.\n |\n |      prefix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  strip(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  swapcase(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |\n |  title(self, /)\n |      Return a version of the string where each word is titlecased.\n |\n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |\n |  translate(self, table, /)\n |      Replace each character in the string using the given translation table.\n |\n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |\n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |\n |  upper(self, /)\n |      Return a copy of the string converted to uppercase.\n |\n |  zfill(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |\n |      The string is never truncated.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.str:\n |\n |  maketrans(x, y=<unrepresentable>, z=<unrepresentable>, /)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: FlagBoundary(*values)",
        "other-params": ""
    },
    "enum.IntEnum": {
        "function": "IntEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "IntEnum",
        "help": "Help on class IntEnum in module enum:\n\nclass IntEnum(builtins.int, ReprEnum)\n |  IntEnum(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Enum where members are also (and must be) ints\n |\n |  Method resolution order:\n |      IntEnum\n |      builtins.int\n |      ReprEnum\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __format__(self, format_spec, /) from builtins.int\n |      Convert to a string according to format_spec.\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __repr__(self) from enum.Enum\n |      Return repr(self).\n |\n |  __str__ = __repr__(self, /) from builtins.int\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.int:\n |\n |  __abs__(self, /)\n |      abs(self)\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __ceil__(self, /)\n |      Ceiling of an Integral returns itself.\n |\n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __float__(self, /)\n |      float(self)\n |\n |  __floor__(self, /)\n |      Flooring an Integral returns itself.\n |\n |  __floordiv__(self, value, /)\n |      Return self//value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |\n |  __int__(self, /)\n |      int(self)\n |\n |  __invert__(self, /)\n |      ~self\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lshift__(self, value, /)\n |      Return self<<value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __neg__(self, /)\n |      -self\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __pos__(self, /)\n |      +self\n |\n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |\n |  __radd__(self, value, /)\n |      Return value+self.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |\n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |\n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __round__(self, ndigits=<unrepresentable>, /)\n |      Rounding an Integral returns itself.\n |\n |      Rounding with an ndigits argument also returns an integer.\n |\n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |\n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |\n |  __rshift__(self, value, /)\n |      Return self>>value.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __truediv__(self, value, /)\n |      Return self/value.\n |\n |  __trunc__(self, /)\n |      Truncating an Integral returns itself.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  as_integer_ratio(self, /)\n |      Return a pair of integers, whose ratio is equal to the original int.\n |\n |      The ratio is in lowest terms and has a positive denominator.\n |\n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |\n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |\n |      Also known as the population count.\n |\n |      >>> bin(13)\n |      '0b1101'\n |      >>> (13).bit_count()\n |      3\n |\n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |\n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |\n |  conjugate(self, /)\n |      Returns self, the complex conjugate of any int.\n |\n |  is_integer(self, /)\n |      Returns True. Exists for duck type compatibility with float.is_integer.\n |\n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |\n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.int:\n |\n |  from_bytes(bytes, byteorder='big', *, signed=False)\n |      Return the integer represented by the given array of bytes.\n |\n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.int:\n |\n |  denominator\n |      the denominator of a rational number in lowest terms\n |\n |  imag\n |      the imaginary part of a complex number\n |\n |  numerator\n |      the numerator of a rational number in lowest terms\n |\n |  real\n |      the real part of a complex number\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from EnumType:\n |\n |  __contains__(value)\n |      Return True if `value` is in `cls`.\n |\n |      `value` is in `cls` if:\n |      1) `value` is a member of `cls`, or\n |      2) `value` is the value of one of the `cls`'s members.\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  __iter__()\n |      Return members in definition order.\n |\n |  __len__()\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: IntEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum.IntFlag": {
        "function": "IntFlag(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "IntFlag",
        "help": "Help on class IntFlag in module enum:\n\nclass IntFlag(builtins.int, ReprEnum, Flag)\n |  IntFlag(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Support for integer-based Flags\n |\n |  Method resolution order:\n |      IntFlag\n |      builtins.int\n |      ReprEnum\n |      Flag\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __and__(self, other) from enum.Flag\n |\n |  __format__(self, format_spec, /) from builtins.int\n |      Convert to a string according to format_spec.\n |\n |  __invert__(self) from enum.Flag\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __or__(self, other) from enum.Flag\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __repr__(self) from enum.Flag\n |      Return repr(self).\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __str__ = __repr__(self, /) from builtins.int\n |      Return repr(self).\n |\n |  __xor__(self, other) from enum.Flag\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.int:\n |\n |  __abs__(self, /)\n |      abs(self)\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __ceil__(self, /)\n |      Ceiling of an Integral returns itself.\n |\n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __float__(self, /)\n |      float(self)\n |\n |  __floor__(self, /)\n |      Flooring an Integral returns itself.\n |\n |  __floordiv__(self, value, /)\n |      Return self//value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |\n |  __int__(self, /)\n |      int(self)\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lshift__(self, value, /)\n |      Return self<<value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __neg__(self, /)\n |      -self\n |\n |  __pos__(self, /)\n |      +self\n |\n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |\n |  __radd__(self, value, /)\n |      Return value+self.\n |\n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |\n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |\n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __round__(self, ndigits=<unrepresentable>, /)\n |      Rounding an Integral returns itself.\n |\n |      Rounding with an ndigits argument also returns an integer.\n |\n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |\n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |\n |  __rshift__(self, value, /)\n |      Return self>>value.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |\n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __truediv__(self, value, /)\n |      Return self/value.\n |\n |  __trunc__(self, /)\n |      Truncating an Integral returns itself.\n |\n |  as_integer_ratio(self, /)\n |      Return a pair of integers, whose ratio is equal to the original int.\n |\n |      The ratio is in lowest terms and has a positive denominator.\n |\n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |\n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |\n |      Also known as the population count.\n |\n |      >>> bin(13)\n |      '0b1101'\n |      >>> (13).bit_count()\n |      3\n |\n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |\n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |\n |  conjugate(self, /)\n |      Returns self, the complex conjugate of any int.\n |\n |  is_integer(self, /)\n |      Returns True. Exists for duck type compatibility with float.is_integer.\n |\n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |\n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.int:\n |\n |  from_bytes(bytes, byteorder='big', *, signed=False)\n |      Return the integer represented by the given array of bytes.\n |\n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.int:\n |\n |  denominator\n |      the denominator of a rational number in lowest terms\n |\n |  imag\n |      the imaginary part of a complex number\n |\n |  numerator\n |      the numerator of a rational number in lowest terms\n |\n |  real\n |      the real part of a complex number\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Flag:\n |\n |  __contains__(self, other)\n |      Returns True if self has at least the same flags set as other.\n |\n |  __iter__(self)\n |      Returns flags in definition order.\n |\n |  __len__(self)\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from EnumType:\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: IntFlag(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum.MappingProxyType": {
        "function": "MappingProxyType(mapping)",
        "alias": "MappingProxyType",
        "help": "Help on class mappingproxy in module builtins:\n\nclass mappingproxy(object)\n |  mappingproxy(mapping)\n |\n |  Read-only proxy of a mapping.\n |\n |  Methods defined here:\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      D.__reversed__() -> reverse iterator\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  copy(self, /)\n |      D.copy() -> a shallow copy of D\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the mapping, else default.\n |\n |  items(self, /)\n |      D.items() -> a set-like object providing a view on D's items\n |\n |  keys(self, /)\n |      D.keys() -> a set-like object providing a view on D's keys\n |\n |  values(self, /)\n |      D.values() -> an object providing a view on D's values\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: MappingProxyType(mapping)",
        "other-params": ""
    },
    "enum.ReprEnum": {
        "function": "ReprEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "ReprEnum",
        "help": "Help on class ReprEnum in module enum:\n\nclass ReprEnum(Enum)\n |  ReprEnum(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Only changes the repr(), leaving str() and format() to the mixed-in type.\n |\n |  Method resolution order:\n |      ReprEnum\n |      Enum\n |      builtins.object\n |\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from EnumType:\n |\n |  __contains__(value)\n |      Return True if `value` is in `cls`.\n |\n |      `value` is in `cls` if:\n |      1) `value` is a member of `cls`, or\n |      2) `value` is the value of one of the `cls`'s members.\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  __iter__()\n |      Return members in definition order.\n |\n |  __len__()\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: ReprEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum.StrEnum": {
        "function": "StrEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "alias": "StrEnum",
        "help": "Help on class StrEnum in module enum:\n\nclass StrEnum(builtins.str, ReprEnum)\n |  StrEnum(\n |      new_class_name,\n |      /,\n |      names,\n |      *,\n |      module=None,\n |      qualname=None,\n |      type=None,\n |      start=1,\n |      boundary=None\n |  )\n |\n |  Enum where members are also (and must be) strings\n |\n |  Method resolution order:\n |      StrEnum\n |      builtins.str\n |      ReprEnum\n |      Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __format__(self, format_spec, /) from builtins.str\n |      Return a formatted version of the string as described by format_spec.\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __repr__(self) from enum.Enum\n |      Return repr(self).\n |\n |  __str__(self, /) from builtins.str\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.str:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the string in memory, in bytes.\n |\n |  capitalize(self, /)\n |      Return a capitalized version of the string.\n |\n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |\n |  casefold(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |\n |  center(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  count(self, sub[, start[, end]], /)\n |      Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |\n |  encode(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |\n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |\n |  endswith(self, suffix[, start[, end]], /)\n |      Return True if the string ends with the specified suffix, False otherwise.\n |\n |      suffix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  expandtabs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |\n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |\n |  find(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  format(self, /, *args, **kwargs)\n |      Return a formatted version of the string, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  format_map(self, mapping, /)\n |      Return a formatted version of the string, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  index(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  isalnum(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |\n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |\n |  isalpha(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |\n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |\n |  isascii(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |\n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |\n |  isdecimal(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |\n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |\n |  isdigit(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |\n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |\n |  isidentifier(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |\n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |\n |  islower(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |\n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |\n |  isnumeric(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |\n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |\n |  isprintable(self, /)\n |      Return True if the string is printable, False otherwise.\n |\n |      A string is printable if all of its characters are considered printable in\n |      repr() or if it is empty.\n |\n |  isspace(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |\n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |\n |  istitle(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |\n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |\n |  isupper(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |\n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |\n |  join(self, iterable, /)\n |      Concatenate any number of strings.\n |\n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |\n |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n |\n |  ljust(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  lower(self, /)\n |      Return a copy of the string converted to lowercase.\n |\n |  lstrip(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  partition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |\n |  removeprefix(self, prefix, /)\n |      Return a str with the given prefix string removed if present.\n |\n |      If the string starts with the prefix string, return string[len(prefix):].\n |      Otherwise, return a copy of the original string.\n |\n |  removesuffix(self, suffix, /)\n |      Return a str with the given suffix string removed if present.\n |\n |      If the string ends with the suffix string and that suffix is not empty,\n |      return string[:-len(suffix)]. Otherwise, return a copy of the original\n |      string.\n |\n |  replace(self, old, new, /, count=-1)\n |      Return a copy with all occurrences of substring old replaced by new.\n |\n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |\n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |\n |  rfind(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  rindex(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  rjust(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  rpartition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |\n |  rsplit(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the end of the string and works to the front.\n |\n |  rstrip(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  split(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the front of the string and works to the end.\n |\n |      Note, str.split() is mainly useful for data that has been intentionally\n |      delimited.  With natural text that includes punctuation, consider using\n |      the regular expression module.\n |\n |  splitlines(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |\n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |\n |  startswith(self, prefix[, start[, end]], /)\n |      Return True if the string starts with the specified prefix, False otherwise.\n |\n |      prefix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  strip(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  swapcase(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |\n |  title(self, /)\n |      Return a version of the string where each word is titlecased.\n |\n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |\n |  translate(self, table, /)\n |      Replace each character in the string using the given translation table.\n |\n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |\n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |\n |  upper(self, /)\n |      Return a copy of the string converted to uppercase.\n |\n |  zfill(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |\n |      The string is never truncated.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.str:\n |\n |  maketrans(x, y=<unrepresentable>, z=<unrepresentable>, /)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: StrEnum(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
        "other-params": ""
    },
    "enum._EnumDict": {
        "function": "_EnumDict()",
        "alias": "_EnumDict",
        "help": "Help on class EnumDict in module enum:\n\nclass EnumDict(builtins.dict)\n |  Track enum member order and ensure member names are not reused.\n |\n |  EnumType will use the names found in self._member_names as the\n |  enumeration member names.\n |\n |  Method resolution order:\n |      EnumDict\n |      builtins.dict\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __setitem__(self, key, value)\n |      Changes anything not dundered or not a descriptor.\n |\n |      If an enum member name is used twice, an error is raised; duplicate\n |      values are not checked for.\n |\n |      Single underscore (sunder) names are reserved.\n |\n |  update(self, members, **more_members)\n |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  member_names\n |\n |  member_names\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |\n |  __contains__(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |\n |  __delitem__(self, key, /)\n |      Delete self[key].\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __ior__(self, value, /)\n |      Return self|=value.\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __reversed__(self, /)\n |      Return a reverse iterator over the dict keys.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the dict in memory, in bytes.\n |\n |  clear(self, /)\n |      Remove all items from the dict.\n |\n |  copy(self, /)\n |      Return a shallow copy of the dict.\n |\n |  get(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  items(self, /)\n |      Return a set-like object providing a view on the dict's items.\n |\n |  keys(self, /)\n |      Return a set-like object providing a view on the dict's keys.\n |\n |  pop(self, key, default=<unrepresentable>, /)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |\n |      If the key is not found, return the default if given; otherwise,\n |      raise a KeyError.\n |\n |  popitem(self, /)\n |      Remove and return a (key, value) pair as a 2-tuple.\n |\n |      Pairs are returned in LIFO (last-in, first-out) order.\n |      Raises KeyError if the dict is empty.\n |\n |  setdefault(self, key, default=None, /)\n |      Insert key with a value of default if key is not in the dictionary.\n |\n |      Return the value for key if key is in the dictionary, else default.\n |\n |  values(self, /)\n |      Return an object providing a view on the dict's values.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.dict:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  fromkeys(iterable, value=None, /)\n |      Create a new dictionary with keys from iterable and values set to value.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |\n |  __new__(*args, **kwargs) class method of builtins.dict\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from builtins.dict:\n |\n |  __hash__ = None",
        "syntax": "Syntax: _EnumDict()",
        "other-params": ""
    },
    "enum._dataclass_repr": {
        "function": "_dataclass_repr(self)",
        "alias": "_dataclass_repr",
        "help": "Help on function _dataclass_repr in module enum:\n\n_dataclass_repr(self)",
        "syntax": "Syntax: _dataclass_repr(self)",
        "other-params": ""
    },
    "enum._dedent": {
        "function": "_dedent(text)",
        "alias": "_dedent",
        "help": "Help on function _dedent in module enum:\n\n_dedent(text)\n    Like textwrap.dedent.  Rewritten because we cannot import textwrap.",
        "syntax": "Syntax: _dedent(text)",
        "other-params": ""
    },
    "enum._high_bit": {
        "function": "_high_bit(value)",
        "alias": "_high_bit",
        "help": "Help on function _high_bit in module enum:\n\n_high_bit(value)\n    returns index of highest bit, or -1 if value is zero or negative",
        "syntax": "Syntax: _high_bit(value)",
        "other-params": ""
    },
    "enum._is_descriptor": {
        "function": "_is_descriptor(obj)",
        "alias": "_is_descriptor",
        "help": "Help on function _is_descriptor in module enum:\n\n_is_descriptor(obj)\n    Returns True if obj is a descriptor, False otherwise.",
        "syntax": "Syntax: _is_descriptor(obj)",
        "other-params": ""
    },
    "enum._is_dunder": {
        "function": "_is_dunder(name)",
        "alias": "_is_dunder",
        "help": "Help on function _is_dunder in module enum:\n\n_is_dunder(name)\n    Returns True if a __dunder__ name, False otherwise.",
        "syntax": "Syntax: _is_dunder(name)",
        "other-params": ""
    },
    "enum._is_internal_class": {
        "function": "_is_internal_class(cls_name, obj)",
        "alias": "_is_internal_class",
        "help": "Help on function _is_internal_class in module enum:\n\n_is_internal_class(cls_name, obj)",
        "syntax": "Syntax: _is_internal_class(cls_name, obj)",
        "other-params": ""
    },
    "enum._is_private": {
        "function": "_is_private(cls_name, name)",
        "alias": "_is_private",
        "help": "Help on function _is_private in module enum:\n\n_is_private(cls_name, name)",
        "syntax": "Syntax: _is_private(cls_name, name)",
        "other-params": ""
    },
    "enum._is_single_bit": {
        "function": "_is_single_bit(num)",
        "alias": "_is_single_bit",
        "help": "Help on function _is_single_bit in module enum:\n\n_is_single_bit(num)\n    True if only one bit set in num (should be an int)",
        "syntax": "Syntax: _is_single_bit(num)",
        "other-params": ""
    },
    "enum._is_sunder": {
        "function": "_is_sunder(name)",
        "alias": "_is_sunder",
        "help": "Help on function _is_sunder in module enum:\n\n_is_sunder(name)\n    Returns True if a _sunder_ name, False otherwise.",
        "syntax": "Syntax: _is_sunder(name)",
        "other-params": ""
    },
    "enum._iter_bits_lsb": {
        "function": "_iter_bits_lsb(num)",
        "alias": "_iter_bits_lsb",
        "help": "Help on function _iter_bits_lsb in module enum:\n\n_iter_bits_lsb(num)",
        "syntax": "Syntax: _iter_bits_lsb(num)",
        "other-params": ""
    },
    "enum._make_class_unpicklable": {
        "function": "_make_class_unpicklable(obj)",
        "alias": "_make_class_unpicklable",
        "help": "Help on function _make_class_unpicklable in module enum:\n\n_make_class_unpicklable(obj)\n    Make the given obj un-picklable.\n\n    obj should be either a dictionary, or an Enum",
        "syntax": "Syntax: _make_class_unpicklable(obj)",
        "other-params": ""
    },
    "enum._old_convert_": {
        "function": "_old_convert_(etype, name, module, filter, source=None, *, boundary=None)",
        "alias": "_old_convert_",
        "help": "Help on function _old_convert_ in module enum:\n\n_old_convert_(etype, name, module, filter, source=None, *, boundary=None)\n    Create a new Enum subclass that replaces a collection of global constants",
        "syntax": "Syntax: _old_convert_(etype, name, module, filter, source=None, *, boundary=None)",
        "other-params": ""
    },
    "enum._proto_member": {
        "function": "_proto_member(value)",
        "alias": "_proto_member",
        "help": "Help on class _proto_member in module enum:\n\nclass _proto_member(builtins.object)\n |  _proto_member(value)\n |\n |  intermediate step for enum members between class execution and final creation\n |\n |  Methods defined here:\n |\n |  __init__(self, value)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __set_name__(self, enum_class, member_name)\n |      convert each quasi-member into an instance of the new enum class\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _proto_member(value)",
        "other-params": ""
    },
    "enum._reduce_ex_by_global_name": {
        "function": "_reduce_ex_by_global_name(self, proto)",
        "alias": "_reduce_ex_by_global_name",
        "help": "Help on function pickle_by_global_name in module enum:\n\npickle_by_global_name(self, proto)",
        "syntax": "Syntax: _reduce_ex_by_global_name(self, proto)",
        "other-params": ""
    },
    "enum._simple_enum": {
        "function": "_simple_enum(etype=<enum 'Enum'>, *, boundary=None, use_args=None)",
        "alias": "_simple_enum",
        "help": "Help on function _simple_enum in module enum:\n\n_simple_enum(etype=<enum 'Enum'>, *, boundary=None, use_args=None)\n    Class decorator that converts a normal class into an :class:`Enum`.  No\n    safety checks are done, and some advanced behavior (such as\n    :func:`__init_subclass__`) is not available.  Enum creation can be faster\n    using :func:`_simple_enum`.\n\n        >>> from enum import Enum, _simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> Color\n        <enum 'Color'>",
        "syntax": "Syntax: _simple_enum(etype=<enum 'Enum'>, *, boundary=None, use_args=None)",
        "other-params": ""
    },
    "enum._test_simple_enum": {
        "function": "_test_simple_enum(checked_enum, simple_enum)",
        "alias": "_test_simple_enum",
        "help": "Help on function _test_simple_enum in module enum:\n\n_test_simple_enum(checked_enum, simple_enum)\n    A function that can be used to test an enum created with :func:`_simple_enum`\n    against the version created by subclassing :class:`Enum`::\n\n        >>> from enum import Enum, _simple_enum, _test_simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> class CheckedColor(Enum):\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> _test_simple_enum(CheckedColor, Color)\n\n    If differences are found, a :exc:`TypeError` is raised.",
        "syntax": "Syntax: _test_simple_enum(checked_enum, simple_enum)",
        "other-params": ""
    },
    "enum.auto": {
        "function": "auto(value=_auto_null)",
        "alias": "auto",
        "help": "Help on class auto in module enum:\n\nclass auto(builtins.object)\n |  auto(value=_auto_null)\n |\n |  Instances are replaced with an appropriate value in Enum class suites.\n |\n |  Methods defined here:\n |\n |  __init__(self, value=_auto_null)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: auto(value=_auto_null)",
        "other-params": ""
    },
    "enum.bin": {
        "function": "bin(num, max_bits=None)",
        "alias": "bin",
        "help": "Help on function bin in module enum:\n\nbin(num, max_bits=None)\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'",
        "syntax": "Syntax: bin(num, max_bits=None)",
        "other-params": ""
    },
    "enum.global_enum": {
        "function": "global_enum(cls, update_str=False)",
        "alias": "global_enum",
        "help": "Help on function global_enum in module enum:\n\nglobal_enum(cls, update_str=False)\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace",
        "syntax": "Syntax: global_enum(cls, update_str=False)",
        "other-params": ""
    },
    "enum.global_enum_repr": {
        "function": "global_enum_repr(self)",
        "alias": "global_enum_repr",
        "help": "Help on function global_enum_repr in module enum:\n\nglobal_enum_repr(self)\n    use module.enum_name instead of class.enum_name\n\n    the module is the last module in case of a multi-module name",
        "syntax": "Syntax: global_enum_repr(self)",
        "other-params": ""
    },
    "enum.global_flag_repr": {
        "function": "global_flag_repr(self)",
        "alias": "global_flag_repr",
        "help": "Help on function global_flag_repr in module enum:\n\nglobal_flag_repr(self)\n    use module.flag_name instead of class.flag_name\n\n    the module is the last module in case of a multi-module name",
        "syntax": "Syntax: global_flag_repr(self)",
        "other-params": ""
    },
    "enum.global_str": {
        "function": "global_str(self)",
        "alias": "global_str",
        "help": "Help on function global_str in module enum:\n\nglobal_str(self)\n    use enum_name instead of class.enum_name",
        "syntax": "Syntax: global_str(self)",
        "other-params": ""
    },
    "enum.member": {
        "function": "member(value)",
        "alias": "member",
        "help": "Help on class member in module enum:\n\nclass member(builtins.object)\n |  member(value)\n |\n |  Forces item to become an Enum member during class creation.\n |\n |  Methods defined here:\n |\n |  __init__(self, value)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: member(value)",
        "other-params": ""
    },
    "enum.nonmember": {
        "function": "nonmember(value)",
        "alias": "nonmember",
        "help": "Help on class nonmember in module enum:\n\nclass nonmember(builtins.object)\n |  nonmember(value)\n |\n |  Protects item from becoming an Enum member during class creation.\n |\n |  Methods defined here:\n |\n |  __init__(self, value)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: nonmember(value)",
        "other-params": ""
    },
    "enum.partial": {
        "function": "partial(func, /, *args, **keywords)",
        "alias": "partial",
        "help": "Help on class partial in module functools:\n\nclass partial(builtins.object)\n |  partial(func, /, *args, **keywords)\n |\n |  Create a new function with partial application of the given arguments\n |  and keywords.\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __delattr__(self, name, /)\n |      Implement delattr(self, name).\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setattr__(self, name, value, /)\n |      Implement setattr(self, name, value).\n |\n |  __setstate__(self, object, /)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |\n |  __vectorcalloffset__\n |\n |  args\n |      tuple of arguments to future partial calls\n |\n |  func\n |      function object to use in future partial calls\n |\n |  keywords\n |      dictionary of keyword arguments to future partial calls",
        "syntax": "Syntax: partial(func, /, *args, **keywords)",
        "other-params": ""
    },
    "enum.pickle_by_enum_name": {
        "function": "pickle_by_enum_name(self, proto)",
        "alias": "pickle_by_enum_name",
        "help": "Help on function pickle_by_enum_name in module enum:\n\npickle_by_enum_name(self, proto)",
        "syntax": "Syntax: pickle_by_enum_name(self, proto)",
        "other-params": ""
    },
    "enum.pickle_by_global_name": {
        "function": "pickle_by_global_name(self, proto)",
        "alias": "pickle_by_global_name",
        "help": "Help on function pickle_by_global_name in module enum:\n\npickle_by_global_name(self, proto)",
        "syntax": "Syntax: pickle_by_global_name(self, proto)",
        "other-params": ""
    },
    "enum.property": {
        "function": "property(fget=None, fset=None, fdel=None, doc=None)",
        "alias": "property",
        "help": "Help on class property in module enum:\n\nclass property(types.DynamicClassAttribute)\n |  property(fget=None, fset=None, fdel=None, doc=None)\n |\n |  This is a descriptor, used to define attributes that act differently\n |  when accessed through an enum member and through an enum class.\n |  Instance access is the same as property(), but access to an attribute\n |  through the enum class will instead look in the class' _member_map_ for\n |  a corresponding enum member.\n |\n |  Method resolution order:\n |      property\n |      types.DynamicClassAttribute\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __delete__(self, instance)\n |\n |  __get__(self, instance, ownerclass=None)\n |\n |  __set__(self, instance, value)\n |\n |  __set_name__(self, ownerclass, name)\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  member = None\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from types.DynamicClassAttribute:\n |\n |  __init__(self, fget=None, fset=None, fdel=None, doc=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  deleter(self, fdel)\n |\n |  getter(self, fget)\n |\n |  setter(self, fset)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from types.DynamicClassAttribute:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: property(fget=None, fset=None, fdel=None, doc=None)",
        "other-params": ""
    },
    "enum.show_flag_values": {
        "function": "show_flag_values(value)",
        "alias": "show_flag_values",
        "help": "Help on function show_flag_values in module enum:\n\nshow_flag_values(value)",
        "syntax": "Syntax: show_flag_values(value)",
        "other-params": ""
    },
    "enum.unique": {
        "function": "unique(enumeration)",
        "alias": "unique",
        "help": "Help on function unique in module enum:\n\nunique(enumeration)\n    Class decorator for enumerations ensuring unique member values.",
        "syntax": "Syntax: unique(enumeration)",
        "other-params": ""
    },
    "enum.verify": {
        "function": "verify(*checks)",
        "alias": "verify",
        "help": "Help on class verify in module enum:\n\nclass verify(builtins.object)\n |  verify(*checks)\n |\n |  Check an enumeration for various constraints. (see EnumCheck)\n |\n |  Methods defined here:\n |\n |  __call__(self, enumeration)\n |      Call self as a function.\n |\n |  __init__(self, *checks)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: verify(*checks)",
        "other-params": ""
    },
    "re._constants.PatternError": {
        "function": "PatternError(msg, pattern=None, pos=None)",
        "alias": "PatternError",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: PatternError(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._constants._NamedIntConstant": {
        "function": "_NamedIntConstant(value, name)",
        "alias": "_NamedIntConstant",
        "help": "Help on class _NamedIntConstant in module re._constants:\n\nclass _NamedIntConstant(builtins.int)\n |  _NamedIntConstant(value, name)\n |\n |  Method resolution order:\n |      _NamedIntConstant\n |      builtins.int\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, value, name)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __reduce__ = None\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.int:\n |\n |  __abs__(self, /)\n |      abs(self)\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __ceil__(self, /)\n |      Ceiling of an Integral returns itself.\n |\n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __float__(self, /)\n |      float(self)\n |\n |  __floor__(self, /)\n |      Flooring an Integral returns itself.\n |\n |  __floordiv__(self, value, /)\n |      Return self//value.\n |\n |  __format__(self, format_spec, /)\n |      Convert to a string according to format_spec.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |\n |  __int__(self, /)\n |      int(self)\n |\n |  __invert__(self, /)\n |      ~self\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lshift__(self, value, /)\n |      Return self<<value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __neg__(self, /)\n |      -self\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __pos__(self, /)\n |      +self\n |\n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |\n |  __radd__(self, value, /)\n |      Return value+self.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |\n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |\n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __round__(self, ndigits=<unrepresentable>, /)\n |      Rounding an Integral returns itself.\n |\n |      Rounding with an ndigits argument also returns an integer.\n |\n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |\n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |\n |  __rshift__(self, value, /)\n |      Return self>>value.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __truediv__(self, value, /)\n |      Return self/value.\n |\n |  __trunc__(self, /)\n |      Truncating an Integral returns itself.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  as_integer_ratio(self, /)\n |      Return a pair of integers, whose ratio is equal to the original int.\n |\n |      The ratio is in lowest terms and has a positive denominator.\n |\n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |\n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |\n |      Also known as the population count.\n |\n |      >>> bin(13)\n |      '0b1101'\n |      >>> (13).bit_count()\n |      3\n |\n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |\n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |\n |  conjugate(self, /)\n |      Returns self, the complex conjugate of any int.\n |\n |  is_integer(self, /)\n |      Returns True. Exists for duck type compatibility with float.is_integer.\n |\n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |\n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.int:\n |\n |  from_bytes(bytes, byteorder='big', *, signed=False)\n |      Return the integer represented by the given array of bytes.\n |\n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.int:\n |\n |  denominator\n |      the denominator of a rational number in lowest terms\n |\n |  imag\n |      the imaginary part of a complex number\n |\n |  numerator\n |      the numerator of a rational number in lowest terms\n |\n |  real\n |      the real part of a complex number",
        "syntax": "Syntax: _NamedIntConstant(value, name)",
        "other-params": ""
    },
    "re._constants._makecodes": {
        "function": "_makecodes(*names)",
        "alias": "_makecodes",
        "help": "Help on function _makecodes in module re._constants:\n\n_makecodes(*names)",
        "syntax": "Syntax: _makecodes(*names)",
        "other-params": ""
    },
    "re._constants.error": {
        "function": "error(msg, pattern=None, pos=None)",
        "alias": "error",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: error(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._parser.PatternError": {
        "function": "PatternError(msg, pattern=None, pos=None)",
        "alias": "PatternError",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: PatternError(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._parser.State": {
        "function": "State()",
        "alias": "State",
        "help": "Help on class State in module re._parser:\n\nclass State(builtins.object)\n |  Methods defined here:\n |\n |  __init__(self)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  checkgroup(self, gid)\n |\n |  checklookbehindgroup(self, gid, source)\n |\n |  closegroup(self, gid, p)\n |\n |  opengroup(self, name=None)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  groups\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: State()",
        "other-params": ""
    },
    "re._parser.SubPattern": {
        "function": "SubPattern(state, data=None)",
        "alias": "SubPattern",
        "help": "Help on class SubPattern in module re._parser:\n\nclass SubPattern(builtins.object)\n |  SubPattern(state, data=None)\n |\n |  Methods defined here:\n |\n |  __delitem__(self, index)\n |\n |  __getitem__(self, index)\n |\n |  __init__(self, state, data=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __setitem__(self, index, code)\n |\n |  append(self, code)\n |\n |  dump(self, level=0)\n |\n |  getwidth(self)\n |\n |  insert(self, index, code)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: SubPattern(state, data=None)",
        "other-params": ""
    },
    "re._parser.Tokenizer": {
        "function": "Tokenizer(string)",
        "alias": "Tokenizer",
        "help": "Help on class Tokenizer in module re._parser:\n\nclass Tokenizer(builtins.object)\n |  Tokenizer(string)\n |\n |  Methods defined here:\n |\n |  __init__(self, string)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  checkgroupname(self, name, offset)\n |\n |  error(self, msg, offset=0)\n |\n |  get(self)\n |\n |  getuntil(self, terminator, name)\n |\n |  getwhile(self, n, charset)\n |\n |  match(self, char)\n |\n |  seek(self, index)\n |\n |  tell(self)\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  pos\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Tokenizer(string)",
        "other-params": ""
    },
    "re._parser._class_escape": {
        "function": "_class_escape(source, escape)",
        "alias": "_class_escape",
        "help": "Help on function _class_escape in module re._parser:\n\n_class_escape(source, escape)",
        "syntax": "Syntax: _class_escape(source, escape)",
        "other-params": ""
    },
    "re._parser._escape": {
        "function": "_escape(source, escape, state)",
        "alias": "_escape",
        "help": "Help on function _escape in module re._parser:\n\n_escape(source, escape, state)",
        "syntax": "Syntax: _escape(source, escape, state)",
        "other-params": ""
    },
    "re._parser._parse": {
        "function": "_parse(source, state, verbose, nested, first=False)",
        "alias": "_parse",
        "help": "Help on function _parse in module re._parser:\n\n_parse(source, state, verbose, nested, first=False)",
        "syntax": "Syntax: _parse(source, state, verbose, nested, first=False)",
        "other-params": ""
    },
    "re._parser._parse_flags": {
        "function": "_parse_flags(source, state, char)",
        "alias": "_parse_flags",
        "help": "Help on function _parse_flags in module re._parser:\n\n_parse_flags(source, state, char)",
        "syntax": "Syntax: _parse_flags(source, state, char)",
        "other-params": ""
    },
    "re._parser._parse_sub": {
        "function": "_parse_sub(source, state, verbose, nested)",
        "alias": "_parse_sub",
        "help": "Help on function _parse_sub in module re._parser:\n\n_parse_sub(source, state, verbose, nested)",
        "syntax": "Syntax: _parse_sub(source, state, verbose, nested)",
        "other-params": ""
    },
    "re._parser._uniq": {
        "function": "_uniq(items)",
        "alias": "_uniq",
        "help": "Help on function _uniq in module re._parser:\n\n_uniq(items)",
        "syntax": "Syntax: _uniq(items)",
        "other-params": ""
    },
    "re._parser.error": {
        "function": "error(msg, pattern=None, pos=None)",
        "alias": "error",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: error(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._parser.fix_flags": {
        "function": "fix_flags(src, flags)",
        "alias": "fix_flags",
        "help": "Help on function fix_flags in module re._parser:\n\nfix_flags(src, flags)",
        "syntax": "Syntax: fix_flags(src, flags)",
        "other-params": ""
    },
    "re._parser.parse": {
        "function": "parse(str, flags=0, state=None)",
        "alias": "parse",
        "help": "Help on function parse in module re._parser:\n\nparse(str, flags=0, state=None)",
        "syntax": "Syntax: parse(str, flags=0, state=None)",
        "other-params": ""
    },
    "re._parser.parse_template": {
        "function": "parse_template(source, pattern)",
        "alias": "parse_template",
        "help": "Help on function parse_template in module re._parser:\n\nparse_template(source, pattern)",
        "syntax": "Syntax: parse_template(source, pattern)",
        "other-params": ""
    },
    "re._compiler.PatternError": {
        "function": "PatternError(msg, pattern=None, pos=None)",
        "alias": "PatternError",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: PatternError(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._compiler._bytes_to_codes": {
        "function": "_bytes_to_codes(b)",
        "alias": "_bytes_to_codes",
        "help": "Help on function _bytes_to_codes in module re._compiler:\n\n_bytes_to_codes(b)",
        "syntax": "Syntax: _bytes_to_codes(b)",
        "other-params": ""
    },
    "re._compiler._code": {
        "function": "_code(p, flags)",
        "alias": "_code",
        "help": "Help on function _code in module re._compiler:\n\n_code(p, flags)",
        "syntax": "Syntax: _code(p, flags)",
        "other-params": ""
    },
    "re._compiler._combine_flags": {
        "function": "_combine_flags(flags, add_flags, del_flags, TYPE_FLAGS=292)",
        "alias": "_combine_flags",
        "help": "Help on function _combine_flags in module re._compiler:\n\n_combine_flags(flags, add_flags, del_flags, TYPE_FLAGS=292)",
        "syntax": "Syntax: _combine_flags(flags, add_flags, del_flags, TYPE_FLAGS=292)",
        "other-params": ""
    },
    "re._compiler._compile": {
        "function": "_compile(code, pattern, flags)",
        "alias": "_compile",
        "help": "Help on function _compile in module re._compiler:\n\n_compile(code, pattern, flags)",
        "syntax": "Syntax: _compile(code, pattern, flags)",
        "other-params": ""
    },
    "re._compiler._compile_charset": {
        "function": "_compile_charset(charset, flags, code)",
        "alias": "_compile_charset",
        "help": "Help on function _compile_charset in module re._compiler:\n\n_compile_charset(charset, flags, code)",
        "syntax": "Syntax: _compile_charset(charset, flags, code)",
        "other-params": ""
    },
    "re._compiler._compile_info": {
        "function": "_compile_info(code, pattern, flags)",
        "alias": "_compile_info",
        "help": "Help on function _compile_info in module re._compiler:\n\n_compile_info(code, pattern, flags)",
        "syntax": "Syntax: _compile_info(code, pattern, flags)",
        "other-params": ""
    },
    "re._compiler._generate_overlap_table": {
        "function": "_generate_overlap_table(prefix)",
        "alias": "_generate_overlap_table",
        "help": "Help on function _generate_overlap_table in module re._compiler:\n\n_generate_overlap_table(prefix)\n    Generate an overlap table for the following prefix.\n    An overlap table is a table of the same size as the prefix which\n    informs about the potential self-overlap for each index in the prefix:\n    - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]\n    - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with\n      prefix[0:k]",
        "syntax": "Syntax: _generate_overlap_table(prefix)",
        "other-params": ""
    },
    "re._compiler._get_charset_prefix": {
        "function": "_get_charset_prefix(pattern, flags)",
        "alias": "_get_charset_prefix",
        "help": "Help on function _get_charset_prefix in module re._compiler:\n\n_get_charset_prefix(pattern, flags)",
        "syntax": "Syntax: _get_charset_prefix(pattern, flags)",
        "other-params": ""
    },
    "re._compiler._get_iscased": {
        "function": "_get_iscased(flags)",
        "alias": "_get_iscased",
        "help": "Help on function _get_iscased in module re._compiler:\n\n_get_iscased(flags)",
        "syntax": "Syntax: _get_iscased(flags)",
        "other-params": ""
    },
    "re._compiler._get_literal_prefix": {
        "function": "_get_literal_prefix(pattern, flags)",
        "alias": "_get_literal_prefix",
        "help": "Help on function _get_literal_prefix in module re._compiler:\n\n_get_literal_prefix(pattern, flags)",
        "syntax": "Syntax: _get_literal_prefix(pattern, flags)",
        "other-params": ""
    },
    "re._compiler._hex_code": {
        "function": "_hex_code(code)",
        "alias": "_hex_code",
        "help": "Help on function _hex_code in module re._compiler:\n\n_hex_code(code)",
        "syntax": "Syntax: _hex_code(code)",
        "other-params": ""
    },
    "re._compiler._mk_bitmap": {
        "function": "_mk_bitmap(bits, _CODEBITS=32, _int=<class 'int'>)",
        "alias": "_mk_bitmap",
        "help": "Help on function _mk_bitmap in module re._compiler:\n\n_mk_bitmap(bits, _CODEBITS=32, _int=<class 'int'>)",
        "syntax": "Syntax: _mk_bitmap(bits, _CODEBITS=32, _int=<class 'int'>)",
        "other-params": ""
    },
    "re._compiler._optimize_charset": {
        "function": "_optimize_charset(charset, iscased=None, fixup=None, fixes=None)",
        "alias": "_optimize_charset",
        "help": "Help on function _optimize_charset in module re._compiler:\n\n_optimize_charset(charset, iscased=None, fixup=None, fixes=None)",
        "syntax": "Syntax: _optimize_charset(charset, iscased=None, fixup=None, fixes=None)",
        "other-params": ""
    },
    "re._compiler._simple": {
        "function": "_simple(p)",
        "alias": "_simple",
        "help": "Help on function _simple in module re._compiler:\n\n_simple(p)",
        "syntax": "Syntax: _simple(p)",
        "other-params": ""
    },
    "re._compiler.compile": {
        "function": "compile(p, flags=0)",
        "alias": "compile",
        "help": "Help on function compile in module re._compiler:\n\ncompile(p, flags=0)",
        "syntax": "Syntax: compile(p, flags=0)",
        "other-params": ""
    },
    "re._compiler.dis": {
        "function": "dis(code)",
        "alias": "dis",
        "help": "Help on function dis in module re._compiler:\n\ndis(code)",
        "syntax": "Syntax: dis(code)",
        "other-params": ""
    },
    "re._compiler.error": {
        "function": "error(msg, pattern=None, pos=None)",
        "alias": "error",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: error(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re._compiler.isstring": {
        "function": "isstring(obj)",
        "alias": "isstring",
        "help": "Help on function isstring in module re._compiler:\n\nisstring(obj)",
        "syntax": "Syntax: isstring(obj)",
        "other-params": ""
    },
    "copyreg._new_type": {
        "function": "_new_type()",
        "alias": "_new_type",
        "help": "Help on class builtin_function_or_method in module builtins:\n\nclass builtin_function_or_method(object)\n |  Built-in subclasses:\n |      builtin_method\n |\n |  Methods defined here:\n |\n |  __call__(self, /, *args, **kwargs)\n |      Call self as a function.\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __self__\n |\n |  __text_signature__",
        "syntax": "Syntax: _new_type()",
        "other-params": ""
    },
    "copyreg._reconstructor": {
        "function": "_reconstructor(cls, base, state)",
        "alias": "_reconstructor",
        "help": "Help on function _reconstructor in module copyreg:\n\n_reconstructor(cls, base, state)",
        "syntax": "Syntax: _reconstructor(cls, base, state)",
        "other-params": ""
    },
    "copyreg._reduce_ex": {
        "function": "_reduce_ex(self, proto)",
        "alias": "_reduce_ex",
        "help": "Help on function _reduce_ex in module copyreg:\n\n_reduce_ex(self, proto)",
        "syntax": "Syntax: _reduce_ex(self, proto)",
        "other-params": ""
    },
    "copyreg._slotnames": {
        "function": "_slotnames(cls)",
        "alias": "_slotnames",
        "help": "Help on function _slotnames in module copyreg:\n\n_slotnames(cls)\n    Return a list of slot names for a given class.\n\n    This needs to find slots defined by the class and its bases, so we\n    can't simply return the __slots__ attribute.  We must walk down\n    the Method Resolution Order and concatenate the __slots__ of each\n    class found there.  (This assumes classes don't modify their\n    __slots__ attribute to misrepresent their slots after the class is\n    defined.)",
        "syntax": "Syntax: _slotnames(cls)",
        "other-params": ""
    },
    "copyreg.add_extension": {
        "function": "add_extension(module, name, code)",
        "alias": "add_extension",
        "help": "Help on function add_extension in module copyreg:\n\nadd_extension(module, name, code)\n    Register an extension code.",
        "syntax": "Syntax: add_extension(module, name, code)",
        "other-params": ""
    },
    "copyreg.clear_extension_cache": {
        "function": "clear_extension_cache()",
        "alias": "clear_extension_cache",
        "help": "Help on function clear_extension_cache in module copyreg:\n\nclear_extension_cache()",
        "syntax": "Syntax: clear_extension_cache()",
        "other-params": ""
    },
    "copyreg.constructor": {
        "function": "constructor(object)",
        "alias": "constructor",
        "help": "Help on function constructor in module copyreg:\n\nconstructor(object)",
        "syntax": "Syntax: constructor(object)",
        "other-params": ""
    },
    "copyreg.pickle": {
        "function": "pickle(ob_type, pickle_function, constructor_ob=None)",
        "alias": "pickle",
        "help": "Help on function pickle in module copyreg:\n\npickle(ob_type, pickle_function, constructor_ob=None)",
        "syntax": "Syntax: pickle(ob_type, pickle_function, constructor_ob=None)",
        "other-params": ""
    },
    "copyreg.pickle_complex": {
        "function": "pickle_complex(c)",
        "alias": "pickle_complex",
        "help": "Help on function pickle_complex in module copyreg:\n\npickle_complex(c)",
        "syntax": "Syntax: pickle_complex(c)",
        "other-params": ""
    },
    "copyreg.pickle_union": {
        "function": "pickle_union(obj)",
        "alias": "pickle_union",
        "help": "Help on function pickle_union in module copyreg:\n\npickle_union(obj)",
        "syntax": "Syntax: pickle_union(obj)",
        "other-params": ""
    },
    "copyreg.remove_extension": {
        "function": "remove_extension(module, name, code)",
        "alias": "remove_extension",
        "help": "Help on function remove_extension in module copyreg:\n\nremove_extension(module, name, code)\n    Unregister an extension code.  For testing only.",
        "syntax": "Syntax: remove_extension(module, name, code)",
        "other-params": ""
    },
    "re.Match": {
        "function": "Match()",
        "alias": "Match",
        "help": "Help on class Match in module re:\n\nclass Match(builtins.object)\n |  The result of re.match() and re.search().\n |  Match objects always have a boolean value of True.\n |\n |  Methods defined here:\n |\n |  __copy__(self, /)\n |\n |  __deepcopy__(self, memo, /)\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  end(self, group=0, /)\n |      Return index of the end of the substring matched by group.\n |\n |  expand(self, /, template)\n |      Return the string obtained by doing backslash substitution on the string template, as done by the sub() method.\n |\n |  group(...)\n |      group([group1, ...]) -> str or tuple.\n |      Return subgroup(s) of the match by indices or names.\n |      For 0 returns the entire match.\n |\n |  groupdict(self, /, default=None)\n |      Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n |\n |      default\n |        Is used for groups that did not participate in the match.\n |\n |  groups(self, /, default=None)\n |      Return a tuple containing all the subgroups of the match, from 1.\n |\n |      default\n |        Is used for groups that did not participate in the match.\n |\n |  span(self, group=0, /)\n |      For match object m, return the 2-tuple (m.start(group), m.end(group)).\n |\n |  start(self, group=0, /)\n |      Return index of the start of the substring matched by group.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  endpos\n |      The index into the string beyond which the RE engine will not go.\n |\n |  lastgroup\n |      The name of the last matched capturing group.\n |\n |  lastindex\n |      The integer index of the last matched capturing group.\n |\n |  pos\n |      The index into the string at which the RE engine started looking for a match.\n |\n |  re\n |      The regular expression object.\n |\n |  regs\n |\n |  string\n |      The string passed to match() or search().",
        "syntax": "Syntax: Match()",
        "other-params": ""
    },
    "re.Pattern": {
        "function": "Pattern()",
        "alias": "Pattern",
        "help": "Help on class Pattern in module re:\n\nclass Pattern(builtins.object)\n |  Compiled regular expression object.\n |\n |  Methods defined here:\n |\n |  __copy__(self, /)\n |\n |  __deepcopy__(self, memo, /)\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  findall(self, /, string, pos=0, endpos=9223372036854775807)\n |      Return a list of all non-overlapping matches of pattern in string.\n |\n |  finditer(self, /, string, pos=0, endpos=9223372036854775807)\n |      Return an iterator over all non-overlapping matches for the RE pattern in string.\n |\n |      For each match, the iterator returns a match object.\n |\n |  fullmatch(self, /, string, pos=0, endpos=9223372036854775807)\n |      Matches against all of the string.\n |\n |  match(self, /, string, pos=0, endpos=9223372036854775807)\n |      Matches zero or more characters at the beginning of the string.\n |\n |  scanner(self, /, string, pos=0, endpos=9223372036854775807)\n |\n |  search(self, /, string, pos=0, endpos=9223372036854775807)\n |      Scan through string looking for a match, and return a corresponding match object instance.\n |\n |      Return None if no position in the string matches.\n |\n |  split(self, /, string, maxsplit=0)\n |      Split string by the occurrences of pattern.\n |\n |  sub(self, /, repl, string, count=0)\n |      Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.\n |\n |  subn(self, /, repl, string, count=0)\n |      Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  flags\n |      The regex matching flags.\n |\n |  groupindex\n |      A dictionary mapping group names to group numbers.\n |\n |  groups\n |      The number of capturing groups in the pattern.\n |\n |  pattern\n |      The pattern string from which the RE object was compiled.",
        "syntax": "Syntax: Pattern()",
        "other-params": ""
    },
    "re.PatternError": {
        "function": "PatternError(msg, pattern=None, pos=None)",
        "alias": "PatternError",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: PatternError(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re.RegexFlag": {
        "function": "RegexFlag(*values)",
        "alias": "RegexFlag",
        "help": "Help on class RegexFlag in module re:\n\nclass RegexFlag(enum.IntFlag)\n |  RegexFlag(*values)\n |\n |  An enumeration.\n |\n |  Method resolution order:\n |      RegexFlag\n |      enum.IntFlag\n |      builtins.int\n |      enum.ReprEnum\n |      enum.Flag\n |      enum.Enum\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __and__(self, other) from enum.Flag\n |\n |  __format__(self, format_spec, /) from builtins.int\n |      Convert to a string according to format_spec.\n |\n |  __invert__(self) from enum.Flag\n |\n |  __new__(cls, value) from enum.Enum\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  __or__(self, other) from enum.Flag\n |      Return self|value.\n |\n |  __rand__ = __and__(self, other)\n |\n |  __repr__ = global_flag_repr(self) from enum\n |      use module.flag_name instead of class.flag_name\n |\n |      the module is the last module in case of a multi-module name\n |\n |  __ror__ = __or__(self, other)\n |\n |  __rxor__ = __xor__(self, other)\n |\n |  __str__(self, /) from builtins.object\n |      Return str(self).\n |\n |  __xor__(self, other) from enum.Flag\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  ASCII = re.ASCII\n |\n |  DEBUG = re.DEBUG\n |\n |  DOTALL = re.DOTALL\n |\n |  IGNORECASE = re.IGNORECASE\n |\n |  LOCALE = re.LOCALE\n |\n |  MULTILINE = re.MULTILINE\n |\n |  UNICODE = re.UNICODE\n |\n |  VERBOSE = re.VERBOSE\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.int:\n |\n |  __abs__(self, /)\n |      abs(self)\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __ceil__(self, /)\n |      Ceiling of an Integral returns itself.\n |\n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __float__(self, /)\n |      float(self)\n |\n |  __floor__(self, /)\n |      Flooring an Integral returns itself.\n |\n |  __floordiv__(self, value, /)\n |      Return self//value.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |\n |  __int__(self, /)\n |      int(self)\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lshift__(self, value, /)\n |      Return self<<value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __neg__(self, /)\n |      -self\n |\n |  __pos__(self, /)\n |      +self\n |\n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |\n |  __radd__(self, value, /)\n |      Return value+self.\n |\n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |\n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |\n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __round__(self, ndigits=<unrepresentable>, /)\n |      Rounding an Integral returns itself.\n |\n |      Rounding with an ndigits argument also returns an integer.\n |\n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |\n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |\n |  __rshift__(self, value, /)\n |      Return self>>value.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |\n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __truediv__(self, value, /)\n |      Return self/value.\n |\n |  __trunc__(self, /)\n |      Truncating an Integral returns itself.\n |\n |  as_integer_ratio(self, /)\n |      Return a pair of integers, whose ratio is equal to the original int.\n |\n |      The ratio is in lowest terms and has a positive denominator.\n |\n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |\n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |\n |      Also known as the population count.\n |\n |      >>> bin(13)\n |      '0b1101'\n |      >>> (13).bit_count()\n |      3\n |\n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |\n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |\n |  conjugate(self, /)\n |      Returns self, the complex conjugate of any int.\n |\n |  is_integer(self, /)\n |      Returns True. Exists for duck type compatibility with float.is_integer.\n |\n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |\n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.int:\n |\n |  from_bytes(bytes, byteorder='big', *, signed=False)\n |      Return the integer represented by the given array of bytes.\n |\n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.int:\n |\n |  denominator\n |      the denominator of a rational number in lowest terms\n |\n |  imag\n |      the imaginary part of a complex number\n |\n |  numerator\n |      the numerator of a rational number in lowest terms\n |\n |  real\n |      the real part of a complex number\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from enum.Flag:\n |\n |  __contains__(self, other)\n |      Returns True if self has at least the same flags set as other.\n |\n |  __iter__(self)\n |      Returns flags in definition order.\n |\n |  __len__(self)\n |      Return the number of members (no aliases)\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from enum.Enum:\n |\n |  __dir__(self)\n |      Returns public methods and other interesting attributes.\n |\n |  __init__(self, *args, **kwds)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __reduce_ex__(self, proto)\n |      Helper for pickle.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from enum.Enum:\n |\n |  name\n |      The name of the Enum member.\n |\n |  value\n |      The value of the Enum member.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from enum.EnumType:\n |\n |  __getitem__(name)\n |      Return the member matching `name`.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from enum.EnumType:\n |\n |  __members__\n |      Returns a mapping of member name->value.\n |\n |      This mapping lists all enum members, including aliases. Note that this\n |      is a read-only view of the internal mapping.",
        "syntax": "Syntax: RegexFlag(*values)",
        "other-params": ""
    },
    "re.Scanner": {
        "function": "Scanner(lexicon, flags=0)",
        "alias": "Scanner",
        "help": "Help on class Scanner in module re:\n\nclass Scanner(builtins.object)\n |  Scanner(lexicon, flags=0)\n |\n |  Methods defined here:\n |\n |  __init__(self, lexicon, flags=0)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  scan(self, string)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: Scanner(lexicon, flags=0)",
        "other-params": ""
    },
    "re._ZeroSentinel": {
        "function": "Error retrieving signature: no signature found for builtin type <class 're._ZeroSentinel'>",
        "alias": "_ZeroSentinel",
        "help": "Help on class _ZeroSentinel in module re:\n\nclass _ZeroSentinel(builtins.int)\n |  Method resolution order:\n |      _ZeroSentinel\n |      builtins.int\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.int:\n |\n |  __abs__(self, /)\n |      abs(self)\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __and__(self, value, /)\n |      Return self&value.\n |\n |  __bool__(self, /)\n |      True if self else False\n |\n |  __ceil__(self, /)\n |      Ceiling of an Integral returns itself.\n |\n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __float__(self, /)\n |      float(self)\n |\n |  __floor__(self, /)\n |      Flooring an Integral returns itself.\n |\n |  __floordiv__(self, value, /)\n |      Return self//value.\n |\n |  __format__(self, format_spec, /)\n |      Convert to a string according to format_spec.\n |\n |  __ge__(self, value, /)\n |      Return self>=value.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self>value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |\n |  __int__(self, /)\n |      int(self)\n |\n |  __invert__(self, /)\n |      ~self\n |\n |  __le__(self, value, /)\n |      Return self<=value.\n |\n |  __lshift__(self, value, /)\n |      Return self<<value.\n |\n |  __lt__(self, value, /)\n |      Return self<value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __neg__(self, /)\n |      -self\n |\n |  __or__(self, value, /)\n |      Return self|value.\n |\n |  __pos__(self, /)\n |      +self\n |\n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |\n |  __radd__(self, value, /)\n |      Return value+self.\n |\n |  __rand__(self, value, /)\n |      Return value&self.\n |\n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |\n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __ror__(self, value, /)\n |      Return value|self.\n |\n |  __round__(self, ndigits=<unrepresentable>, /)\n |      Rounding an Integral returns itself.\n |\n |      Rounding with an ndigits argument also returns an integer.\n |\n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |\n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |\n |  __rshift__(self, value, /)\n |      Return self>>value.\n |\n |  __rsub__(self, value, /)\n |      Return value-self.\n |\n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |\n |  __rxor__(self, value, /)\n |      Return value^self.\n |\n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |\n |  __sub__(self, value, /)\n |      Return self-value.\n |\n |  __truediv__(self, value, /)\n |      Return self/value.\n |\n |  __trunc__(self, /)\n |      Truncating an Integral returns itself.\n |\n |  __xor__(self, value, /)\n |      Return self^value.\n |\n |  as_integer_ratio(self, /)\n |      Return a pair of integers, whose ratio is equal to the original int.\n |\n |      The ratio is in lowest terms and has a positive denominator.\n |\n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |\n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |\n |      Also known as the population count.\n |\n |      >>> bin(13)\n |      '0b1101'\n |      >>> (13).bit_count()\n |      3\n |\n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |\n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |\n |  conjugate(self, /)\n |      Returns self, the complex conjugate of any int.\n |\n |  is_integer(self, /)\n |      Returns True. Exists for duck type compatibility with float.is_integer.\n |\n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |\n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from builtins.int:\n |\n |  from_bytes(bytes, byteorder='big', *, signed=False)\n |      Return the integer represented by the given array of bytes.\n |\n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        sys.byteorder as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.int:\n |\n |  __new__(*args, **kwargs) class method of builtins.int\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.int:\n |\n |  denominator\n |      the denominator of a rational number in lowest terms\n |\n |  imag\n |      the imaginary part of a complex number\n |\n |  numerator\n |      the numerator of a rational number in lowest terms\n |\n |  real\n |      the real part of a complex number",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 're._ZeroSentinel'>",
        "other-params": ""
    },
    "re._compile": {
        "function": "_compile(pattern, flags)",
        "alias": "_compile",
        "help": "Help on function _compile in module re:\n\n_compile(pattern, flags)",
        "syntax": "Syntax: _compile(pattern, flags)",
        "other-params": ""
    },
    "re._compile_template": {
        "function": "_compile_template(pattern, repl)",
        "alias": "_compile_template",
        "help": "Help on _lru_cache_wrapper in module re:\n\n_compile_template(pattern, repl)",
        "syntax": "Syntax: _compile_template(pattern, repl)",
        "other-params": ""
    },
    "re._pickle": {
        "function": "_pickle(p)",
        "alias": "_pickle",
        "help": "Help on function _pickle in module re:\n\n_pickle(p)",
        "syntax": "Syntax: _pickle(p)",
        "other-params": ""
    },
    "re.compile": {
        "function": "compile(pattern, flags=0)",
        "alias": "compile",
        "help": "Help on function compile in module re:\n\ncompile(pattern, flags=0)\n    Compile a regular expression pattern, returning a Pattern object.",
        "syntax": "Syntax: compile(pattern, flags=0)",
        "other-params": ""
    },
    "re.error": {
        "function": "error(msg, pattern=None, pos=None)",
        "alias": "error",
        "help": "Help on class PatternError in module re:\n\nclass PatternError(builtins.Exception)\n |  PatternError(msg, pattern=None, pos=None)\n |\n |  Exception raised for invalid regular expressions.\n |\n |  Attributes:\n |\n |      msg: The unformatted error message\n |      pattern: The regular expression pattern\n |      pos: The index in the pattern where compilation failed (may be None)\n |      lineno: The line corresponding to pos (may be None)\n |      colno: The column corresponding to pos (may be None)\n |\n |  Method resolution order:\n |      PatternError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, msg, pattern=None, pos=None) from re._constants.PatternError\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: error(msg, pattern=None, pos=None)",
        "other-params": ""
    },
    "re.escape": {
        "function": "escape(pattern)",
        "alias": "escape",
        "help": "Help on function escape in module re:\n\nescape(pattern)\n    Escape special characters in a string.",
        "syntax": "Syntax: escape(pattern)",
        "other-params": ""
    },
    "re.findall": {
        "function": "findall(pattern, string, flags=0)",
        "alias": "findall",
        "help": "Help on function findall in module re:\n\nfindall(pattern, string, flags=0)\n    Return a list of all non-overlapping matches in the string.\n\n    If one or more capturing groups are present in the pattern, return\n    a list of groups; this will be a list of tuples if the pattern\n    has more than one group.\n\n    Empty matches are included in the result.",
        "syntax": "Syntax: findall(pattern, string, flags=0)",
        "other-params": ""
    },
    "re.finditer": {
        "function": "finditer(pattern, string, flags=0)",
        "alias": "finditer",
        "help": "Help on function finditer in module re:\n\nfinditer(pattern, string, flags=0)\n    Return an iterator over all non-overlapping matches in the\n    string.  For each match, the iterator returns a Match object.\n\n    Empty matches are included in the result.",
        "syntax": "Syntax: finditer(pattern, string, flags=0)",
        "other-params": ""
    },
    "re.fullmatch": {
        "function": "fullmatch(pattern, string, flags=0)",
        "alias": "fullmatch",
        "help": "Help on function fullmatch in module re:\n\nfullmatch(pattern, string, flags=0)\n    Try to apply the pattern to all of the string, returning\n    a Match object, or None if no match was found.",
        "syntax": "Syntax: fullmatch(pattern, string, flags=0)",
        "other-params": ""
    },
    "re.match": {
        "function": "match(pattern, string, flags=0)",
        "alias": "match",
        "help": "Help on function match in module re:\n\nmatch(pattern, string, flags=0)\n    Try to apply the pattern at the start of the string, returning\n    a Match object, or None if no match was found.",
        "syntax": "Syntax: match(pattern, string, flags=0)",
        "other-params": ""
    },
    "re.purge": {
        "function": "purge()",
        "alias": "purge",
        "help": "Help on function purge in module re:\n\npurge()\n    Clear the regular expression caches",
        "syntax": "Syntax: purge()",
        "other-params": ""
    },
    "re.search": {
        "function": "search(pattern, string, flags=0)",
        "alias": "search",
        "help": "Help on function search in module re:\n\nsearch(pattern, string, flags=0)\n    Scan through string looking for a match to the pattern, returning\n    a Match object, or None if no match was found.",
        "syntax": "Syntax: search(pattern, string, flags=0)",
        "other-params": ""
    },
    "re.split": {
        "function": "split(pattern, string, maxsplit=0, flags=0)",
        "alias": "split",
        "help": "Help on function split in module re:\n\nsplit(pattern, string, maxsplit=0, flags=0)\n    Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.  If\n    capturing parentheses are used in pattern, then the text of all\n    groups in the pattern are also returned as part of the resulting\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\n    and the remainder of the string is returned as the final element\n    of the list.",
        "syntax": "Syntax: split(pattern, string, maxsplit=0, flags=0)",
        "other-params": ""
    },
    "re.sub": {
        "function": "sub(pattern, repl, string, count=0, flags=0)",
        "alias": "sub",
        "help": "Help on function sub in module re:\n\nsub(pattern, repl, string, count=0, flags=0)\n    Return the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in string by the\n    replacement repl.  repl can be either a string or a callable;\n    if a string, backslash escapes in it are processed.  If it is\n    a callable, it's passed the Match object and must return\n    a replacement string to be used.",
        "syntax": "Syntax: sub(pattern, repl, string, count=0, flags=0)",
        "other-params": ""
    },
    "re.subn": {
        "function": "subn(pattern, repl, string, count=0, flags=0)",
        "alias": "subn",
        "help": "Help on function subn in module re:\n\nsubn(pattern, repl, string, count=0, flags=0)\n    Return a 2-tuple containing (new_string, number).\n    new_string is the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in the source\n    string by the replacement repl.  number is the number of\n    substitutions that were made. repl can be either a string or a\n    callable; if a string, backslash escapes in it are processed.\n    If it is a callable, it's passed the Match object and must\n    return a replacement string to be used.",
        "syntax": "Syntax: subn(pattern, repl, string, count=0, flags=0)",
        "other-params": ""
    },
    "posixpath._get_sep": {
        "function": "_get_sep(path)",
        "alias": "_get_sep",
        "help": "Help on function _get_sep in module posixpath:\n\n_get_sep(path)",
        "syntax": "Syntax: _get_sep(path)",
        "other-params": ""
    },
    "posixpath.abspath": {
        "function": "abspath(path)",
        "alias": "abspath",
        "help": "Help on function abspath in module posixpath:\n\nabspath(path)\n    Return an absolute path.",
        "syntax": "Syntax: abspath(path)",
        "other-params": ""
    },
    "posixpath.basename": {
        "function": "basename(p)",
        "alias": "basename",
        "help": "Help on function basename in module posixpath:\n\nbasename(p)\n    Returns the final component of a pathname",
        "syntax": "Syntax: basename(p)",
        "other-params": ""
    },
    "posixpath.commonpath": {
        "function": "commonpath(paths)",
        "alias": "commonpath",
        "help": "Help on function commonpath in module posixpath:\n\ncommonpath(paths)\n    Given a sequence of path names, returns the longest common sub-path.",
        "syntax": "Syntax: commonpath(paths)",
        "other-params": ""
    },
    "posixpath.commonprefix": {
        "function": "commonprefix(m)",
        "alias": "commonprefix",
        "help": "Help on function commonprefix in module genericpath:\n\ncommonprefix(m)\n    Given a list of pathnames, returns the longest common leading component",
        "syntax": "Syntax: commonprefix(m)",
        "other-params": ""
    },
    "posixpath.dirname": {
        "function": "dirname(p)",
        "alias": "dirname",
        "help": "Help on function dirname in module posixpath:\n\ndirname(p)\n    Returns the directory component of a pathname",
        "syntax": "Syntax: dirname(p)",
        "other-params": ""
    },
    "posixpath.exists": {
        "function": "exists(path)",
        "alias": "exists",
        "help": "Help on function exists in module genericpath:\n\nexists(path)\n    Test whether a path exists.  Returns False for broken symbolic links",
        "syntax": "Syntax: exists(path)",
        "other-params": ""
    },
    "posixpath.expanduser": {
        "function": "expanduser(path)",
        "alias": "expanduser",
        "help": "Help on function expanduser in module posixpath:\n\nexpanduser(path)\n    Expand ~ and ~user constructions.  If user or $HOME is unknown,\n    do nothing.",
        "syntax": "Syntax: expanduser(path)",
        "other-params": ""
    },
    "posixpath.expandvars": {
        "function": "expandvars(path)",
        "alias": "expandvars",
        "help": "Help on function expandvars in module posixpath:\n\nexpandvars(path)\n    Expand shell variables of form $var and ${var}.  Unknown variables\n    are left unchanged.",
        "syntax": "Syntax: expandvars(path)",
        "other-params": ""
    },
    "posixpath.getatime": {
        "function": "getatime(filename)",
        "alias": "getatime",
        "help": "Help on function getatime in module genericpath:\n\ngetatime(filename)\n    Return the last access time of a file, reported by os.stat().",
        "syntax": "Syntax: getatime(filename)",
        "other-params": ""
    },
    "posixpath.getctime": {
        "function": "getctime(filename)",
        "alias": "getctime",
        "help": "Help on function getctime in module genericpath:\n\ngetctime(filename)\n    Return the metadata change time of a file, reported by os.stat().",
        "syntax": "Syntax: getctime(filename)",
        "other-params": ""
    },
    "posixpath.getmtime": {
        "function": "getmtime(filename)",
        "alias": "getmtime",
        "help": "Help on function getmtime in module genericpath:\n\ngetmtime(filename)\n    Return the last modification time of a file, reported by os.stat().",
        "syntax": "Syntax: getmtime(filename)",
        "other-params": ""
    },
    "posixpath.getsize": {
        "function": "getsize(filename)",
        "alias": "getsize",
        "help": "Help on function getsize in module genericpath:\n\ngetsize(filename)\n    Return the size of a file, reported by os.stat().",
        "syntax": "Syntax: getsize(filename)",
        "other-params": ""
    },
    "posixpath.isabs": {
        "function": "isabs(s)",
        "alias": "isabs",
        "help": "Help on function isabs in module posixpath:\n\nisabs(s)\n    Test whether a path is absolute",
        "syntax": "Syntax: isabs(s)",
        "other-params": ""
    },
    "posixpath.isdevdrive": {
        "function": "isdevdrive(path)",
        "alias": "isdevdrive",
        "help": "Help on function isdevdrive in module genericpath:\n\nisdevdrive(path)\n    Determines whether the specified path is on a Windows Dev Drive.\n    Dev Drives are not supported on the current platform",
        "syntax": "Syntax: isdevdrive(path)",
        "other-params": ""
    },
    "posixpath.isdir": {
        "function": "isdir(s)",
        "alias": "isdir",
        "help": "Help on function isdir in module genericpath:\n\nisdir(s)\n    Return true if the pathname refers to an existing directory.",
        "syntax": "Syntax: isdir(s)",
        "other-params": ""
    },
    "posixpath.isfile": {
        "function": "isfile(path)",
        "alias": "isfile",
        "help": "Help on function isfile in module genericpath:\n\nisfile(path)\n    Test whether a path is a regular file",
        "syntax": "Syntax: isfile(path)",
        "other-params": ""
    },
    "posixpath.isjunction": {
        "function": "isjunction(path)",
        "alias": "isjunction",
        "help": "Help on function isjunction in module genericpath:\n\nisjunction(path)\n    Test whether a path is a junction\n    Junctions are not supported on the current platform",
        "syntax": "Syntax: isjunction(path)",
        "other-params": ""
    },
    "posixpath.islink": {
        "function": "islink(path)",
        "alias": "islink",
        "help": "Help on function islink in module genericpath:\n\nislink(path)\n    Test whether a path is a symbolic link",
        "syntax": "Syntax: islink(path)",
        "other-params": ""
    },
    "posixpath.ismount": {
        "function": "ismount(path)",
        "alias": "ismount",
        "help": "Help on function ismount in module posixpath:\n\nismount(path)\n    Test whether a path is a mount point",
        "syntax": "Syntax: ismount(path)",
        "other-params": ""
    },
    "posixpath.join": {
        "function": "join(a, *p)",
        "alias": "join",
        "help": "Help on function join in module posixpath:\n\njoin(a, *p)\n    Join two or more pathname components, inserting '/' as needed.\n    If any component is an absolute path, all previous path components\n    will be discarded.  An empty last part will result in a path that\n    ends with a separator.",
        "syntax": "Syntax: join(a, *p)",
        "other-params": ""
    },
    "posixpath.lexists": {
        "function": "lexists(path)",
        "alias": "lexists",
        "help": "Help on function lexists in module genericpath:\n\nlexists(path)\n    Test whether a path exists.  Returns True for broken symbolic links",
        "syntax": "Syntax: lexists(path)",
        "other-params": ""
    },
    "posixpath.normcase": {
        "function": "normcase(s)",
        "alias": "normcase",
        "help": "Help on function normcase in module posixpath:\n\nnormcase(s)\n    Normalize case of pathname.  Has no effect under Posix",
        "syntax": "Syntax: normcase(s)",
        "other-params": ""
    },
    "posixpath.normpath": {
        "function": "normpath(path)",
        "alias": "normpath",
        "help": "Help on function normpath in module posixpath:\n\nnormpath(path)\n    Normalize path, eliminating double slashes, etc.",
        "syntax": "Syntax: normpath(path)",
        "other-params": ""
    },
    "posixpath.realpath": {
        "function": "realpath(filename, *, strict=False)",
        "alias": "realpath",
        "help": "Help on function realpath in module posixpath:\n\nrealpath(filename, *, strict=False)\n    Return the canonical path of the specified filename, eliminating any\n    symbolic links encountered in the path.",
        "syntax": "Syntax: realpath(filename, *, strict=False)",
        "other-params": ""
    },
    "posixpath.relpath": {
        "function": "relpath(path, start=None)",
        "alias": "relpath",
        "help": "Help on function relpath in module posixpath:\n\nrelpath(path, start=None)\n    Return a relative version of a path",
        "syntax": "Syntax: relpath(path, start=None)",
        "other-params": ""
    },
    "posixpath.samefile": {
        "function": "samefile(f1, f2)",
        "alias": "samefile",
        "help": "Help on function samefile in module genericpath:\n\nsamefile(f1, f2)\n    Test whether two pathnames reference the same actual file or directory\n\n    This is determined by the device number and i-node number and\n    raises an exception if an os.stat() call on either pathname fails.",
        "syntax": "Syntax: samefile(f1, f2)",
        "other-params": ""
    },
    "posixpath.sameopenfile": {
        "function": "sameopenfile(fp1, fp2)",
        "alias": "sameopenfile",
        "help": "Help on function sameopenfile in module genericpath:\n\nsameopenfile(fp1, fp2)\n    Test whether two open file objects reference the same file",
        "syntax": "Syntax: sameopenfile(fp1, fp2)",
        "other-params": ""
    },
    "posixpath.samestat": {
        "function": "samestat(s1, s2)",
        "alias": "samestat",
        "help": "Help on function samestat in module genericpath:\n\nsamestat(s1, s2)\n    Test whether two stat buffers reference the same file",
        "syntax": "Syntax: samestat(s1, s2)",
        "other-params": ""
    },
    "posixpath.split": {
        "function": "split(p)",
        "alias": "split",
        "help": "Help on function split in module posixpath:\n\nsplit(p)\n    Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\n    everything after the final slash.  Either part may be empty.",
        "syntax": "Syntax: split(p)",
        "other-params": ""
    },
    "posixpath.splitdrive": {
        "function": "splitdrive(p)",
        "alias": "splitdrive",
        "help": "Help on function splitdrive in module posixpath:\n\nsplitdrive(p)\n    Split a pathname into drive and path. On Posix, drive is always\n    empty.",
        "syntax": "Syntax: splitdrive(p)",
        "other-params": ""
    },
    "posixpath.splitext": {
        "function": "splitext(p)",
        "alias": "splitext",
        "help": "Help on function splitext in module posixpath:\n\nsplitext(p)\n    Split the extension from a pathname.\n\n    Extension is everything from the last dot to the end, ignoring\n    leading dots.  Returns \"(root, ext)\"; ext may be empty.",
        "syntax": "Syntax: splitext(p)",
        "other-params": ""
    },
    "posixpath.splitroot": {
        "function": "splitroot(p)",
        "alias": "splitroot",
        "help": "Help on function splitroot in module posixpath:\n\nsplitroot(p)\n    Split a pathname into drive, root and tail.\n\n    The tail contains anything after the root.",
        "syntax": "Syntax: splitroot(p)",
        "other-params": ""
    },
    "fnmatch._compile_pattern": {
        "function": "_compile_pattern(pat)",
        "alias": "_compile_pattern",
        "help": "Help on _lru_cache_wrapper in module fnmatch:\n\n_compile_pattern(pat)",
        "syntax": "Syntax: _compile_pattern(pat)",
        "other-params": ""
    },
    "fnmatch._join_translated_parts": {
        "function": "_join_translated_parts(inp, STAR)",
        "alias": "_join_translated_parts",
        "help": "Help on function _join_translated_parts in module fnmatch:\n\n_join_translated_parts(inp, STAR)",
        "syntax": "Syntax: _join_translated_parts(inp, STAR)",
        "other-params": ""
    },
    "fnmatch._translate": {
        "function": "_translate(pat, STAR, QUESTION_MARK)",
        "alias": "_translate",
        "help": "Help on function _translate in module fnmatch:\n\n_translate(pat, STAR, QUESTION_MARK)",
        "syntax": "Syntax: _translate(pat, STAR, QUESTION_MARK)",
        "other-params": ""
    },
    "fnmatch.filter": {
        "function": "filter(names, pat)",
        "alias": "filter",
        "help": "Help on function filter in module fnmatch:\n\nfilter(names, pat)\n    Construct a list from those elements of the iterable NAMES that match PAT.",
        "syntax": "Syntax: filter(names, pat)",
        "other-params": ""
    },
    "fnmatch.fnmatch": {
        "function": "fnmatch(name, pat)",
        "alias": "fnmatch",
        "help": "Help on function fnmatch in module fnmatch:\n\nfnmatch(name, pat)\n    Test whether FILENAME matches PATTERN.\n\n    Patterns are Unix shell style:\n\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq\n    [!seq]  matches any char not in seq\n\n    An initial period in FILENAME is not special.\n    Both FILENAME and PATTERN are first case-normalized\n    if the operating system requires it.\n    If you don't want this, use fnmatchcase(FILENAME, PATTERN).",
        "syntax": "Syntax: fnmatch(name, pat)",
        "other-params": ""
    },
    "fnmatch.fnmatchcase": {
        "function": "fnmatchcase(name, pat)",
        "alias": "fnmatchcase",
        "help": "Help on function fnmatchcase in module fnmatch:\n\nfnmatchcase(name, pat)\n    Test whether FILENAME matches PATTERN, including case.\n\n    This is a version of fnmatch() which doesn't case-normalize\n    its arguments.",
        "syntax": "Syntax: fnmatchcase(name, pat)",
        "other-params": ""
    },
    "fnmatch.translate": {
        "function": "translate(pat)",
        "alias": "translate",
        "help": "Help on function translate in module fnmatch:\n\ntranslate(pat)\n    Translate a shell PATTERN to a regular expression.\n\n    There is no way to quote meta-characters.",
        "syntax": "Syntax: translate(pat)",
        "other-params": ""
    },
    "glob._Globber": {
        "function": "_Globber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "alias": "_Globber",
        "help": "Help on class _Globber in module glob:\n\nclass _Globber(builtins.object)\n |  _Globber(sep, case_sensitive, case_pedantic=False, recursive=False)\n |\n |  Class providing shell-style pattern matching and globbing.\n |\n |  Methods defined here:\n |\n |  __init__(self, sep, case_sensitive, case_pedantic=False, recursive=False)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  compile(self, pat)\n |\n |  literal_selector(self, part, parts)\n |      Returns a function that selects a literal descendant of a path.\n |\n |  recursive_selector(self, part, parts)\n |      Returns a function that selects a given path and all its children,\n |      recursively, filtering by pattern.\n |\n |  select_exists(self, path, exists=False)\n |      Yields the given path, if it exists.\n |\n |  selector(self, parts)\n |      Returns a function that selects from a given path, walking and\n |      filtering according to the glob-style pattern parts in *parts*.\n |\n |  special_selector(self, part, parts)\n |      Returns a function that selects special children of the given path.\n |\n |  wildcard_selector(self, part, parts)\n |      Returns a function that selects direct children of a given path,\n |      filtering by pattern.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  concat_path(path, text)\n |      Appends text to the given path.\n |\n |  parse_entry(entry)\n |      Returns the path of an entry yielded from scandir().\n |\n |  scandir(path)\n |      Emulates os.scandir(), which returns an object that can be used as\n |      a context manager. This method is called by walk() and glob().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  add_slash = operator.methodcaller('joinpath', '')\n |\n |  lstat = operator.methodcaller('lstat')",
        "syntax": "Syntax: _Globber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "other-params": ""
    },
    "glob._StringGlobber": {
        "function": "_StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "alias": "_StringGlobber",
        "help": "Help on class _StringGlobber in module glob:\n\nclass _StringGlobber(_Globber)\n |  _StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)\n |\n |  Method resolution order:\n |      _StringGlobber\n |      _Globber\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  add_slash(pathname)\n |\n |  concat_path = add(a, b, /)\n |      Same as a + b.\n |\n |  lstat(path, *, dir_fd=None)\n |      Perform a stat system call on the given path, without following symbolic links.\n |\n |      Like stat(), but do not follow symbolic links.\n |      Equivalent to stat(path, follow_symlinks=False).\n |\n |  scandir(path=None)\n |      Return an iterator of DirEntry objects for given path.\n |\n |      path can be specified as either str, bytes, or a path-like object.  If path\n |      is bytes, the names of yielded DirEntry objects will also be bytes; in\n |      all other circumstances they will be str.\n |\n |      If path is None, uses the path='.'.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parse_entry = operator.attrgetter('path')\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _Globber:\n |\n |  __init__(self, sep, case_sensitive, case_pedantic=False, recursive=False)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  compile(self, pat)\n |\n |  literal_selector(self, part, parts)\n |      Returns a function that selects a literal descendant of a path.\n |\n |  recursive_selector(self, part, parts)\n |      Returns a function that selects a given path and all its children,\n |      recursively, filtering by pattern.\n |\n |  select_exists(self, path, exists=False)\n |      Yields the given path, if it exists.\n |\n |  selector(self, parts)\n |      Returns a function that selects from a given path, walking and\n |      filtering according to the glob-style pattern parts in *parts*.\n |\n |  special_selector(self, part, parts)\n |      Returns a function that selects special children of the given path.\n |\n |  wildcard_selector(self, part, parts)\n |      Returns a function that selects direct children of a given path,\n |      filtering by pattern.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _Globber:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "other-params": ""
    },
    "glob._compile_pattern": {
        "function": "_compile_pattern(pat, sep, case_sensitive, recursive=True)",
        "alias": "_compile_pattern",
        "help": "Help on _lru_cache_wrapper in module glob:\n\n_compile_pattern(pat, sep, case_sensitive, recursive=True)\n    Compile given glob pattern to a re.Pattern object (observing case\n    sensitivity).",
        "syntax": "Syntax: _compile_pattern(pat, sep, case_sensitive, recursive=True)",
        "other-params": ""
    },
    "glob._glob0": {
        "function": "_glob0(dirname, basename, dir_fd, dironly, include_hidden=False)",
        "alias": "_glob0",
        "help": "Help on function _glob0 in module glob:\n\n_glob0(dirname, basename, dir_fd, dironly, include_hidden=False)",
        "syntax": "Syntax: _glob0(dirname, basename, dir_fd, dironly, include_hidden=False)",
        "other-params": ""
    },
    "glob._glob1": {
        "function": "_glob1(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "alias": "_glob1",
        "help": "Help on function _glob1 in module glob:\n\n_glob1(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "syntax": "Syntax: _glob1(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "other-params": ""
    },
    "glob._glob2": {
        "function": "_glob2(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "alias": "_glob2",
        "help": "Help on function _glob2 in module glob:\n\n_glob2(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "syntax": "Syntax: _glob2(dirname, pattern, dir_fd, dironly, include_hidden=False)",
        "other-params": ""
    },
    "glob._iglob": {
        "function": "_iglob(pathname, root_dir, dir_fd, recursive, dironly, include_hidden=False)",
        "alias": "_iglob",
        "help": "Help on function _iglob in module glob:\n\n_iglob(pathname, root_dir, dir_fd, recursive, dironly, include_hidden=False)",
        "syntax": "Syntax: _iglob(pathname, root_dir, dir_fd, recursive, dironly, include_hidden=False)",
        "other-params": ""
    },
    "glob._isdir": {
        "function": "_isdir(pathname, dir_fd)",
        "alias": "_isdir",
        "help": "Help on function _isdir in module glob:\n\n_isdir(pathname, dir_fd)",
        "syntax": "Syntax: _isdir(pathname, dir_fd)",
        "other-params": ""
    },
    "glob._ishidden": {
        "function": "_ishidden(path)",
        "alias": "_ishidden",
        "help": "Help on function _ishidden in module glob:\n\n_ishidden(path)",
        "syntax": "Syntax: _ishidden(path)",
        "other-params": ""
    },
    "glob._isrecursive": {
        "function": "_isrecursive(pattern)",
        "alias": "_isrecursive",
        "help": "Help on function _isrecursive in module glob:\n\n_isrecursive(pattern)",
        "syntax": "Syntax: _isrecursive(pattern)",
        "other-params": ""
    },
    "glob._iterdir": {
        "function": "_iterdir(dirname, dir_fd, dironly)",
        "alias": "_iterdir",
        "help": "Help on function _iterdir in module glob:\n\n_iterdir(dirname, dir_fd, dironly)\n    # If dironly is false, yields all file names inside a directory.\n    # If dironly is true, yields only directory names.",
        "syntax": "Syntax: _iterdir(dirname, dir_fd, dironly)",
        "other-params": ""
    },
    "glob._join": {
        "function": "_join(dirname, basename)",
        "alias": "_join",
        "help": "Help on function _join in module glob:\n\n_join(dirname, basename)",
        "syntax": "Syntax: _join(dirname, basename)",
        "other-params": ""
    },
    "glob._lexists": {
        "function": "_lexists(pathname, dir_fd)",
        "alias": "_lexists",
        "help": "Help on function _lexists in module glob:\n\n_lexists(pathname, dir_fd)",
        "syntax": "Syntax: _lexists(pathname, dir_fd)",
        "other-params": ""
    },
    "glob._listdir": {
        "function": "_listdir(dirname, dir_fd, dironly)",
        "alias": "_listdir",
        "help": "Help on function _listdir in module glob:\n\n_listdir(dirname, dir_fd, dironly)",
        "syntax": "Syntax: _listdir(dirname, dir_fd, dironly)",
        "other-params": ""
    },
    "glob._rlistdir": {
        "function": "_rlistdir(dirname, dir_fd, dironly, include_hidden=False)",
        "alias": "_rlistdir",
        "help": "Help on function _rlistdir in module glob:\n\n_rlistdir(dirname, dir_fd, dironly, include_hidden=False)\n    # Recursively yields relative pathnames inside a literal directory.",
        "syntax": "Syntax: _rlistdir(dirname, dir_fd, dironly, include_hidden=False)",
        "other-params": ""
    },
    "glob.escape": {
        "function": "escape(pathname)",
        "alias": "escape",
        "help": "Help on function escape in module glob:\n\nescape(pathname)\n    Escape all special characters.",
        "syntax": "Syntax: escape(pathname)",
        "other-params": ""
    },
    "glob.glob": {
        "function": "glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
        "alias": "glob",
        "help": "Help on function glob in module glob:\n\nglob(\n    pathname,\n    *,\n    root_dir=None,\n    dir_fd=None,\n    recursive=False,\n    include_hidden=False\n)\n    Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. Unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns by default.\n\n    If `include_hidden` is true, the patterns '*', '?', '**'  will match hidden\n    directories.\n\n    If `recursive` is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.",
        "syntax": "Syntax: glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
        "other-params": ""
    },
    "glob.glob0": {
        "function": "glob0(dirname, pattern)",
        "alias": "glob0",
        "help": "Help on function glob0 in module glob:\n\nglob0(dirname, pattern)",
        "syntax": "Syntax: glob0(dirname, pattern)",
        "other-params": ""
    },
    "glob.glob1": {
        "function": "glob1(dirname, pattern)",
        "alias": "glob1",
        "help": "Help on function glob1 in module glob:\n\nglob1(dirname, pattern)",
        "syntax": "Syntax: glob1(dirname, pattern)",
        "other-params": ""
    },
    "glob.has_magic": {
        "function": "has_magic(s)",
        "alias": "has_magic",
        "help": "Help on function has_magic in module glob:\n\nhas_magic(s)",
        "syntax": "Syntax: has_magic(s)",
        "other-params": ""
    },
    "glob.iglob": {
        "function": "iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
        "alias": "iglob",
        "help": "Help on function iglob in module glob:\n\niglob(\n    pathname,\n    *,\n    root_dir=None,\n    dir_fd=None,\n    recursive=False,\n    include_hidden=False\n)\n    Return an iterator which yields the paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.",
        "syntax": "Syntax: iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
        "other-params": ""
    },
    "glob.translate": {
        "function": "translate(pat, *, recursive=False, include_hidden=False, seps=None)",
        "alias": "translate",
        "help": "Help on function translate in module glob:\n\ntranslate(pat, *, recursive=False, include_hidden=False, seps=None)\n    Translate a pathname with shell wildcards to a regular expression.\n\n    If `recursive` is true, the pattern segment '**' will match any number of\n    path segments.\n\n    If `include_hidden` is true, wildcards can match path segments beginning\n    with a dot ('.').\n\n    If a sequence of separator characters is given to `seps`, they will be\n    used to split the pattern into segments and match path separators. If not\n    given, os.path.sep and os.path.altsep (where available) are used.",
        "syntax": "Syntax: translate(pat, *, recursive=False, include_hidden=False, seps=None)",
        "other-params": ""
    },
    "pathlib._abc.ParserBase": {
        "function": "ParserBase()",
        "alias": "ParserBase",
        "help": "Help on class ParserBase in module pathlib._abc:\n\nclass ParserBase(builtins.object)\n |  Base class for path parsers, which do low-level path manipulation.\n |\n |  Path parsers provide a subset of the os.path API, specifically those\n |  functions needed to provide PurePathBase functionality. Each PurePathBase\n |  subclass references its path parser via a 'parser' class attribute.\n |\n |  Every method in this base class raises an UnsupportedOperation exception.\n |\n |  Methods defined here:\n |\n |  isabs(self, path)\n |      Returns whether the path is absolute, i.e. unaffected by the\n |      current directory or drive.\n |\n |  join(self, path, *paths)\n |      Join path segments.\n |\n |  normcase(self, path)\n |      Normalize the case of the path.\n |\n |  split(self, path)\n |      Split the path into a pair (head, tail), where *head* is everything\n |      before the final path separator, and *tail* is everything after.\n |      Either part may be empty.\n |\n |  splitdrive(self, path)\n |      Split the path into a 2-item tuple (drive, tail), where *drive* is\n |      a device name or mount point, and *tail* is everything after the\n |      drive. Either part may be empty.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  sep\n |      The character used to separate path components.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: ParserBase()",
        "other-params": ""
    },
    "pathlib._abc.PathBase": {
        "function": "PathBase(path, *paths)",
        "alias": "PathBase",
        "help": "Help on class PathBase in module pathlib._abc:\n\nclass PathBase(PurePathBase)\n |  PathBase(path, *paths)\n |\n |  Base class for concrete path objects.\n |\n |  This class provides dummy implementations for many methods that derived\n |  classes can override selectively; the default implementations raise\n |  UnsupportedOperation. The most basic methods, such as stat() and open(),\n |  directly raise UnsupportedOperation; these basic methods are called by\n |  other methods such as is_dir() and read_text().\n |\n |  The Path class derives this class to implement local filesystem paths.\n |  Users may derive their own classes to implement virtual filesystem paths,\n |  such as paths in archive files or on remote storage systems.\n |\n |  Method resolution order:\n |      PathBase\n |      PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=True)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=True)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePathBase:\n |\n |  __init__(self, path, *paths)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other)\n |      Return True if the path is relative to another path or False.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  relative_to(self, other, *, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePathBase:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePathBase:\n |\n |  parser = <pathlib._abc.ParserBase object>",
        "syntax": "Syntax: PathBase(path, *paths)",
        "other-params": ""
    },
    "pathlib._abc.PurePathBase": {
        "function": "PurePathBase(path, *paths)",
        "alias": "PurePathBase",
        "help": "Help on class PurePathBase in module pathlib._abc:\n\nclass PurePathBase(builtins.object)\n |  PurePathBase(path, *paths)\n |\n |  Base class for pure path objects.\n |\n |  This class *does not* provide several magic methods that are defined in\n |  its subclass PurePath. They are: __fspath__, __bytes__, __reduce__,\n |  __hash__, __eq__, __lt__, __le__, __gt__, __ge__. Its initializer and path\n |  joining methods accept only strings, not os.PathLike objects more broadly.\n |\n |  Methods defined here:\n |\n |  __init__(self, path, *paths)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other)\n |      Return True if the path is relative to another path or False.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  relative_to(self, other, *, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parser = <pathlib._abc.ParserBase object>",
        "syntax": "Syntax: PurePathBase(path, *paths)",
        "other-params": ""
    },
    "pathlib._abc.S_ISBLK": {
        "function": "S_ISBLK(object, /)",
        "alias": "S_ISBLK",
        "help": "Help on built-in function S_ISBLK in module _stat:\n\nS_ISBLK(object, /)\n    S_ISBLK(mode) -> bool\n\n    Return True if mode is from a block special device file.",
        "syntax": "Syntax: S_ISBLK(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISCHR": {
        "function": "S_ISCHR(object, /)",
        "alias": "S_ISCHR",
        "help": "Help on built-in function S_ISCHR in module _stat:\n\nS_ISCHR(object, /)\n    S_ISCHR(mode) -> bool\n\n    Return True if mode is from a character special device file.",
        "syntax": "Syntax: S_ISCHR(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISDIR": {
        "function": "S_ISDIR(object, /)",
        "alias": "S_ISDIR",
        "help": "Help on built-in function S_ISDIR in module _stat:\n\nS_ISDIR(object, /)\n    S_ISDIR(mode) -> bool\n\n    Return True if mode is from a directory.",
        "syntax": "Syntax: S_ISDIR(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISFIFO": {
        "function": "S_ISFIFO(object, /)",
        "alias": "S_ISFIFO",
        "help": "Help on built-in function S_ISFIFO in module _stat:\n\nS_ISFIFO(object, /)\n    S_ISFIFO(mode) -> bool\n\n    Return True if mode is from a FIFO (named pipe).",
        "syntax": "Syntax: S_ISFIFO(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISLNK": {
        "function": "S_ISLNK(object, /)",
        "alias": "S_ISLNK",
        "help": "Help on built-in function S_ISLNK in module _stat:\n\nS_ISLNK(object, /)\n    S_ISLNK(mode) -> bool\n\n    Return True if mode is from a symbolic link.",
        "syntax": "Syntax: S_ISLNK(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISREG": {
        "function": "S_ISREG(object, /)",
        "alias": "S_ISREG",
        "help": "Help on built-in function S_ISREG in module _stat:\n\nS_ISREG(object, /)\n    S_ISREG(mode) -> bool\n\n    Return True if mode is from a regular file.",
        "syntax": "Syntax: S_ISREG(object, /)",
        "other-params": ""
    },
    "pathlib._abc.S_ISSOCK": {
        "function": "S_ISSOCK(object, /)",
        "alias": "S_ISSOCK",
        "help": "Help on built-in function S_ISSOCK in module _stat:\n\nS_ISSOCK(object, /)\n    S_ISSOCK(mode) -> bool\n\n    Return True if mode is from a socket.",
        "syntax": "Syntax: S_ISSOCK(object, /)",
        "other-params": ""
    },
    "pathlib._abc.UnsupportedOperation": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "alias": "UnsupportedOperation",
        "help": "Help on class UnsupportedOperation in module pathlib._abc:\n\nclass UnsupportedOperation(builtins.NotImplementedError)\n |  An exception that is raised when an unsupported operation is called on\n |  a path object.\n |\n |  Method resolution order:\n |      UnsupportedOperation\n |      builtins.NotImplementedError\n |      builtins.RuntimeError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.NotImplementedError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.NotImplementedError:\n |\n |  __new__(*args, **kwargs) class method of builtins.NotImplementedError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "other-params": ""
    },
    "pathlib._abc._Globber": {
        "function": "_Globber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "alias": "_Globber",
        "help": "Help on class _Globber in module glob:\n\nclass _Globber(builtins.object)\n |  _Globber(sep, case_sensitive, case_pedantic=False, recursive=False)\n |\n |  Class providing shell-style pattern matching and globbing.\n |\n |  Methods defined here:\n |\n |  __init__(self, sep, case_sensitive, case_pedantic=False, recursive=False)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  compile(self, pat)\n |\n |  literal_selector(self, part, parts)\n |      Returns a function that selects a literal descendant of a path.\n |\n |  recursive_selector(self, part, parts)\n |      Returns a function that selects a given path and all its children,\n |      recursively, filtering by pattern.\n |\n |  select_exists(self, path, exists=False)\n |      Yields the given path, if it exists.\n |\n |  selector(self, parts)\n |      Returns a function that selects from a given path, walking and\n |      filtering according to the glob-style pattern parts in *parts*.\n |\n |  special_selector(self, part, parts)\n |      Returns a function that selects special children of the given path.\n |\n |  wildcard_selector(self, part, parts)\n |      Returns a function that selects direct children of a given path,\n |      filtering by pattern.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  concat_path(path, text)\n |      Appends text to the given path.\n |\n |  parse_entry(entry)\n |      Returns the path of an entry yielded from scandir().\n |\n |  scandir(path)\n |      Emulates os.scandir(), which returns an object that can be used as\n |      a context manager. This method is called by walk() and glob().\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  add_slash = operator.methodcaller('joinpath', '')\n |\n |  lstat = operator.methodcaller('lstat')",
        "syntax": "Syntax: _Globber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "other-params": ""
    },
    "pathlib._abc._ignore_error": {
        "function": "_ignore_error(exception)",
        "alias": "_ignore_error",
        "help": "Help on function _ignore_error in module pathlib._abc:\n\n_ignore_error(exception)",
        "syntax": "Syntax: _ignore_error(exception)",
        "other-params": ""
    },
    "pathlib._abc._is_case_sensitive": {
        "function": "_is_case_sensitive(parser)",
        "alias": "_is_case_sensitive",
        "help": "Help on _lru_cache_wrapper in module pathlib._abc:\n\n_is_case_sensitive(parser)",
        "syntax": "Syntax: _is_case_sensitive(parser)",
        "other-params": ""
    },
    "warnings.WarningMessage": {
        "function": "WarningMessage(message, category, filename, lineno, file=None, line=None, source=None)",
        "alias": "WarningMessage",
        "help": "Help on class WarningMessage in module warnings:\n\nclass WarningMessage(builtins.object)\n |  WarningMessage(\n |      message,\n |      category,\n |      filename,\n |      lineno,\n |      file=None,\n |      line=None,\n |      source=None\n |  )\n |\n |  Methods defined here:\n |\n |  __init__(\n |      self,\n |      message,\n |      category,\n |      filename,\n |      lineno,\n |      file=None,\n |      line=None,\n |      source=None\n |  )\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __str__(self)\n |      Return str(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: WarningMessage(message, category, filename, lineno, file=None, line=None, source=None)",
        "other-params": ""
    },
    "warnings._OptionError": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'warnings._OptionError'>",
        "alias": "_OptionError",
        "help": "Help on class _OptionError in module warnings:\n\nclass _OptionError(builtins.Exception)\n |  Exception used by option processing helpers.\n |\n |  Method resolution order:\n |      _OptionError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.Exception:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.Exception:\n |\n |  __new__(*args, **kwargs) class method of builtins.Exception\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'warnings._OptionError'>",
        "other-params": ""
    },
    "warnings._add_filter": {
        "function": "_add_filter(*item, append)",
        "alias": "_add_filter",
        "help": "Help on function _add_filter in module warnings:\n\n_add_filter(*item, append)",
        "syntax": "Syntax: _add_filter(*item, append)",
        "other-params": ""
    },
    "warnings._deprecated": {
        "function": "_deprecated(name, message='{name!r} is deprecated and slated for removal in Python {remove}', *, remove, _version=sys.version_info(major=3, minor=13, micro=1, releaselevel='final', serial=0))",
        "alias": "_deprecated",
        "help": "Help on function _deprecated in module warnings:\n\n_deprecated(\n    name,\n    message='{name!r} is deprecated and slated for removal in Python {remove}',\n    *,\n    remove,\n    _version=sys.version_info(major=3, minor=13, micro=1, releaselevel='final', serial=0)\n)\n    Warn that *name* is deprecated or should be removed.\n\n    RuntimeError is raised if *remove* specifies a major/minor tuple older than\n    the current Python version or the same version but past the alpha.\n\n    The *message* argument is formatted with *name* and *remove* as a Python\n    version tuple (e.g. (3, 11)).",
        "syntax": "Syntax: _deprecated(name, message='{name!r} is deprecated and slated for removal in Python {remove}', *, remove, _version=sys.version_info(major=3, minor=13, micro=1, releaselevel='final', serial=0))",
        "other-params": ""
    },
    "warnings._filters_mutated": {
        "function": "_filters_mutated()",
        "alias": "_filters_mutated",
        "help": "Help on built-in function _filters_mutated in module _warnings:\n\n_filters_mutated()",
        "syntax": "Syntax: _filters_mutated()",
        "other-params": ""
    },
    "warnings._formatwarning_orig": {
        "function": "_formatwarning_orig(message, category, filename, lineno, line=None)",
        "alias": "_formatwarning_orig",
        "help": "Help on function formatwarning in module warnings:\n\nformatwarning(message, category, filename, lineno, line=None)\n    Function to format a warning the standard way.",
        "syntax": "Syntax: _formatwarning_orig(message, category, filename, lineno, line=None)",
        "other-params": ""
    },
    "warnings._formatwarnmsg": {
        "function": "_formatwarnmsg(msg)",
        "alias": "_formatwarnmsg",
        "help": "Help on function _formatwarnmsg in module warnings:\n\n_formatwarnmsg(msg)\n    Function to format a warning the standard way.",
        "syntax": "Syntax: _formatwarnmsg(msg)",
        "other-params": ""
    },
    "warnings._formatwarnmsg_impl": {
        "function": "_formatwarnmsg_impl(msg)",
        "alias": "_formatwarnmsg_impl",
        "help": "Help on function _formatwarnmsg_impl in module warnings:\n\n_formatwarnmsg_impl(msg)",
        "syntax": "Syntax: _formatwarnmsg_impl(msg)",
        "other-params": ""
    },
    "warnings._getaction": {
        "function": "_getaction(action)",
        "alias": "_getaction",
        "help": "Help on function _getaction in module warnings:\n\n_getaction(action)\n    # Helper for _setoption()",
        "syntax": "Syntax: _getaction(action)",
        "other-params": ""
    },
    "warnings._getcategory": {
        "function": "_getcategory(category)",
        "alias": "_getcategory",
        "help": "Help on function _getcategory in module warnings:\n\n_getcategory(category)\n    # Helper for _setoption()",
        "syntax": "Syntax: _getcategory(category)",
        "other-params": ""
    },
    "warnings._is_filename_to_skip": {
        "function": "_is_filename_to_skip(filename, skip_file_prefixes)",
        "alias": "_is_filename_to_skip",
        "help": "Help on function _is_filename_to_skip in module warnings:\n\n_is_filename_to_skip(filename, skip_file_prefixes)",
        "syntax": "Syntax: _is_filename_to_skip(filename, skip_file_prefixes)",
        "other-params": ""
    },
    "warnings._is_internal_filename": {
        "function": "_is_internal_filename(filename)",
        "alias": "_is_internal_filename",
        "help": "Help on function _is_internal_filename in module warnings:\n\n_is_internal_filename(filename)",
        "syntax": "Syntax: _is_internal_filename(filename)",
        "other-params": ""
    },
    "warnings._is_internal_frame": {
        "function": "_is_internal_frame(frame)",
        "alias": "_is_internal_frame",
        "help": "Help on function _is_internal_frame in module warnings:\n\n_is_internal_frame(frame)\n    Signal whether the frame is an internal CPython implementation detail.",
        "syntax": "Syntax: _is_internal_frame(frame)",
        "other-params": ""
    },
    "warnings._next_external_frame": {
        "function": "_next_external_frame(frame, skip_file_prefixes)",
        "alias": "_next_external_frame",
        "help": "Help on function _next_external_frame in module warnings:\n\n_next_external_frame(frame, skip_file_prefixes)\n    Find the next frame that doesn't involve Python or user internals.",
        "syntax": "Syntax: _next_external_frame(frame, skip_file_prefixes)",
        "other-params": ""
    },
    "warnings._processoptions": {
        "function": "_processoptions(args)",
        "alias": "_processoptions",
        "help": "Help on function _processoptions in module warnings:\n\n_processoptions(args)\n    # Helper to process -W options passed via sys.warnoptions",
        "syntax": "Syntax: _processoptions(args)",
        "other-params": ""
    },
    "warnings._setoption": {
        "function": "_setoption(arg)",
        "alias": "_setoption",
        "help": "Help on function _setoption in module warnings:\n\n_setoption(arg)\n    # Helper for _processoptions()",
        "syntax": "Syntax: _setoption(arg)",
        "other-params": ""
    },
    "warnings._showwarning_orig": {
        "function": "_showwarning_orig(message, category, filename, lineno, file=None, line=None)",
        "alias": "_showwarning_orig",
        "help": "Help on function showwarning in module warnings:\n\nshowwarning(message, category, filename, lineno, file=None, line=None)\n    Hook to write a warning to a file; replace if you like.",
        "syntax": "Syntax: _showwarning_orig(message, category, filename, lineno, file=None, line=None)",
        "other-params": ""
    },
    "warnings._showwarnmsg": {
        "function": "_showwarnmsg(msg)",
        "alias": "_showwarnmsg",
        "help": "Help on function _showwarnmsg in module warnings:\n\n_showwarnmsg(msg)\n    Hook to write a warning to a file; replace if you like.",
        "syntax": "Syntax: _showwarnmsg(msg)",
        "other-params": ""
    },
    "warnings._showwarnmsg_impl": {
        "function": "_showwarnmsg_impl(msg)",
        "alias": "_showwarnmsg_impl",
        "help": "Help on function _showwarnmsg_impl in module warnings:\n\n_showwarnmsg_impl(msg)",
        "syntax": "Syntax: _showwarnmsg_impl(msg)",
        "other-params": ""
    },
    "warnings._warn_unawaited_coroutine": {
        "function": "_warn_unawaited_coroutine(coro)",
        "alias": "_warn_unawaited_coroutine",
        "help": "Help on function _warn_unawaited_coroutine in module warnings:\n\n_warn_unawaited_coroutine(coro)\n    # Private utility function called by _PyErr_WarnUnawaitedCoroutine",
        "syntax": "Syntax: _warn_unawaited_coroutine(coro)",
        "other-params": ""
    },
    "warnings.catch_warnings": {
        "function": "catch_warnings(*, record=False, module=None, action=None, category=<class 'Warning'>, lineno=0, append=False)",
        "alias": "catch_warnings",
        "help": "Help on class catch_warnings in module warnings:\n\nclass catch_warnings(builtins.object)\n |  catch_warnings(\n |      *,\n |      record=False,\n |      module=None,\n |      action=None,\n |      category=<class 'Warning'>,\n |      lineno=0,\n |      append=False\n |  )\n |\n |  A context manager that copies and restores the warnings filter upon\n |  exiting the context.\n |\n |  The 'record' argument specifies whether warnings should be captured by a\n |  custom implementation of warnings.showwarning() and be appended to a list\n |  returned by the context manager. Otherwise None is returned by the context\n |  manager. The objects appended to the list are arguments whose attributes\n |  mirror the arguments to showwarning().\n |\n |  The 'module' argument is to specify an alternative module to the module\n |  named 'warnings' and imported under that name. This argument is only useful\n |  when testing the warnings module itself.\n |\n |  If the 'action' argument is not None, the remaining arguments are passed\n |  to warnings.simplefilter() as if it were called immediately on entering the\n |  context.\n |\n |  Methods defined here:\n |\n |  __enter__(self)\n |\n |  __exit__(self, *exc_info)\n |\n |  __init__(\n |      self,\n |      *,\n |      record=False,\n |      module=None,\n |      action=None,\n |      category=<class 'Warning'>,\n |      lineno=0,\n |      append=False\n |  )\n |      Specify whether to record warnings and if an alternative module\n |      should be used other than sys.modules['warnings'].\n |\n |      For compatibility with Python 3.0, please consider all arguments to be\n |      keyword-only.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: catch_warnings(*, record=False, module=None, action=None, category=<class 'Warning'>, lineno=0, append=False)",
        "other-params": ""
    },
    "warnings.deprecated": {
        "function": "deprecated(message: str, /, *, category: type[Warning] | None = <class 'DeprecationWarning'>, stacklevel: int = 1) -> None",
        "alias": "deprecated",
        "help": "Help on class deprecated in module warnings:\n\nclass deprecated(builtins.object)\n |  deprecated(\n |      message: str,\n |      /,\n |      *,\n |      category: type[Warning] | None = <class 'DeprecationWarning'>,\n |      stacklevel: int = 1\n |  ) -> None\n |\n |  Indicate that a class, function or overload is deprecated.\n |\n |  When this decorator is applied to an object, the type checker\n |  will generate a diagnostic on usage of the deprecated object.\n |\n |  Usage:\n |\n |      @deprecated(\"Use B instead\")\n |      class A:\n |          pass\n |\n |      @deprecated(\"Use g instead\")\n |      def f():\n |          pass\n |\n |      @overload\n |      @deprecated(\"int support is deprecated\")\n |      def g(x: int) -> int: ...\n |      @overload\n |      def g(x: str) -> int: ...\n |\n |  The warning specified by *category* will be emitted at runtime\n |  on use of deprecated objects. For functions, that happens on calls;\n |  for classes, on instantiation and on creation of subclasses.\n |  If the *category* is ``None``, no warning is emitted at runtime.\n |  The *stacklevel* determines where the\n |  warning is emitted. If it is ``1`` (the default), the warning\n |  is emitted at the direct caller of the deprecated object; if it\n |  is higher, it is emitted further up the stack.\n |  Static type checker behavior is not affected by the *category*\n |  and *stacklevel* arguments.\n |\n |  The deprecation message passed to the decorator is saved in the\n |  ``__deprecated__`` attribute on the decorated object.\n |  If applied to an overload, the decorator\n |  must be after the ``@overload`` decorator for the attribute to\n |  exist on the overload as returned by ``get_overloads()``.\n |\n |  See PEP 702 for details.\n |\n |  Methods defined here:\n |\n |  __call__(self, arg, /)\n |      Call self as a function.\n |\n |  __init__(\n |      self,\n |      message: str,\n |      /,\n |      *,\n |      category: type[Warning] | None = <class 'DeprecationWarning'>,\n |      stacklevel: int = 1\n |  ) -> None\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: deprecated(message: str, /, *, category: type[Warning] | None = <class 'DeprecationWarning'>, stacklevel: int = 1) -> None",
        "other-params": ""
    },
    "warnings.filterwarnings": {
        "function": "filterwarnings(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
        "alias": "filterwarnings",
        "help": "Help on function filterwarnings in module warnings:\n\nfilterwarnings(\n    action,\n    message='',\n    category=<class 'Warning'>,\n    module='',\n    lineno=0,\n    append=False\n)\n    Insert an entry into the list of warnings filters (at the front).\n\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'message' -- a regex that the warning message must match\n    'category' -- a class that the warning must be a subclass of\n    'module' -- a regex that the module name must match\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters",
        "syntax": "Syntax: filterwarnings(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
        "other-params": ""
    },
    "warnings.formatwarning": {
        "function": "formatwarning(message, category, filename, lineno, line=None)",
        "alias": "formatwarning",
        "help": "Help on function formatwarning in module warnings:\n\nformatwarning(message, category, filename, lineno, line=None)\n    Function to format a warning the standard way.",
        "syntax": "Syntax: formatwarning(message, category, filename, lineno, line=None)",
        "other-params": ""
    },
    "warnings.resetwarnings": {
        "function": "resetwarnings()",
        "alias": "resetwarnings",
        "help": "Help on function resetwarnings in module warnings:\n\nresetwarnings()\n    Clear the list of warning filters, so that no filters are active.",
        "syntax": "Syntax: resetwarnings()",
        "other-params": ""
    },
    "warnings.showwarning": {
        "function": "showwarning(message, category, filename, lineno, file=None, line=None)",
        "alias": "showwarning",
        "help": "Help on function showwarning in module warnings:\n\nshowwarning(message, category, filename, lineno, file=None, line=None)\n    Hook to write a warning to a file; replace if you like.",
        "syntax": "Syntax: showwarning(message, category, filename, lineno, file=None, line=None)",
        "other-params": ""
    },
    "warnings.simplefilter": {
        "function": "simplefilter(action, category=<class 'Warning'>, lineno=0, append=False)",
        "alias": "simplefilter",
        "help": "Help on function simplefilter in module warnings:\n\nsimplefilter(action, category=<class 'Warning'>, lineno=0, append=False)\n    Insert a simple entry into the list of warnings filters (at the front).\n\n    A simple filter matches all modules and messages.\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'category' -- a class that the warning must be a subclass of\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters",
        "syntax": "Syntax: simplefilter(action, category=<class 'Warning'>, lineno=0, append=False)",
        "other-params": ""
    },
    "warnings.warn": {
        "function": "Error retrieving signature: <built-in function warn> builtin has invalid signature",
        "alias": "warn",
        "help": "Help on built-in function warn in module _warnings:\n\nwarn(message, category=None, stacklevel=1, source=None, *,\n     skip_file_prefixes=<unrepresentable>)\n    Issue a warning, or maybe ignore it or raise an exception.\n\n    message\n      Text of the warning message.\n    category\n      The Warning category subclass. Defaults to UserWarning.\n    stacklevel\n      How far up the call stack to make this warning appear. A value of 2 for\n      example attributes the warning to the caller of the code calling warn().\n    source\n      If supplied, the destroyed object which emitted a ResourceWarning\n    skip_file_prefixes\n      An optional tuple of module filename prefixes indicating frames to skip\n      during stacklevel computations for stack frame attribution.",
        "syntax": "Syntax: Error retrieving signature: <built-in function warn> builtin has invalid signature",
        "other-params": ""
    },
    "warnings.warn_explicit": {
        "function": "Error retrieving signature: <built-in function warn_explicit> builtin has invalid signature",
        "alias": "warn_explicit",
        "help": "Help on built-in function warn_explicit in module _warnings:\n\nwarn_explicit(message, category, filename, lineno,\n              module=<unrepresentable>, registry=None,\n              module_globals=None, source=None)\n    Issue a warning, or maybe ignore it or raise an exception.",
        "syntax": "Syntax: Error retrieving signature: <built-in function warn_explicit> builtin has invalid signature",
        "other-params": ""
    },
    "pathlib._local.Path": {
        "function": "Path(*args, **kwargs)",
        "alias": "Path",
        "help": "Help on class Path in module pathlib._local:\n\nclass Path(pathlib._abc.PathBase, PurePath)\n |  Path(*args, **kwargs)\n |\n |  PurePath subclass that can make system calls.\n |\n |  Path represents a filesystem path but unlike PurePath, also offers\n |  methods to do system calls on path objects. Depending on your system,\n |  instantiating a Path will return either a PosixPath or a WindowsPath\n |  object. You can also instantiate a PosixPath or WindowsPath directly,\n |  but cannot instantiate a WindowsPath on a POSIX system or vice versa.\n |\n |  Method resolution order:\n |      Path\n |      pathlib._abc.PathBase\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePath:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: Path(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local.PathBase": {
        "function": "PathBase(path, *paths)",
        "alias": "PathBase",
        "help": "Help on class PathBase in module pathlib._abc:\n\nclass PathBase(PurePathBase)\n |  PathBase(path, *paths)\n |\n |  Base class for concrete path objects.\n |\n |  This class provides dummy implementations for many methods that derived\n |  classes can override selectively; the default implementations raise\n |  UnsupportedOperation. The most basic methods, such as stat() and open(),\n |  directly raise UnsupportedOperation; these basic methods are called by\n |  other methods such as is_dir() and read_text().\n |\n |  The Path class derives this class to implement local filesystem paths.\n |  Users may derive their own classes to implement virtual filesystem paths,\n |  such as paths in archive files or on remote storage systems.\n |\n |  Method resolution order:\n |      PathBase\n |      PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=True)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=True)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePathBase:\n |\n |  __init__(self, path, *paths)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other)\n |      Return True if the path is relative to another path or False.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  relative_to(self, other, *, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePathBase:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePathBase:\n |\n |  parser = <pathlib._abc.ParserBase object>",
        "syntax": "Syntax: PathBase(path, *paths)",
        "other-params": ""
    },
    "pathlib._local.PosixPath": {
        "function": "PosixPath(*args, **kwargs)",
        "alias": "PosixPath",
        "help": "Help on class PosixPath in module pathlib._local:\n\nclass PosixPath(Path, PurePosixPath)\n |  PosixPath(*args, **kwargs)\n |\n |  Path subclass for non-Windows systems.\n |\n |  On a POSIX system, instantiating a Path should return this object.\n |\n |  Method resolution order:\n |      PosixPath\n |      Path\n |      pathlib._abc.PathBase\n |      PurePosixPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Path:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Path:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePosixPath:\n |\n |  parser = <module 'posixpath' (frozen)>\n |      Common operations on Posix pathnames.\n |\n |      Instead of importing this module directly, import os and refer to\n |      this module as os.path.  The \"os.path\" name is an alias for this\n |      module on Posix systems; on other systems (e.g. Windows),\n |      os.path provides the same operations in a manner specific to that\n |      platform, and is an alias to another module (e.g. ntpath).\n |\n |      Some of this can actually be useful on non-Posix systems too, e.g.\n |      for manipulation of the pathname component of URLs.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PosixPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local.PurePath": {
        "function": "PurePath(*args, **kwargs)",
        "alias": "PurePath",
        "help": "Help on class PurePath in module pathlib._local:\n\nclass PurePath(pathlib._abc.PurePathBase)\n |  PurePath(*args, **kwargs)\n |\n |  Base class for manipulating paths without I/O.\n |\n |  PurePath represents a filesystem path and offers operations which\n |  don't imply any actual filesystem I/O.  Depending on your system,\n |  instantiating a PurePath will return either a PurePosixPath or a\n |  PureWindowsPath object.  You can also instantiate either of these classes\n |  directly, regardless of your system.\n |\n |  Method resolution order:\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PurePath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local.PurePathBase": {
        "function": "PurePathBase(path, *paths)",
        "alias": "PurePathBase",
        "help": "Help on class PurePathBase in module pathlib._abc:\n\nclass PurePathBase(builtins.object)\n |  PurePathBase(path, *paths)\n |\n |  Base class for pure path objects.\n |\n |  This class *does not* provide several magic methods that are defined in\n |  its subclass PurePath. They are: __fspath__, __bytes__, __reduce__,\n |  __hash__, __eq__, __lt__, __le__, __gt__, __ge__. Its initializer and path\n |  joining methods accept only strings, not os.PathLike objects more broadly.\n |\n |  Methods defined here:\n |\n |  __init__(self, path, *paths)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other)\n |      Return True if the path is relative to another path or False.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  relative_to(self, other, *, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parser = <pathlib._abc.ParserBase object>",
        "syntax": "Syntax: PurePathBase(path, *paths)",
        "other-params": ""
    },
    "pathlib._local.PurePosixPath": {
        "function": "PurePosixPath(*args, **kwargs)",
        "alias": "PurePosixPath",
        "help": "Help on class PurePosixPath in module pathlib._local:\n\nclass PurePosixPath(PurePath)\n |  PurePosixPath(*args, **kwargs)\n |\n |  PurePath subclass for non-Windows systems.\n |\n |  On a POSIX system, instantiating a PurePath should return this object.\n |  However, you can also instantiate it directly on any system.\n |\n |  Method resolution order:\n |      PurePosixPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  parser = <module 'posixpath' (frozen)>\n |      Common operations on Posix pathnames.\n |\n |      Instead of importing this module directly, import os and refer to\n |      this module as os.path.  The \"os.path\" name is an alias for this\n |      module on Posix systems; on other systems (e.g. Windows),\n |      os.path provides the same operations in a manner specific to that\n |      platform, and is an alias to another module (e.g. ntpath).\n |\n |      Some of this can actually be useful on non-Posix systems too, e.g.\n |      for manipulation of the pathname component of URLs.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from PurePath:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PurePosixPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local.PureWindowsPath": {
        "function": "PureWindowsPath(*args, **kwargs)",
        "alias": "PureWindowsPath",
        "help": "Help on class PureWindowsPath in module pathlib._local:\n\nclass PureWindowsPath(PurePath)\n |  PureWindowsPath(*args, **kwargs)\n |\n |  PurePath subclass for Windows systems.\n |\n |  On a Windows system, instantiating a PurePath should return this object.\n |  However, you can also instantiate it directly on any system.\n |\n |  Method resolution order:\n |      PureWindowsPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from PurePath:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PureWindowsPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local.Sequence": {
        "function": "Sequence()",
        "alias": "Sequence",
        "help": "Help on class Sequence in module collections.abc:\n\nclass Sequence(Reversible, Collection)\n |  All the operations on a read-only sequence.\n |\n |  Concrete subclasses must override __new__ or __init__,\n |  __getitem__, and __len__.\n |\n |  Method resolution order:\n |      Sequence\n |      Reversible\n |      Collection\n |      Sized\n |      Iterable\n |      Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __contains__(self, value)\n |\n |  __getitem__(self, index)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset({'__getitem__', '__len__'})\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Sized:\n |\n |  __len__(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: Sequence()",
        "other-params": ""
    },
    "pathlib._local.UnsupportedOperation": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "alias": "UnsupportedOperation",
        "help": "Help on class UnsupportedOperation in module pathlib._abc:\n\nclass UnsupportedOperation(builtins.NotImplementedError)\n |  An exception that is raised when an unsupported operation is called on\n |  a path object.\n |\n |  Method resolution order:\n |      UnsupportedOperation\n |      builtins.NotImplementedError\n |      builtins.RuntimeError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.NotImplementedError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.NotImplementedError:\n |\n |  __new__(*args, **kwargs) class method of builtins.NotImplementedError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "other-params": ""
    },
    "pathlib._local.WindowsPath": {
        "function": "WindowsPath(*args, **kwargs)",
        "alias": "WindowsPath",
        "help": "Help on class WindowsPath in module pathlib._local:\n\nclass WindowsPath(Path, PureWindowsPath)\n |  WindowsPath(*args, **kwargs)\n |\n |  Path subclass for Windows systems.\n |\n |  On a Windows system, instantiating a Path should return this object.\n |\n |  Method resolution order:\n |      WindowsPath\n |      Path\n |      pathlib._abc.PathBase\n |      PureWindowsPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods inherited from Path:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Path:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from Path:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PureWindowsPath:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: WindowsPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib._local._PathParents": {
        "function": "_PathParents(path)",
        "alias": "_PathParents",
        "help": "Help on class _PathParents in module pathlib._local:\n\nclass _PathParents(collections.abc.Sequence)\n |  _PathParents(path)\n |\n |  This object provides sequence-like access to the logical ancestors\n |  of a path.  Don't try to construct it yourself.\n |\n |  Method resolution order:\n |      _PathParents\n |      collections.abc.Sequence\n |      collections.abc.Reversible\n |      collections.abc.Collection\n |      collections.abc.Sized\n |      collections.abc.Iterable\n |      collections.abc.Container\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __getitem__(self, idx)\n |\n |  __init__(self, path)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __len__(self)\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __abstractmethods__ = frozenset()\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from collections.abc.Sequence:\n |\n |  __contains__(self, value)\n |\n |  __iter__(self)\n |\n |  __reversed__(self)\n |\n |  count(self, value)\n |      S.count(value) -> integer -- return number of occurrences of value\n |\n |  index(self, value, start=0, stop=None)\n |      S.index(value, [start, [stop]]) -> integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |      Supporting start and stop arguments is optional, but\n |      recommended.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Reversible:\n |\n |  __subclasshook__(C)\n |      Abstract classes can override this to customize issubclass().\n |\n |      This is invoked early on by abc.ABCMeta.__subclasscheck__().\n |      It should return True, False or NotImplemented.  If it returns\n |      NotImplemented, the normal algorithm is used.  Otherwise, it\n |      overrides the normal algorithm (and the outcome is cached).\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from collections.abc.Iterable:\n |\n |  __class_getitem__ = GenericAlias(args, /)\n |      Represent a PEP 585 generic type\n |\n |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).",
        "syntax": "Syntax: _PathParents(path)",
        "other-params": ""
    },
    "pathlib._local._StringGlobber": {
        "function": "_StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "alias": "_StringGlobber",
        "help": "Help on class _StringGlobber in module glob:\n\nclass _StringGlobber(_Globber)\n |  _StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)\n |\n |  Method resolution order:\n |      _StringGlobber\n |      _Globber\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  add_slash(pathname)\n |\n |  concat_path = add(a, b, /)\n |      Same as a + b.\n |\n |  lstat(path, *, dir_fd=None)\n |      Perform a stat system call on the given path, without following symbolic links.\n |\n |      Like stat(), but do not follow symbolic links.\n |      Equivalent to stat(path, follow_symlinks=False).\n |\n |  scandir(path=None)\n |      Return an iterator of DirEntry objects for given path.\n |\n |      path can be specified as either str, bytes, or a path-like object.  If path\n |      is bytes, the names of yielded DirEntry objects will also be bytes; in\n |      all other circumstances they will be str.\n |\n |      If path is None, uses the path='.'.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parse_entry = operator.attrgetter('path')\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from _Globber:\n |\n |  __init__(self, sep, case_sensitive, case_pedantic=False, recursive=False)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  compile(self, pat)\n |\n |  literal_selector(self, part, parts)\n |      Returns a function that selects a literal descendant of a path.\n |\n |  recursive_selector(self, part, parts)\n |      Returns a function that selects a given path and all its children,\n |      recursively, filtering by pattern.\n |\n |  select_exists(self, path, exists=False)\n |      Yields the given path, if it exists.\n |\n |  selector(self, parts)\n |      Returns a function that selects from a given path, walking and\n |      filtering according to the glob-style pattern parts in *parts*.\n |\n |  special_selector(self, part, parts)\n |      Returns a function that selects special children of the given path.\n |\n |  wildcard_selector(self, part, parts)\n |      Returns a function that selects direct children of a given path,\n |      filtering by pattern.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from _Globber:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _StringGlobber(sep, case_sensitive, case_pedantic=False, recursive=False)",
        "other-params": ""
    },
    "pathlib._local.chain": {
        "function": "chain(*iterables)",
        "alias": "chain",
        "help": "Help on class chain in module itertools:\n\nclass chain(builtins.object)\n |  chain(*iterables)\n |\n |  Return a chain object whose .__next__() method returns elements from the\n |  first iterable until it is exhausted, then elements from the next\n |  iterable, until all of the iterables are exhausted.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  from_iterable(iterable, /)\n |      Alternative chain() constructor taking a single iterable argument that evaluates lazily.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: chain(*iterables)",
        "other-params": ""
    },
    "pathlib.Path": {
        "function": "Path(*args, **kwargs)",
        "alias": "Path",
        "help": "Help on class Path in module pathlib._local:\n\nclass Path(pathlib._abc.PathBase, PurePath)\n |  Path(*args, **kwargs)\n |\n |  PurePath subclass that can make system calls.\n |\n |  Path represents a filesystem path but unlike PurePath, also offers\n |  methods to do system calls on path objects. Depending on your system,\n |  instantiating a Path will return either a PosixPath or a WindowsPath\n |  object. You can also instantiate a PosixPath or WindowsPath directly,\n |  but cannot instantiate a WindowsPath on a POSIX system or vice versa.\n |\n |  Method resolution order:\n |      Path\n |      pathlib._abc.PathBase\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePath:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: Path(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib.PosixPath": {
        "function": "PosixPath(*args, **kwargs)",
        "alias": "PosixPath",
        "help": "Help on class PosixPath in module pathlib._local:\n\nclass PosixPath(Path, PurePosixPath)\n |  PosixPath(*args, **kwargs)\n |\n |  Path subclass for non-Windows systems.\n |\n |  On a POSIX system, instantiating a Path should return this object.\n |\n |  Method resolution order:\n |      PosixPath\n |      Path\n |      pathlib._abc.PathBase\n |      PurePosixPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from Path:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Path:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePosixPath:\n |\n |  parser = <module 'posixpath' (frozen)>\n |      Common operations on Posix pathnames.\n |\n |      Instead of importing this module directly, import os and refer to\n |      this module as os.path.  The \"os.path\" name is an alias for this\n |      module on Posix systems; on other systems (e.g. Windows),\n |      os.path provides the same operations in a manner specific to that\n |      platform, and is an alias to another module (e.g. ntpath).\n |\n |      Some of this can actually be useful on non-Posix systems too, e.g.\n |      for manipulation of the pathname component of URLs.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PosixPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib.PurePath": {
        "function": "PurePath(*args, **kwargs)",
        "alias": "PurePath",
        "help": "Help on class PurePath in module pathlib._local:\n\nclass PurePath(pathlib._abc.PurePathBase)\n |  PurePath(*args, **kwargs)\n |\n |  Base class for manipulating paths without I/O.\n |\n |  PurePath represents a filesystem path and offers operations which\n |  don't imply any actual filesystem I/O.  Depending on your system,\n |  instantiating a PurePath will return either a PurePosixPath or a\n |  PureWindowsPath object.  You can also instantiate either of these classes\n |  directly, regardless of your system.\n |\n |  Method resolution order:\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PurePath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib.PurePosixPath": {
        "function": "PurePosixPath(*args, **kwargs)",
        "alias": "PurePosixPath",
        "help": "Help on class PurePosixPath in module pathlib._local:\n\nclass PurePosixPath(PurePath)\n |  PurePosixPath(*args, **kwargs)\n |\n |  PurePath subclass for non-Windows systems.\n |\n |  On a POSIX system, instantiating a PurePath should return this object.\n |  However, you can also instantiate it directly on any system.\n |\n |  Method resolution order:\n |      PurePosixPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  parser = <module 'posixpath' (frozen)>\n |      Common operations on Posix pathnames.\n |\n |      Instead of importing this module directly, import os and refer to\n |      this module as os.path.  The \"os.path\" name is an alias for this\n |      module on Posix systems; on other systems (e.g. Windows),\n |      os.path provides the same operations in a manner specific to that\n |      platform, and is an alias to another module (e.g. ntpath).\n |\n |      Some of this can actually be useful on non-Posix systems too, e.g.\n |      for manipulation of the pathname component of URLs.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from PurePath:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PurePosixPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib.PureWindowsPath": {
        "function": "PureWindowsPath(*args, **kwargs)",
        "alias": "PureWindowsPath",
        "help": "Help on class PureWindowsPath in module pathlib._local:\n\nclass PureWindowsPath(PurePath)\n |  PureWindowsPath(*args, **kwargs)\n |\n |  PurePath subclass for Windows systems.\n |\n |  On a Windows system, instantiating a PurePath should return this object.\n |  However, you can also instantiate it directly on any system.\n |\n |  Method resolution order:\n |      PureWindowsPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Data and other attributes defined here:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __init__(self, *args)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  as_uri(self)\n |      Return the path as a URI.\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from PurePath:\n |\n |  __new__(cls, *args, **kwargs)\n |      Construct a PurePath from one or several strings and or existing\n |      PurePath objects.  The strings and path objects are combined so as\n |      to yield a canonicalized path, which is incorporated into the\n |      new PurePath object.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: PureWindowsPath(*args, **kwargs)",
        "other-params": ""
    },
    "pathlib.UnsupportedOperation": {
        "function": "Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "alias": "UnsupportedOperation",
        "help": "Help on class UnsupportedOperation in module pathlib._abc:\n\nclass UnsupportedOperation(builtins.NotImplementedError)\n |  An exception that is raised when an unsupported operation is called on\n |  a path object.\n |\n |  Method resolution order:\n |      UnsupportedOperation\n |      builtins.NotImplementedError\n |      builtins.RuntimeError\n |      builtins.Exception\n |      builtins.BaseException\n |      builtins.object\n |\n |  Data descriptors defined here:\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.NotImplementedError:\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.NotImplementedError:\n |\n |  __new__(*args, **kwargs) class method of builtins.NotImplementedError\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.BaseException:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __reduce__(self, /)\n |      Helper for pickle.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __setstate__(self, object, /)\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  add_note(self, object, /)\n |      Exception.add_note(note) --\n |      add a note to the exception\n |\n |  with_traceback(self, object, /)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from builtins.BaseException:\n |\n |  __cause__\n |      exception cause\n |\n |  __context__\n |      exception context\n |\n |  __dict__\n |\n |  __suppress_context__\n |\n |  __traceback__\n |\n |  args",
        "syntax": "Syntax: Error retrieving signature: no signature found for builtin type <class 'pathlib._abc.UnsupportedOperation'>",
        "other-params": ""
    },
    "pathlib.WindowsPath": {
        "function": "WindowsPath(*args, **kwargs)",
        "alias": "WindowsPath",
        "help": "Help on class WindowsPath in module pathlib._local:\n\nclass WindowsPath(Path, PureWindowsPath)\n |  WindowsPath(*args, **kwargs)\n |\n |  Path subclass for Windows systems.\n |\n |  On a Windows system, instantiating a Path should return this object.\n |\n |  Method resolution order:\n |      WindowsPath\n |      Path\n |      pathlib._abc.PathBase\n |      PureWindowsPath\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods inherited from Path:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from Path:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Static methods inherited from Path:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PureWindowsPath:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: WindowsPath(*args, **kwargs)",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.ModuleSpec": {
        "function": "ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "alias": "ModuleSpec",
        "help": "Help on class ModuleSpec in module importlib._bootstrap:\n\nclass ModuleSpec(builtins.object)\n |  ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)\n |\n |  The specification for a module, used for loading.\n |\n |  A module's spec is the source for information about the module.  For\n |  data associated with the module, including source, use the spec's\n |  loader.\n |\n |  `name` is the absolute name of the module.  `loader` is the loader\n |  to use when loading the module.  `parent` is the name of the\n |  package the module is in.  The parent is derived from the name.\n |\n |  `is_package` determines if the module is considered a package or\n |  not.  On modules this is reflected by the `__path__` attribute.\n |\n |  `origin` is the specific location used by the loader from which to\n |  load the module, if that information is available.  When filename is\n |  set, origin will match.\n |\n |  `has_location` indicates that a spec's \"origin\" reflects a location.\n |  When this is True, `__file__` attribute of the module is set.\n |\n |  `cached` is the location of the cached bytecode file, if any.  It\n |  corresponds to the `__cached__` attribute.\n |\n |  `submodule_search_locations` is the sequence of path entries to\n |  search when importing submodules.  If set, is_package should be\n |  True--and False otherwise.\n |\n |  Packages are simply modules that (may) have submodules.  If a spec\n |  has a non-None value in `submodule_search_locations`, the import\n |  system will consider modules loaded from the spec as packages.\n |\n |  Only finders (see importlib.abc.MetaPathFinder and\n |  importlib.abc.PathEntryFinder) should modify ModuleSpec instances.\n |\n |  Methods defined here:\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __init__(self, name, loader, *, origin=None, loader_state=None, is_package=None)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |\n |  parent\n |      The name of the module's parent.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  cached\n |\n |  has_location\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None",
        "syntax": "Syntax: ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.Path": {
        "function": "Path(*args, **kwargs)",
        "alias": "Path",
        "help": "Help on class Path in module pathlib._local:\n\nclass Path(pathlib._abc.PathBase, PurePath)\n |  Path(*args, **kwargs)\n |\n |  PurePath subclass that can make system calls.\n |\n |  Path represents a filesystem path but unlike PurePath, also offers\n |  methods to do system calls on path objects. Depending on your system,\n |  instantiating a Path will return either a PosixPath or a WindowsPath\n |  object. You can also instantiate a PosixPath or WindowsPath directly,\n |  but cannot instantiate a WindowsPath on a POSIX system or vice versa.\n |\n |  Method resolution order:\n |      Path\n |      pathlib._abc.PathBase\n |      PurePath\n |      pathlib._abc.PurePathBase\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  absolute(self)\n |      Return an absolute version of this path\n |      No normalization or symlink resolution is performed.\n |\n |      Use resolve() to resolve symlinks and remove '..' segments.\n |\n |  as_uri(self) from pathlib._local.PurePath\n |      Return the path as a URI.\n |\n |  chmod(self, mode, *, follow_symlinks=True)\n |      Change the permissions of the path, like os.chmod().\n |\n |  expanduser(self)\n |      Return a new path with expanded ~ and ~user constructs\n |      (as returned by os.path.expanduser)\n |\n |  glob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Iterate over this subtree and yield all existing files (of any\n |      kind, including directories) matching the given relative pattern.\n |\n |  hardlink_to(self, target)\n |      Make this path a hard link pointing to the same file as *target*.\n |\n |      Note the order of arguments (self, target) is the reverse of os.link's.\n |\n |  is_junction(self)\n |      Whether this path is a junction.\n |\n |  is_mount(self)\n |      Check if this path is a mount point\n |\n |  iterdir(self)\n |      Yield path objects of the directory contents.\n |\n |      The children are yielded in arbitrary order, and the\n |      special entries '.' and '..' are not included.\n |\n |  mkdir(self, mode=511, parents=False, exist_ok=False)\n |      Create a new directory at this given path.\n |\n |  open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)\n |      Open the file pointed to by this path and return a file object, as\n |      the built-in open() function does.\n |\n |  read_text(self, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, read it, and close the file.\n |\n |  readlink(self)\n |      Return the path to which the symbolic link points.\n |\n |  rename(self, target)\n |      Rename this path to the target path.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  replace(self, target)\n |      Rename this path to the target path, overwriting if that path exists.\n |\n |      The target path may be absolute or relative. Relative paths are\n |      interpreted relative to the current working directory, *not* the\n |      directory of the Path object.\n |\n |      Returns the new Path instance pointing to the target path.\n |\n |  resolve(self, strict=False)\n |      Make the path absolute, resolving all symlinks on the way and also\n |      normalizing it.\n |\n |  rglob(self, pattern, *, case_sensitive=None, recurse_symlinks=False)\n |      Recursively yield all existing files (of any kind, including\n |      directories) matching the given relative pattern, anywhere in\n |      this subtree.\n |\n |  rmdir(self)\n |      Remove this directory.  The directory must be empty.\n |\n |  stat(self, *, follow_symlinks=True)\n |      Return the result of the stat() system call on this path, like\n |      os.stat() does.\n |\n |  symlink_to(self, target, target_is_directory=False)\n |      Make this path a symlink pointing to the target path.\n |      Note the order of arguments (link, target) is the reverse of os.symlink.\n |\n |  touch(self, mode=438, exist_ok=True)\n |      Create this file with the given access mode, if it doesn't exist.\n |\n |  unlink(self, missing_ok=False)\n |      Remove this file or link.\n |      If the path is a directory, use rmdir() instead.\n |\n |  walk(self, top_down=True, on_error=None, follow_symlinks=False)\n |      Walk the directory tree from this directory, similar to os.walk().\n |\n |  write_text(self, data, encoding=None, errors=None, newline=None)\n |      Open the file in text mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  from_uri(uri)\n |      Return a new path from the given 'file' URI.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(cls, *args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PathBase:\n |\n |  exists(self, *, follow_symlinks=True)\n |      Whether this path exists.\n |\n |      This method normally follows symlinks; to check whether a symlink exists,\n |      add the argument follow_symlinks=False.\n |\n |  group(self, *, follow_symlinks=True)\n |      Return the group name of the file gid.\n |\n |  is_block_device(self)\n |      Whether this path is a block device.\n |\n |  is_char_device(self)\n |      Whether this path is a character device.\n |\n |  is_dir(self, *, follow_symlinks=True)\n |      Whether this path is a directory.\n |\n |  is_fifo(self)\n |      Whether this path is a FIFO.\n |\n |  is_file(self, *, follow_symlinks=True)\n |      Whether this path is a regular file (also True for symlinks pointing\n |      to regular files).\n |\n |  is_socket(self)\n |      Whether this path is a socket.\n |\n |  is_symlink(self)\n |      Whether this path is a symbolic link.\n |\n |  lchmod(self, mode)\n |      Like chmod(), except if the path points to a symlink, the symlink's\n |      permissions are changed, rather than its target's.\n |\n |  lstat(self)\n |      Like stat(), except if the path points to a symlink, the symlink's\n |      status information is returned, rather than its target's.\n |\n |  owner(self, *, follow_symlinks=True)\n |      Return the login name of the file owner.\n |\n |  read_bytes(self)\n |      Open the file in bytes mode, read it, and close the file.\n |\n |  samefile(self, other_path)\n |      Return whether other_path is the same or not as this file\n |      (as returned by os.path.samefile()).\n |\n |  write_bytes(self, data)\n |      Open the file in bytes mode, write to it, and close the file.\n |\n |  ----------------------------------------------------------------------\n |  Class methods inherited from pathlib._abc.PathBase:\n |\n |  cwd()\n |      Return a new path pointing to the current working directory.\n |\n |  home()\n |      Return a new path pointing to expanduser('~').\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from PurePath:\n |\n |  __bytes__(self)\n |      Return the bytes representation of the path.  This is only\n |      recommended to use under Unix.\n |\n |  __eq__(self, other)\n |      Return self==value.\n |\n |  __fspath__(self)\n |\n |  __ge__(self, other)\n |      Return self>=value.\n |\n |  __gt__(self, other)\n |      Return self>value.\n |\n |  __hash__(self)\n |      Return hash(self).\n |\n |  __le__(self, other)\n |      Return self<=value.\n |\n |  __lt__(self, other)\n |      Return self<value.\n |\n |  __reduce__(self)\n |      Helper for pickle.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  __rtruediv__(self, key)\n |\n |  __str__(self)\n |      Return the string representation of the path, suitable for\n |      passing to system calls.\n |\n |  __truediv__(self, key)\n |\n |  is_absolute(self)\n |      True if the path is absolute (has both a root and, if applicable,\n |      a drive).\n |\n |  is_relative_to(self, other, /, *_deprecated)\n |      Return True if the path is relative to another path or False.\n |\n |  is_reserved(self)\n |      Return True if the path contains one of the special names reserved\n |      by the system, if any.\n |\n |  joinpath(self, *pathsegments)\n |      Combine this path with one or several arguments, and return a\n |      new path representing either a subpath (if all arguments are relative\n |      paths) or a totally different path (if one of the arguments is\n |      anchored).\n |\n |  relative_to(self, other, /, *_deprecated, walk_up=False)\n |      Return the relative path to another path identified by the passed\n |      arguments.  If the operation is not possible (because this is not\n |      related to the other path), raise ValueError.\n |\n |      The *walk_up* parameter controls whether `..` may be used to resolve\n |      the path.\n |\n |  with_name(self, name)\n |      Return a new path with the file name changed.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from PurePath:\n |\n |  anchor\n |      The concatenation of the drive and root, or ''.\n |\n |  drive\n |      The drive prefix (letter or UNC path), if any.\n |\n |  name\n |      The final path component, if any.\n |\n |  parent\n |      The logical parent of the path.\n |\n |  parents\n |      A sequence of this path's logical parents.\n |\n |  parts\n |      An object providing sequence-like access to the\n |      components in the filesystem path.\n |\n |  root\n |      The root of the path, if any.\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from PurePath:\n |\n |  parser = <module 'ntpath' (frozen)>\n |      Common pathname manipulations, WindowsNT/95 version.\n |\n |      Instead of importing this module directly, import os and refer to this\n |      module as os.path.\n |\n |\n |  ----------------------------------------------------------------------\n |  Methods inherited from pathlib._abc.PurePathBase:\n |\n |  as_posix(self)\n |      Return the string representation of the path with forward (/)\n |      slashes.\n |\n |  full_match(self, pattern, *, case_sensitive=None)\n |      Return True if this path matches the given glob-style pattern. The\n |      pattern is matched against the entire path.\n |\n |  match(self, path_pattern, *, case_sensitive=None)\n |      Return True if this path matches the given pattern. If the pattern is\n |      relative, matching is done from the right; otherwise, the entire path\n |      is matched. The recursive wildcard '**' is *not* supported by this\n |      method.\n |\n |  with_segments(self, *pathsegments)\n |      Construct a new path object from any number of path-like objects.\n |      Subclasses may override this method to customize how new path objects\n |      are created from methods like `iterdir()`.\n |\n |  with_stem(self, stem)\n |      Return a new path with the stem changed.\n |\n |  with_suffix(self, suffix)\n |      Return a new path with the file suffix changed.  If the path\n |      has no suffix, add given suffix.  If the given suffix is an empty\n |      string, remove the suffix from the path.\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from pathlib._abc.PurePathBase:\n |\n |  stem\n |      The final path component, minus its last suffix.\n |\n |  suffix\n |      The final component's last suffix, if any.\n |\n |      This includes the leading period. For example: '.txt'\n |\n |  suffixes\n |      A list of the final component's suffixes, if any.\n |\n |      These include the leading periods. For example: ['.tar', '.gz']",
        "syntax": "Syntax: Path(*args, **kwargs)",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.PathFinder": {
        "function": "PathFinder()",
        "alias": "PathFinder",
        "help": "Help on class PathFinder in module importlib._bootstrap_external:\n\nclass PathFinder(builtins.object)\n |  Meta path finder for sys.path and package __path__ attributes.\n |\n |  Class methods defined here:\n |\n |  find_spec(fullname, path=None, target=None)\n |      Try to find a spec for 'fullname' on sys.path or 'path'.\n |\n |      The search is based on sys.path_hooks and sys.path_importer_cache.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  find_distributions(*args, **kwargs)\n |      Find distributions.\n |\n |      Return an iterable of all Distribution instances capable of\n |      loading the metadata for packages matching ``context.name``\n |      (or all names if ``None`` indicated) along the paths in the list\n |      of directories ``context.path``.\n |\n |  invalidate_caches()\n |      Call the invalidate_caches() method on all path entry finders\n |      stored in sys.path_importer_cache (where implemented).\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: PathFinder()",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder._EditableFinder": {
        "function": "_EditableFinder()",
        "alias": "_EditableFinder",
        "help": "Help on class _EditableFinder in module __editable___pyme_0_1_0_finder:\n\nclass _EditableFinder(builtins.object)\n |  Class methods defined here:\n |\n |  find_spec(fullname: 'str', path=None, target=None) -> 'ModuleSpec | None'\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _EditableFinder()",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder._EditableNamespaceFinder": {
        "function": "_EditableNamespaceFinder()",
        "alias": "_EditableNamespaceFinder",
        "help": "Help on class _EditableNamespaceFinder in module __editable___pyme_0_1_0_finder:\n\nclass _EditableNamespaceFinder(builtins.object)\n |  Class methods defined here:\n |\n |  find_module(_fullname) -> 'None'\n |\n |  find_spec(fullname: 'str', target=None) -> 'ModuleSpec | None'\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _EditableNamespaceFinder()",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.chain": {
        "function": "chain(*iterables)",
        "alias": "chain",
        "help": "Help on class chain in module itertools:\n\nclass chain(builtins.object)\n |  chain(*iterables)\n |\n |  Return a chain object whose .__next__() method returns elements from the\n |  first iterable until it is exhausted, then elements from the next\n |  iterable, until all of the iterables are exhausted.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  __setstate__(self, object, /)\n |      Set state information for unpickling.\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  __class_getitem__(object, /)\n |      See PEP 585\n |\n |  from_iterable(iterable, /)\n |      Alternative chain() constructor taking a single iterable argument that evaluates lazily.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.",
        "syntax": "Syntax: chain(*iterables)",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.install": {
        "function": "install()",
        "alias": "install",
        "help": "Help on function install in module __editable___pyme_0_1_0_finder:\n\ninstall()",
        "syntax": "Syntax: install()",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.module_suffixes": {
        "function": "module_suffixes()",
        "alias": "module_suffixes",
        "help": "Help on function all_suffixes in module importlib.machinery:\n\nall_suffixes()\n    Returns a list of all recognized module suffixes for this process",
        "syntax": "Syntax: module_suffixes()",
        "other-params": ""
    },
    "__editable___pyme_0_1_0_finder.spec_from_file_location": {
        "function": "spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "alias": "spec_from_file_location",
        "help": "Help on function spec_from_file_location in module importlib._bootstrap_external:\n\nspec_from_file_location(\n    name,\n    location=None,\n    *,\n    loader=None,\n    submodule_search_locations=<object object at 0x000001950D0901C0>\n)\n    Return a module spec based on a file location.\n\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n\n    The loader must take a spec as its only __init__() arg.",
        "syntax": "Syntax: spec_from_file_location(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x000001950D0901C0>)",
        "other-params": ""
    },
    "_distutils_hack.DistutilsMetaFinder": {
        "function": "DistutilsMetaFinder()",
        "alias": "DistutilsMetaFinder",
        "help": "Help on class DistutilsMetaFinder in module _distutils_hack:\n\nclass DistutilsMetaFinder(builtins.object)\n |  Methods defined here:\n |\n |  find_spec(self, fullname, path, target=None)\n |\n |  spec_for_distutils(self)\n |\n |  spec_for_pip(self)\n |      Ensure stdlib distutils when running under pip.\n |      See pypa/pip#8761 for rationale.\n |\n |  spec_for_sensitive_tests(self)\n |      Ensure stdlib distutils when running select tests under CPython.\n |\n |      python/cpython#91169\n |\n |  spec_for_test.test_distutils = spec_for_sensitive_tests(self)\n |\n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |\n |  pip_imported_during_build()\n |      Detect if pip is being imported in a build script. Ref #2355.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  frame_file_is_setup(frame)\n |      Return True if the indicated frame suggests a setup.py file.\n |\n |  is_cpython()\n |      Suppress supplying distutils for CPython (build and tests).\n |      Ref #2965 and #3007.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  sensitive_tests = ['test.test_distutils']",
        "syntax": "Syntax: DistutilsMetaFinder()",
        "other-params": ""
    },
    "_distutils_hack._TrivialRe": {
        "function": "_TrivialRe(*patterns) -> None",
        "alias": "_TrivialRe",
        "help": "Help on class _TrivialRe in module _distutils_hack:\n\nclass _TrivialRe(builtins.object)\n |  _TrivialRe(*patterns) -> None\n |\n |  Methods defined here:\n |\n |  __init__(self, *patterns) -> None\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  match(self, string)\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: _TrivialRe(*patterns) -> None",
        "other-params": ""
    },
    "_distutils_hack._remove_shim": {
        "function": "_remove_shim()",
        "alias": "_remove_shim",
        "help": "Help on function _remove_shim in module _distutils_hack:\n\n_remove_shim()",
        "syntax": "Syntax: _remove_shim()",
        "other-params": ""
    },
    "_distutils_hack.add_shim": {
        "function": "add_shim()",
        "alias": "add_shim",
        "help": "Help on function add_shim in module _distutils_hack:\n\nadd_shim()",
        "syntax": "Syntax: add_shim()",
        "other-params": ""
    },
    "_distutils_hack.clear_distutils": {
        "function": "clear_distutils()",
        "alias": "clear_distutils",
        "help": "Help on function clear_distutils in module _distutils_hack:\n\nclear_distutils()",
        "syntax": "Syntax: clear_distutils()",
        "other-params": ""
    },
    "_distutils_hack.do_override": {
        "function": "do_override()",
        "alias": "do_override",
        "help": "Help on function do_override in module _distutils_hack:\n\ndo_override()\n    Ensure that the local copy of distutils is preferred over stdlib.\n\n    See https://github.com/pypa/setuptools/issues/417#issuecomment-392298401\n    for more motivation.",
        "syntax": "Syntax: do_override()",
        "other-params": ""
    },
    "_distutils_hack.enabled": {
        "function": "enabled()",
        "alias": "enabled",
        "help": "Help on function enabled in module _distutils_hack:\n\nenabled()\n    Allow selection of distutils by environment variable.",
        "syntax": "Syntax: enabled()",
        "other-params": ""
    },
    "_distutils_hack.ensure_local_distutils": {
        "function": "ensure_local_distutils()",
        "alias": "ensure_local_distutils",
        "help": "Help on function ensure_local_distutils in module _distutils_hack:\n\nensure_local_distutils()",
        "syntax": "Syntax: ensure_local_distutils()",
        "other-params": ""
    },
    "_distutils_hack.insert_shim": {
        "function": "insert_shim()",
        "alias": "insert_shim",
        "help": "Help on function insert_shim in module _distutils_hack:\n\ninsert_shim()",
        "syntax": "Syntax: insert_shim()",
        "other-params": ""
    },
    "_distutils_hack.shim": {
        "function": "shim()",
        "alias": "shim",
        "help": "Help on class shim in module _distutils_hack:\n\nclass shim(builtins.object)\n |  Methods defined here:\n |\n |  __enter__(self) -> None\n |\n |  __exit__(self, exc: object, value: object, tb: object) -> None\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object",
        "syntax": "Syntax: shim()",
        "other-params": ""
    },
    "_distutils_hack.warn_distutils_present": {
        "function": "warn_distutils_present()",
        "alias": "warn_distutils_present",
        "help": "Help on function warn_distutils_present in module _distutils_hack:\n\nwarn_distutils_present()",
        "syntax": "Syntax: warn_distutils_present()",
        "other-params": ""
    },
    "site._get_implementation": {
        "function": "_get_implementation()",
        "alias": "_get_implementation",
        "help": "Help on function _get_implementation in module site:\n\n_get_implementation()",
        "syntax": "Syntax: _get_implementation()",
        "other-params": ""
    },
    "site._get_path": {
        "function": "_get_path(userbase)",
        "alias": "_get_path",
        "help": "Help on function _get_path in module site:\n\n_get_path(userbase)",
        "syntax": "Syntax: _get_path(userbase)",
        "other-params": ""
    },
    "site._getuserbase": {
        "function": "_getuserbase()",
        "alias": "_getuserbase",
        "help": "Help on function _getuserbase in module site:\n\n_getuserbase()",
        "syntax": "Syntax: _getuserbase()",
        "other-params": ""
    },
    "site._init_pathinfo": {
        "function": "_init_pathinfo()",
        "alias": "_init_pathinfo",
        "help": "Help on function _init_pathinfo in module site:\n\n_init_pathinfo()\n    Return a set containing all existing file system items from sys.path.",
        "syntax": "Syntax: _init_pathinfo()",
        "other-params": ""
    },
    "site._script": {
        "function": "_script()",
        "alias": "_script",
        "help": "Help on function _script in module site:\n\n_script()",
        "syntax": "Syntax: _script()",
        "other-params": ""
    },
    "site._trace": {
        "function": "_trace(message)",
        "alias": "_trace",
        "help": "Help on function _trace in module site:\n\n_trace(message)",
        "syntax": "Syntax: _trace(message)",
        "other-params": ""
    },
    "site.abs_paths": {
        "function": "abs_paths()",
        "alias": "abs_paths",
        "help": "Help on function abs_paths in module site:\n\nabs_paths()\n    Set all module __file__ and __cached__ attributes to an absolute path",
        "syntax": "Syntax: abs_paths()",
        "other-params": ""
    },
    "site.addpackage": {
        "function": "addpackage(sitedir, name, known_paths)",
        "alias": "addpackage",
        "help": "Help on function addpackage in module site:\n\naddpackage(sitedir, name, known_paths)\n    Process a .pth file within the site-packages directory:\n    For each line in the file, either combine it with sitedir to a path\n    and add that to known_paths, or execute it if it starts with 'import '.",
        "syntax": "Syntax: addpackage(sitedir, name, known_paths)",
        "other-params": ""
    },
    "site.addsitedir": {
        "function": "addsitedir(sitedir, known_paths=None)",
        "alias": "addsitedir",
        "help": "Help on function addsitedir in module site:\n\naddsitedir(sitedir, known_paths=None)\n    Add 'sitedir' argument to sys.path if missing and handle .pth files in\n    'sitedir'",
        "syntax": "Syntax: addsitedir(sitedir, known_paths=None)",
        "other-params": ""
    },
    "site.addsitepackages": {
        "function": "addsitepackages(known_paths, prefixes=None)",
        "alias": "addsitepackages",
        "help": "Help on function addsitepackages in module site:\n\naddsitepackages(known_paths, prefixes=None)\n    Add site-packages to sys.path",
        "syntax": "Syntax: addsitepackages(known_paths, prefixes=None)",
        "other-params": ""
    },
    "site.addusersitepackages": {
        "function": "addusersitepackages(known_paths)",
        "alias": "addusersitepackages",
        "help": "Help on function addusersitepackages in module site:\n\naddusersitepackages(known_paths)\n    Add a per user site-package to sys.path\n\n    Each user has its own python directory with site-packages in the\n    home directory.",
        "syntax": "Syntax: addusersitepackages(known_paths)",
        "other-params": ""
    },
    "site.check_enableusersite": {
        "function": "check_enableusersite()",
        "alias": "check_enableusersite",
        "help": "Help on function check_enableusersite in module site:\n\ncheck_enableusersite()\n    Check if user site directory is safe for inclusion\n\n    The function tests for the command line flag (including environment var),\n    process uid/gid equal to effective uid/gid.\n\n    None: Disabled for security reasons\n    False: Disabled by user (command line option)\n    True: Safe and enabled",
        "syntax": "Syntax: check_enableusersite()",
        "other-params": ""
    },
    "site.enablerlcompleter": {
        "function": "enablerlcompleter()",
        "alias": "enablerlcompleter",
        "help": "Help on function enablerlcompleter in module site:\n\nenablerlcompleter()\n    Enable default readline configuration on interactive prompts, by\n    registering a sys.__interactivehook__.",
        "syntax": "Syntax: enablerlcompleter()",
        "other-params": ""
    },
    "site.execsitecustomize": {
        "function": "execsitecustomize()",
        "alias": "execsitecustomize",
        "help": "Help on function execsitecustomize in module site:\n\nexecsitecustomize()\n    Run custom site specific code, if available.",
        "syntax": "Syntax: execsitecustomize()",
        "other-params": ""
    },
    "site.execusercustomize": {
        "function": "execusercustomize()",
        "alias": "execusercustomize",
        "help": "Help on function execusercustomize in module site:\n\nexecusercustomize()\n    Run custom user specific code, if available.",
        "syntax": "Syntax: execusercustomize()",
        "other-params": ""
    },
    "site.gethistoryfile": {
        "function": "gethistoryfile()",
        "alias": "gethistoryfile",
        "help": "Help on function gethistoryfile in module site:\n\ngethistoryfile()\n    Check if the PYTHON_HISTORY environment variable is set and define\n    it as the .python_history file.  If PYTHON_HISTORY is not set, use the\n    default .python_history file.",
        "syntax": "Syntax: gethistoryfile()",
        "other-params": ""
    },
    "site.getsitepackages": {
        "function": "getsitepackages(prefixes=None)",
        "alias": "getsitepackages",
        "help": "Help on function getsitepackages in module site:\n\ngetsitepackages(prefixes=None)\n    Returns a list containing all global site-packages directories.\n\n    For each directory present in ``prefixes`` (or the global ``PREFIXES``),\n    this function will find its `site-packages` subdirectory depending on the\n    system environment, and will return a list of full paths.",
        "syntax": "Syntax: getsitepackages(prefixes=None)",
        "other-params": ""
    },
    "site.getuserbase": {
        "function": "getuserbase()",
        "alias": "getuserbase",
        "help": "Help on function getuserbase in module site:\n\ngetuserbase()\n    Returns the `user base` directory path.\n\n    The `user base` directory can be used to store data. If the global\n    variable ``USER_BASE`` is not initialized yet, this function will also set\n    it.",
        "syntax": "Syntax: getuserbase()",
        "other-params": ""
    },
    "site.getusersitepackages": {
        "function": "getusersitepackages()",
        "alias": "getusersitepackages",
        "help": "Help on function getusersitepackages in module site:\n\ngetusersitepackages()\n    Returns the user-specific site-packages directory path.\n\n    If the global variable ``USER_SITE`` is not initialized yet, this\n    function will also set it.",
        "syntax": "Syntax: getusersitepackages()",
        "other-params": ""
    },
    "site.main": {
        "function": "main()",
        "alias": "main",
        "help": "Help on function main in module site:\n\nmain()\n    Add standard site-specific directories to the module search path.\n\n    This function is called automatically when this module is imported,\n    unless the python interpreter was started with the -S flag.",
        "syntax": "Syntax: main()",
        "other-params": ""
    },
    "site.makepath": {
        "function": "makepath(*paths)",
        "alias": "makepath",
        "help": "Help on function makepath in module site:\n\nmakepath(*paths)",
        "syntax": "Syntax: makepath(*paths)",
        "other-params": ""
    },
    "site.register_readline": {
        "function": "register_readline()",
        "alias": "register_readline",
        "help": "Help on function register_readline in module site:\n\nregister_readline()\n    Configure readline completion on interactive prompts.\n\n    If the readline module can be imported, the hook will set the Tab key\n    as completion key and register ~/.python_history as history file.\n    This can be overridden in the sitecustomize or usercustomize module,\n    or in a PYTHONSTARTUP file.",
        "syntax": "Syntax: register_readline()",
        "other-params": ""
    },
    "site.removeduppaths": {
        "function": "removeduppaths()",
        "alias": "removeduppaths",
        "help": "Help on function removeduppaths in module site:\n\nremoveduppaths()\n    Remove duplicate entries from sys.path along with making them\n    absolute",
        "syntax": "Syntax: removeduppaths()",
        "other-params": ""
    },
    "site.setcopyright": {
        "function": "setcopyright()",
        "alias": "setcopyright",
        "help": "Help on function setcopyright in module site:\n\nsetcopyright()\n    Set 'copyright' and 'credits' in builtins",
        "syntax": "Syntax: setcopyright()",
        "other-params": ""
    },
    "site.sethelper": {
        "function": "sethelper()",
        "alias": "sethelper",
        "help": "Help on function sethelper in module site:\n\nsethelper()",
        "syntax": "Syntax: sethelper()",
        "other-params": ""
    },
    "site.setquit": {
        "function": "setquit()",
        "alias": "setquit",
        "help": "Help on function setquit in module site:\n\nsetquit()\n    Define new builtins 'quit' and 'exit'.\n\n    These are objects which make the interpreter exit when called.\n    The repr of each object contains a hint at how it works.",
        "syntax": "Syntax: setquit()",
        "other-params": ""
    },
    "site.venv": {
        "function": "venv(known_paths)",
        "alias": "venv",
        "help": "Help on function venv in module site:\n\nvenv(known_paths)",
        "syntax": "Syntax: venv(known_paths)",
        "other-params": ""
    }
}